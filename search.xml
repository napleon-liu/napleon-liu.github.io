<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ETH</title>
      <link href="/2023/08/17/ETH/"/>
      <url>/2023/08/17/ETH/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>新一代比特币,实现了去中心化的合约.</p><h2 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC-挖矿</title>
      <link href="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/"/>
      <url>/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p> <img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230806181708790.png" alt="image-20230806181708790"></p><h2 id="比特币调整挖矿难度"><a href="#比特币调整挖矿难度" class="headerlink" title="比特币调整挖矿难度"></a>比特币调整挖矿难度</h2><p>H(block header) &lt;&#x3D; target</p><p>比特币使用SHA-256算法，输出值有256位，结果共有2^256中可能。</p><p>挖矿难度与目标阈值成反比。</p><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><h3 id="全节点"><a href="#全节点" class="headerlink" title="全节点"></a>全节点</h3><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230810143121047.png" alt="image-20230810143121047"></p><h3 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h3><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230810143247194.png" alt="image-20230810143247194"></p><h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230816181732178.png" alt="image-20230816181732178"></p><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;result&quot; : &#123;</span><br><span class="line">&quot;txid&quot;: &quot;021a...dd24&quot;,</span><br><span class="line">&quot;hash&quot;: &quot;021a...dd24&quot;,</span><br><span class="line">&quot;version&quot;: &quot;1&quot;,</span><br><span class="line">&quot;size&quot;: 226,</span><br><span class="line">&quot;locktime&quot;: 0,</span><br><span class="line">&quot;vin&quot;: [...],</span><br><span class="line">&quot;vout&quot;: [...],</span><br><span class="line">&quot;blockhash&quot;: &quot;000000000000002c510d...&quot;,</span><br><span class="line">&quot;confirmations&quot;: 23,</span><br><span class="line">&quot;time&quot;:1530846727,</span><br><span class="line">&quot;blocktime&quot;: 1530846727</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="交易的输入"><a href="#交易的输入" class="headerlink" title="交易的输入"></a>交易的输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;vin&quot; : [&#123;</span><br><span class="line">&quot;txid&quot;: &quot;c0cb...c57b&quot;,</span><br><span class="line">&quot;vout&quot;: 0,</span><br><span class="line">&quot;scriptSig&quot;: &#123;</span><br><span class="line">&quot;asm&quot;: &quot;3045...0018&quot;,</span><br><span class="line">&quot;hex&quot;: &quot;4830...0018&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><h4 id="交易的输出"><a href="#交易的输出" class="headerlink" title="交易的输出"></a>交易的输出</h4><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230816182723205.png" alt="image-20230816182723205"></p><h4 id="转账"><a href="#转账" class="headerlink" title="转账"></a>转账</h4><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230816183210931.png" alt="image-20230816183210931"></p><h2 id="分叉fork"><a href="#分叉fork" class="headerlink" title="分叉fork"></a>分叉fork</h2><h3 id="state-fork"><a href="#state-fork" class="headerlink" title="state fork"></a>state fork</h3><p>对比特币当前状态有意见分析产生的分叉.</p><h3 id="soft-fork"><a href="#soft-fork" class="headerlink" title="soft fork"></a>soft fork</h3><h3 id="hard-fork"><a href="#hard-fork" class="headerlink" title="hard fork"></a>hard fork</h3><h2 id="匿名性"><a href="#匿名性" class="headerlink" title="匿名性"></a>匿名性</h2>]]></content>
      
      
      
        <tags>
            
            <tag> BlockChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC-协议与实现</title>
      <link href="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>虚拟货币需要解决的两个问题：</p><ol><li>谁有权发行货币。</li><li>如何验证交易的合法性。</li></ol><span id="more"></span><h3 id="Double-Spending"><a href="#Double-Spending" class="headerlink" title="Double-Spending"></a>Double-Spending</h3><p>区块链的交易存储方案如下图所示：</p><p> <img src="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230731153829071.png" alt="image-20230731153829071"></p><h3 id="Consensus-in-BitCoin"><a href="#Consensus-in-BitCoin" class="headerlink" title="Consensus in BitCoin"></a>Consensus in BitCoin</h3><h4 id="假设：只有少部分节点是恶意节点"><a href="#假设：只有少部分节点是恶意节点" class="headerlink" title="假设：只有少部分节点是恶意节点"></a>假设：只有少部分节点是恶意节点</h4><p>接受的合法区块必须在最长合法链上。</p><p><img src="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230731161551774.png" alt="image-20230731161551774"></p><p>分叉攻击：通过在区块链中间插入节点，达到回滚的效果。</p><h3 id="等长分叉"><a href="#等长分叉" class="headerlink" title="等长分叉"></a>等长分叉</h3><p>系统中两个矿工同时发布一个区块，分叉会存在一段时间，直至某条分叉胜出。</p><p><img src="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230731161833665.png" alt="image-20230731161833665"></p><p>失败的节点被称为orphan block。</p><h3 id="Bitcoin的实现"><a href="#Bitcoin的实现" class="headerlink" title="Bitcoin的实现"></a>Bitcoin的实现</h3><p>比特币中的全节点要维护UTXO的数据结构</p><h4 id="UTXO：Unspent-Transaction-Output"><a href="#UTXO：Unspent-Transaction-Output" class="headerlink" title="UTXO：Unspent Transaction Output"></a>UTXO：Unspent Transaction Output</h4><p>避免Double-Spending问题。</p><h4 id="Block-headers"><a href="#Block-headers" class="headerlink" title="Block headers"></a>Block headers</h4><p><img src="/image-20230801110417429.png" alt="image-20230801110417429"></p><h4 id="Bernoulli-trial-a-random-experiment-with-binary-outcome"><a href="#Bernoulli-trial-a-random-experiment-with-binary-outcome" class="headerlink" title="Bernoulli trial: a random experiment with binary outcome"></a>Bernoulli trial: a random experiment with binary outcome</h4><h4 id="Bernoulli-process-a-sequence-of-independent-Bernoulli-trials-memoryless"><a href="#Bernoulli-process-a-sequence-of-independent-Bernoulli-trials-memoryless" class="headerlink" title="Bernoulli process: a sequence of independent Bernoulli trials memoryless"></a>Bernoulli process: a sequence of independent Bernoulli trials memoryless</h4><h4 id="Poisson-precess-矿工挖到矿的概率"><a href="#Poisson-precess-矿工挖到矿的概率" class="headerlink" title="Poisson precess(矿工挖到矿的概率)"></a>Poisson precess(矿工挖到矿的概率)</h4><h4 id="exponential-distribution-系统挖到矿的概率"><a href="#exponential-distribution-系统挖到矿的概率" class="headerlink" title="exponential distribution(系统挖到矿的概率)"></a>exponential distribution(系统挖到矿的概率)</h4><p>出块事件服从指数分布。 </p><p>指数分布的无记忆性保证了挖矿的公平性。</p><h4 id="Bitcoin-is-secured-by-mining"><a href="#Bitcoin-is-secured-by-mining" class="headerlink" title="Bitcoin is secured by mining"></a>Bitcoin is secured by mining</h4><h4 id="six-confirmation-防范double-spending问题"><a href="#six-confirmation-防范double-spending问题" class="headerlink" title="six confirmation 防范double-spending问题"></a>six confirmation 防范double-spending问题</h4><p> <img src="/image-20230801112639365.png" alt="image-20230801112639365"></p><p>等待6个confirmation平均要等1个小时。</p><h4 id="selfish-mining"><a href="#selfish-mining" class="headerlink" title="selfish mining"></a>selfish mining</h4><p>造成分块攻击。</p><p>误导别的矿工无用功，减少竞争。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go标准库-os</title>
      <link href="/2023/07/31/go%E6%A0%87%E5%87%86%E5%BA%93-os/"/>
      <url>/2023/07/31/go%E6%A0%87%E5%87%86%E5%BA%93-os/</url>
      
        <content type="html"><![CDATA[<p>os包提供了操作系统函数的不依赖平台的接口。设计为Unix风格的，虽然错误处理是go风格的；失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。例如，如果某个使用一个文件名的调用（如Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为*PathError，其内部可以解包获得更多信息。</p><span id="more"></span><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>用于包装底层系统的参数用于Open函数，不是所有的flag都能在特定系统里使用的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SEEK_SET <span class="type">int</span> = <span class="number">0</span> <span class="comment">// 相对于文件起始位置seek</span></span><br><span class="line">    SEEK_CUR <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 相对于文件当前位置seek</span></span><br><span class="line">    SEEK_END <span class="type">int</span> = <span class="number">2</span> <span class="comment">// 相对于文件结尾位置seek</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>指定Seek函数从何处开始搜索（即相对位置）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PathSeparator     = <span class="string">&#x27;/&#x27;</span> <span class="comment">// 操作系统指定的路径分隔符</span></span><br><span class="line">    PathListSeparator = <span class="string">&#x27;:&#x27;</span> <span class="comment">// 操作系统指定的表分隔符</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInvalid    = errors.New(<span class="string">&quot;invalid argument&quot;</span>)</span><br><span class="line">    ErrPermission = errors.New(<span class="string">&quot;permission denied&quot;</span>)</span><br><span class="line">    ErrExist      = errors.New(<span class="string">&quot;file already exists&quot;</span>)</span><br><span class="line">    ErrNotExist   = errors.New(<span class="string">&quot;file does not exist&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="func-Hostname"><a href="#func-Hostname" class="headerlink" title="func Hostname"></a>func <a href="https://github.com/golang/go/blob/master/src/os/doc.go?name=release#92">Hostname</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Hostname() (name string, err error)</span><br></pre></td></tr></table></figure><p>Hostname返回内核提供的主机名。</p><h3 id="func-Getpagesize"><a href="#func-Getpagesize" class="headerlink" title="func Getpagesize"></a>func <a href="https://github.com/golang/go/blob/master/src/os/types.go?name=release#13">Getpagesize</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpagesize() int</span><br></pre></td></tr></table></figure><p>Getpagesize返回底层的系统内存页的尺寸。</p><h3 id="func-Environ"><a href="#func-Environ" class="headerlink" title="func Environ"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#101">Environ</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Environ() []string</span><br></pre></td></tr></table></figure><p>Environ返回表示环境变量的格式为”key&#x3D;value”的字符串的切片拷贝。</p><h3 id="func-Getenv"><a href="#func-Getenv" class="headerlink" title="func Getenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#79">Getenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getenv(key string) string</span><br></pre></td></tr></table></figure><p>Getenv检索并返回名为key的环境变量的值。如果不存在该环境变量会返回空字符串。</p><h3 id="func-Setenv"><a href="#func-Setenv" class="headerlink" title="func Setenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#86">Setenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Setenv(key, value string) error</span><br></pre></td></tr></table></figure><p>Setenv设置名为key的环境变量。如果出错会返回该错误。</p><h3 id="func-Clearenv"><a href="#func-Clearenv" class="headerlink" title="func Clearenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#95">Clearenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Clearenv()</span><br></pre></td></tr></table></figure><p>Clearenv删除所有环境变量。</p><h3 id="func-Exit"><a href="#func-Exit" class="headerlink" title="func Exit"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#36">Exit</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Exit(code int)</span><br></pre></td></tr></table></figure><p>Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行。</p><h3 id="func-Expand"><a href="#func-Expand" class="headerlink" title="func Expand"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#13">Expand</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Expand(s string, mapping func(string) string) string</span><br></pre></td></tr></table></figure><p>Expand函数替换s中的${var}或$var为mapping(var)。例如，os.ExpandEnv(s)等价于os.Expand(s, os.Getenv)。</p><h3 id="func-ExpandEnv"><a href="#func-ExpandEnv" class="headerlink" title="func ExpandEnv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#32">ExpandEnv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ExpandEnv(s string) string</span><br></pre></td></tr></table></figure><p>ExpandEnv函数替换s中的${var}或$var为名为var 的环境变量的值。引用未定义环境变量会被替换为空字符串。</p><h3 id="func-Getuid"><a href="#func-Getuid" class="headerlink" title="func Getuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#15">Getuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getuid() int</span><br></pre></td></tr></table></figure><p>Getuid返回调用者的用户ID。</p><h3 id="func-Geteuid"><a href="#func-Geteuid" class="headerlink" title="func Geteuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#18">Geteuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Geteuid() int</span><br></pre></td></tr></table></figure><p>Geteuid返回调用者的有效用户ID。</p><h3 id="func-Getgid"><a href="#func-Getgid" class="headerlink" title="func Getgid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#21">Getgid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgid() int</span><br></pre></td></tr></table></figure><p>Getgid返回调用者的组ID。</p><h3 id="func-Getegid"><a href="#func-Getegid" class="headerlink" title="func Getegid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#24">Getegid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getegid() int</span><br></pre></td></tr></table></figure><p>Getegid返回调用者的有效组ID。</p><h3 id="func-Getgroups"><a href="#func-Getgroups" class="headerlink" title="func Getgroups"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#27">Getgroups</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgroups() ([]int, error)</span><br></pre></td></tr></table></figure><p>Getgroups返回调用者所属的所有用户组的组ID。</p><h3 id="func-Getpid"><a href="#func-Getpid" class="headerlink" title="func Getpid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#67">Getpid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpid() int</span><br></pre></td></tr></table></figure><p>Getpid返回调用者所在进程的进程ID。</p><h3 id="func-Getppid"><a href="#func-Getppid" class="headerlink" title="func Getppid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#70">Getppid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getppid() int</span><br></pre></td></tr></table></figure><p>Getppid返回调用者所在进程的父进程的进程ID。</p><h3 id="type-Signal"><a href="#type-Signal" class="headerlink" title="type Signal"></a>type <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#61">Signal</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Signal interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">    Signal() // 用来区分其他实现了Stringer接口的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signal代表一个操作系统信号。一般其底层实现是依赖于操作系统的：在Unix中，它是syscall.Signal类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    Interrupt Signal = syscall.SIGINT</span><br><span class="line">    Kill      Signal = syscall.SIGKILL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>仅有的肯定会被所有操作系统提供的信号，Interrupt（中断信号）和Kill（强制退出信号）。</p><h3 id="func-Hostname-1"><a href="#func-Hostname-1" class="headerlink" title="func Hostname"></a>func <a href="https://github.com/golang/go/blob/master/src/os/doc.go?name=release#92">Hostname</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Hostname() (name string, err error)</span><br></pre></td></tr></table></figure><p>Hostname返回内核提供的主机名。</p><h3 id="func-Getpagesize-1"><a href="#func-Getpagesize-1" class="headerlink" title="func Getpagesize"></a>func <a href="https://github.com/golang/go/blob/master/src/os/types.go?name=release#13">Getpagesize</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpagesize() int</span><br></pre></td></tr></table></figure><p>Getpagesize返回底层的系统内存页的尺寸。</p><h3 id="func-Environ-1"><a href="#func-Environ-1" class="headerlink" title="func Environ"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#101">Environ</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Environ() []string</span><br></pre></td></tr></table></figure><p>Environ返回表示环境变量的格式为”key&#x3D;value”的字符串的切片拷贝。</p><h3 id="func-Getenv-1"><a href="#func-Getenv-1" class="headerlink" title="func Getenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#79">Getenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getenv(key string) string</span><br></pre></td></tr></table></figure><p>Getenv检索并返回名为key的环境变量的值。如果不存在该环境变量会返回空字符串。</p><h3 id="func-Setenv-1"><a href="#func-Setenv-1" class="headerlink" title="func Setenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#86">Setenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Setenv(key, value string) error</span><br></pre></td></tr></table></figure><p>Setenv设置名为key的环境变量。如果出错会返回该错误。</p><h3 id="func-Clearenv-1"><a href="#func-Clearenv-1" class="headerlink" title="func Clearenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#95">Clearenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Clearenv()</span><br></pre></td></tr></table></figure><p>Clearenv删除所有环境变量。</p><h3 id="func-Exit-1"><a href="#func-Exit-1" class="headerlink" title="func Exit"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#36">Exit</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Exit(code int)</span><br></pre></td></tr></table></figure><p>Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行。</p><h3 id="func-Expand-1"><a href="#func-Expand-1" class="headerlink" title="func Expand"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#13">Expand</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Expand(s string, mapping func(string) string) string</span><br></pre></td></tr></table></figure><p>Expand函数替换s中的${var}或$var为mapping(var)。例如，os.ExpandEnv(s)等价于os.Expand(s, os.Getenv)。</p><h3 id="func-ExpandEnv-1"><a href="#func-ExpandEnv-1" class="headerlink" title="func ExpandEnv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#32">ExpandEnv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ExpandEnv(s string) string</span><br></pre></td></tr></table></figure><p>ExpandEnv函数替换s中的${var}或$var为名为var 的环境变量的值。引用未定义环境变量会被替换为空字符串。</p><h3 id="func-Getuid-1"><a href="#func-Getuid-1" class="headerlink" title="func Getuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#15">Getuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getuid() int</span><br></pre></td></tr></table></figure><p>Getuid返回调用者的用户ID。</p><h3 id="func-Geteuid-1"><a href="#func-Geteuid-1" class="headerlink" title="func Geteuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#18">Geteuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Geteuid() int</span><br></pre></td></tr></table></figure><p>Geteuid返回调用者的有效用户ID。</p><h3 id="func-Getgid-1"><a href="#func-Getgid-1" class="headerlink" title="func Getgid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#21">Getgid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgid() int</span><br></pre></td></tr></table></figure><p>Getgid返回调用者的组ID。</p><h3 id="func-Getegid-1"><a href="#func-Getegid-1" class="headerlink" title="func Getegid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#24">Getegid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getegid() int</span><br></pre></td></tr></table></figure><p>Getegid返回调用者的有效组ID。</p><h3 id="func-Getgroups-1"><a href="#func-Getgroups-1" class="headerlink" title="func Getgroups"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#27">Getgroups</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgroups() ([]int, error)</span><br></pre></td></tr></table></figure><p>Getgroups返回调用者所属的所有用户组的组ID。</p><h3 id="func-Getpid-1"><a href="#func-Getpid-1" class="headerlink" title="func Getpid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#67">Getpid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpid() int</span><br></pre></td></tr></table></figure><p>Getpid返回调用者所在进程的进程ID。</p><h3 id="func-Getppid-1"><a href="#func-Getppid-1" class="headerlink" title="func Getppid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#70">Getppid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getppid() int</span><br></pre></td></tr></table></figure><p>Getppid返回调用者所在进程的父进程的进程ID。</p><h3 id="type-Signal-1"><a href="#type-Signal-1" class="headerlink" title="type Signal"></a>type <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#61">Signal</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Signal interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">    Signal() // 用来区分其他实现了Stringer接口的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signal代表一个操作系统信号。一般其底层实现是依赖于操作系统的：在Unix中，它是syscall.Signal类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    Interrupt Signal = syscall.SIGINT</span><br><span class="line">    Kill      Signal = syscall.SIGKILL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>仅有的肯定会被所有操作系统提供的信号，Interrupt（中断信号）和Kill（强制退出信号）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础语法面试题</title>
      <link href="/2023/07/30/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/07/30/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Go有异常类型吗"><a href="#Go有异常类型吗" class="headerlink" title="Go有异常类型吗"></a>Go有异常类型吗</h1><p>Go没有异常类型，只有错误类型(Error)，通常使用返回值来表示异常状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么是协程Goroutine"><a href="#什么是协程Goroutine" class="headerlink" title="什么是协程Goroutine"></a>什么是协程Goroutine</h1><p>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p><h1 id="如何高效地拼接字符串"><a href="#如何高效地拼接字符串" class="headerlink" title="如何高效地拼接字符串"></a>如何高效地拼接字符串</h1><p>在Go中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应该使用string.Builder，最小化内存拷贝次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    str.WriteString(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h1 id="什么是rune类型"><a href="#什么是rune类型" class="headerlink" title="什么是rune类型"></a>什么是rune类型</h1><p>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。</p><h1 id="如何判断map中是否包含某个key"><a href="#如何判断map中是否包含某个key" class="headerlink" title="如何判断map中是否包含某个key"></a>如何判断map中是否包含某个key</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> val, ok := dict[<span class="string">&quot;foo&quot;</span>]; ok &#123;</span><br><span class="line">    <span class="comment">//do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dict[“foo”] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key “foo”，val 将被赋予 “foo” 对应的值。</p><h1 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h1><ul><li>多个defer语句，遵从后进先出(Last in First Out, LIFO)的原则，最后声明的defer语句，最先得到执行。</li><li>defer在return语句执行后执行，但在函数退出之前，defer可以修改返回值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;return&quot;</span>, test())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defer2</span></span><br><span class="line"><span class="comment">// defer1</span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure><h1 id="如何交换两个变量的值"><a href="#如何交换两个变量的值" class="headerlink" title="如何交换两个变量的值"></a>如何交换两个变量的值</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b := <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span></span><br><span class="line">a, b = b, a</span><br><span class="line">fmt.Println(a, b) <span class="comment">// B A</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux打包和压缩</title>
      <link href="/2023/07/29/Linux%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/"/>
      <url>/2023/07/29/Linux%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="tar命令做打包操作"><a href="#tar命令做打包操作" class="headerlink" title="tar命令做打包操作"></a>tar命令做打包操作</h1><p>该命令的基本格式为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 源文件或目录</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>将多个文件或目录进行打包。</td></tr><tr><td>-A</td><td>追加 tar 文件到归档文件。</td></tr><tr><td>-f 包名</td><td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td></tr><tr><td>-v</td><td>显示打包文件过程；</td></tr></tbody></table><h1 id="tar命令做解打包操作"><a href="#tar命令做解打包操作" class="headerlink" title="tar命令做解打包操作"></a>tar命令做解打包操作</h1><p>该命令的基本格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 压缩包</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-x</td><td>对 tar 包做解打包操作。</td></tr><tr><td>-f</td><td>指定要解压的 tar 包的包名。</td></tr><tr><td>-t</td><td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td></tr><tr><td>-C 目录</td><td>指定解打包位置。</td></tr><tr><td>-v</td><td>显示解打包的具体过程。</td></tr></tbody></table><p>其实解打包和打包相比，只是把打包选项 “-cvf” 更换为 “-xvf”。我们来试试： </p><h1 id="zip压缩文件或目录"><a href="#zip压缩文件或目录" class="headerlink" title="zip压缩文件或目录"></a>zip压缩文件或目录</h1><p>zip命令的基本格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#zip [选项] 压缩包名 源文件或源目录列表</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td></tr><tr><td>-m</td><td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td></tr><tr><td>-v</td><td>显示详细的压缩过程信息。</td></tr><tr><td>-q</td><td>在压缩的时候不显示命令的执行过程。</td></tr><tr><td>-压缩级别</td><td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td></tr><tr><td>-u</td><td>更新压缩文件，即往压缩文件中添加新文件。</td></tr></tbody></table><p>使用 zip 命令压缩目录，需要使用“-r”选项，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment">#建立测试目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># zip -r dir1.zip dir1</span></span><br><span class="line">adding: dir1/(stored 0%)</span><br><span class="line"><span class="comment">#压缩目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -dl dir1.zip</span></span><br><span class="line">-rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip</span><br><span class="line"><span class="comment">#压缩文件生成</span></span><br></pre></td></tr></table></figure><h1 id="unzip解压文件"><a href="#unzip解压文件" class="headerlink" title="unzip解压文件"></a>unzip解压文件</h1><p>unzip 命令可以查看和解压缩 zip 文件。该命令的基本格式如下：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d 目录名</td><td>将压缩文件解压到指定目录下。</td></tr><tr><td>-n</td><td>解压时并不覆盖已经存在的文件。</td></tr><tr><td>-o</td><td>解压时覆盖已经存在的文件，并且无需用户确认。</td></tr><tr><td>-v</td><td>查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td></tr><tr><td>-t</td><td>测试压缩文件有无损坏，但并不解压。</td></tr><tr><td>-x 文件列表</td><td>解压文件，但不包含文件列表中指定的文件。</td></tr></tbody></table><p>使用 -d 选项手动指定解压缩位置，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># unzip -d /tmp/ ana.zip</span></span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line"><span class="comment">#把压缩包解压到指定位置</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统</title>
      <link href="/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Linux文件目录结构"><a href="#Linux文件目录结构" class="headerlink" title="Linux文件目录结构"></a>Linux文件目录结构</h1><p><img src="/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p><ul><li><strong>&#x2F;bin</strong></li></ul><p>bin是Binaries的缩写，这个目录存放着最经常使用的命令。</p><ul><li><strong>&#x2F;boot</strong></li></ul><p>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><ul><li><strong>&#x2F;dev</strong></li></ul><p>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p><ul><li><strong>&#x2F;etc</strong></li></ul><p>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><ul><li><strong>&#x2F;home</strong></li></ul><p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p><ul><li><strong>&#x2F;lib</strong></li></ul><p>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><ul><li><strong>&#x2F;lost+found</strong></li></ul><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><ul><li><strong>&#x2F;media</strong></li></ul><p>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p><ul><li><strong>&#x2F;mnt</strong></li></ul><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p><ul><li><strong>&#x2F;opt</strong></li></ul><p>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p><ul><li><strong>&#x2F;proc</strong></li></ul><p>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件。</p><ul><li><strong>&#x2F;root</strong></li></ul><p>该目录为系统管理员，也称作超级权限者的用户主目录。</p><ul><li><strong>&#x2F;sbin</strong></li></ul><p>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p><ul><li><strong>&#x2F;var</strong></li></ul><p>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p><ul><li><strong>&#x2F;usr</strong></li></ul><p> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p><ul><li><strong>&#x2F;srv</strong></li></ul><p>该目录存放一些服务启动之后需要提取的数据。</p><ul><li><strong>&#x2F;temp</strong></li></ul><p>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p><h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><p><strong>在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</strong></p><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p><p>举个例子，我们想通过命令行访问某个 U 盘中的数据，图 1 所示为 U 盘文件目录结构和 Linux 系统中的文件目录结构。</p><p><img src="/2-1Z321130921V9-1690619380227-6.gif" alt="U 盘和 Linux 系统文件目录结构"></p><p>图 1 中可以看到，目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。</p><p>接下来，我们在根目录下新建一个目录 &#x2F;sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，挂载效果如图 2 所示。</p><p><img src="/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2-1Z321130I44B.gif" alt="文件系统挂载"></p><p>可以看到，U 盘文件系统已经成为 Linux 文件系统目录的一部分，此时访问 &#x2F;sdb-u&#x2F; 就等同于访问 U 盘。</p><p>前面讲过，根目录下的 &#x2F;dev&#x2F; 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件（比如 sdb1），就位于 &#x2F;dev&#x2F; 目录下（&#x2F;dev&#x2F;sdb1），但无法通过 &#x2F;dev&#x2F;sdb1&#x2F; 直接访问 U 盘数据，访问此目录只会提供给你此设备的一些基本信息（比如容量）。</p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>umount 命令用于卸载已经挂载的硬件设备，该命令的基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# umount 设备文件名或挂载点</span><br></pre></td></tr></table></figure><p>注意，卸载命令后面既可以加设备文件名，也可以加挂载点，不过只能二选一，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# umount /mnt/usb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载U盘</span></span><br><span class="line">[root@localhost ~]# umount /mnt/cdrom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载光盘</span></span><br><span class="line">[root@localhost ~]# umount /dev/sr0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令加设备文件名同样是可以卸载的</span></span><br></pre></td></tr></table></figure><h1 id="修复文件系统"><a href="#修复文件系统" class="headerlink" title="修复文件系统"></a>修复文件系统</h1><p>fsck 命令用于检查文件系统并尝试修复出现的错误。该命令的基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fsck [选项] 分区设备文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>自动修复文件系统，没有任何提示信息。</td></tr><tr><td>-r</td><td>采取互动的修复模式，在修改文件前会进行询问，让用户得以确认并决定处理方式。</td></tr><tr><td>-A（大写）</td><td>按照 &#x2F;etc&#x2F;fstab 配置文件的内容，检查文件内罗列的全部文件系统。</td></tr><tr><td>-t 文件系统类型</td><td>指定要检查的文件系统类型。</td></tr><tr><td>-C（大写）</td><td>显示检查分区的进度条。</td></tr><tr><td>-f</td><td>强制检测，一般 fsck 命令如果没有发现分区有问题，则是不会检测的。如果强制检测，那么不管是否发现问题，都会检测。</td></tr><tr><td>-y</td><td>自动修复，和 -a 作用一致，不过有些文件系统只支持 -y。</td></tr></tbody></table><p>需要注意的是，在使用 fsck 命令修改某文件系统时，这个文件系统对应的磁盘分区一定要处于卸载状态，磁盘分区在挂载状态下进行修复是非常不安全的，数据可能会遭到破坏，也有可能会损坏磁盘。</p><p>这里，给大家举个例子，如果想要修复某个分区，则只需执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#fsck -r /dev/sdb1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">采用互动的修复模式</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC中的密码学原理与数据结构</title>
      <link href="/2023/07/28/BTC%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/28/BTC%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希函数性质"><a href="#哈希函数性质" class="headerlink" title="哈希函数性质"></a>哈希函数性质</h1><h2 id="collision-resistance"><a href="#collision-resistance" class="headerlink" title="collision resistance"></a>collision resistance</h2><p>没有hash collision。</p><h2 id="hiding"><a href="#hiding" class="headerlink" title="hiding"></a>hiding</h2><p>hash过程是单向的。</p><h2 id="puzzle-friendly"><a href="#puzzle-friendly" class="headerlink" title="puzzle friendly"></a>puzzle friendly</h2><p>H(x)的判断不可预测。为了实现proof of works</p><h2 id="difficult-to-soulve-but-easy-to-prove"><a href="#difficult-to-soulve-but-easy-to-prove" class="headerlink" title="difficult to soulve, but easy to prove"></a>difficult to soulve, but easy to prove</h2><h1 id="SHA-256"><a href="#SHA-256" class="headerlink" title="SHA-256"></a>SHA-256</h1><p>Secure Hash Algorithm满足上述三种性质。</p><h1 id="Bitcorn中的账户"><a href="#Bitcorn中的账户" class="headerlink" title="Bitcorn中的账户"></a>Bitcorn中的账户</h1><p>分布式账户，创建一个公私钥对(public key, private key)。无需第三方机构批准。 </p><h1 id="Hash-Pointers"><a href="#Hash-Pointers" class="headerlink" title="Hash Pointers"></a>Hash Pointers</h1><p>区块链是使用哈希指针的链表。</p><p><img src="/2023/07/28/BTC%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/image-20230728211622268.png" alt="image-20230728211622268"></p><h1 id="Merkle-tree"><a href="#Merkle-tree" class="headerlink" title="Merkle tree"></a>Merkle tree</h1><p><img src="/2023/07/28/BTC%E4%B8%AD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/image-20230728212558372.png" alt="image-20230728212558372"></p><p>只要有根hash值，就能检测出对树中任何位置的修改</p><h2 id="Merkle-proof"><a href="#Merkle-proof" class="headerlink" title="Merkle proof"></a>Merkle proof</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约</title>
      <link href="/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
      <url>/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约模型"><a href="#智能合约模型" class="headerlink" title="智能合约模型"></a>智能合约模型</h1><p>本质上是一个运行在区块链上的分布式应用。</p><h2 id="区块链：分布式账本"><a href="#区块链：分布式账本" class="headerlink" title="区块链：分布式账本"></a>区块链：分布式账本</h2><p>区块(Block)</p><p>Previous Hash, Data, Hash</p><p>账户(Account)</p><p>Address, Balance</p><p><img src="/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A8%A1%E5%9E%8B.png" alt="区块链模型"></p><h2 id="以太坊账户模型"><a href="#以太坊账户模型" class="headerlink" title="以太坊账户模型"></a>以太坊账户模型</h2><p><strong>EOA</strong></p><p>拥有非对称密钥对的用户实体。</p><p><strong>COA</strong></p><p>合约字节码（Code Hash）</p><p>持久化存储（Storage Root）</p><p><img src="/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B.png" alt="以太坊账户模型"></p><h2 id="交易的基本格式"><a href="#交易的基本格式" class="headerlink" title="交易的基本格式"></a>交易的基本格式</h2><p><strong>Hash</strong></p><p>交易标识</p><p><strong>From</strong></p><p>发送交易的账户，需要用私钥为这笔交易签名</p><p><strong>to</strong></p><p>目的账户</p><p><strong>Value</strong></p><p>以太币数量</p><p><strong>Calldata</strong></p><p>字节流格式的输入</p><p><strong>Gas</strong></p><p>支付给矿工的手续费</p><p><strong>GasPrice</strong></p><p>Gas的单位价格，以Ether标识</p><p><strong>Logs</strong></p><p>被触发的事件</p><h1 id="执行-amp-调试智能合约"><a href="#执行-amp-调试智能合约" class="headerlink" title="执行&amp;调试智能合约"></a>执行&amp;调试智能合约</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶</title>
      <link href="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/07/27/Redis%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB-Redis-Database"><a href="#RDB-Redis-Database" class="headerlink" title="RDB(Redis Database)"></a>RDB(Redis Database)</h2><blockquote><p>触发机制</p></blockquote><ol><li>save规则满足的情况下,会自动触发rdb规则</li><li>执行flushall命令,也会触发rdb规则</li><li>退出redis,也会产生rdb文件</li></ol><blockquote><p>恢复rdb文件</p></blockquote><ol><li>将rdb文件存放在redis的启动目录</li><li>查看需要存在的位置</li></ol><p><img src="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/v2-1057d3d1a5e4d84745156b65867a6f55_720w.webp" alt="img"></p><h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h2><p>以日志的形式记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录),只许追加文件而不可以改写文件,Redis启动之初会读取该文件重新构建数据.</p><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p><strong>Redis发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接受消息。</strong></p><p><img src="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/v2-29130c54042bd99251f5dd80a7d801cf_b.jpg" alt="img"></p><p><strong>订阅端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE dingdada  <span class="comment">#订阅名字为 dingdada 的频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;dingdada&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#等待推送的信息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span>  <span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;dingdada&quot;</span>  <span class="comment">#来自哪个频道的消息</span></span><br><span class="line">3) <span class="string">&quot;hello world\xef\xbc\x81&quot;</span>  <span class="comment"># 消息的具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;dingdada&quot;</span></span><br><span class="line">3) <span class="string">&quot;my name is dyj\x81&quot;</span></span><br></pre></td></tr></table></figure><p><strong>发送端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH dingdada <span class="string">&quot;hello world！&quot;</span>  <span class="comment">#发送消息到dingdada 频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH dingdada <span class="string">&quot;my name is dyj&quot;</span>  <span class="comment">#发送消息到dingdada 频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制是指将一台Redis服务器的数据,复制到其他的Redis服务器,前者称为master,后者称为slave.数据的复制是单向的,只能从主节点到从节点.Master以写为主,Slave以读为主.</p><p><img src="/image-20230819225131566.png" alt="image-20230819225131566"></p><p>主从复制,读写分离.实战中80%的业务都是读操作,利用仆从服务器减缓服务器的压力</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li>数据冗余:实现了数据的热备份,是持久化之外的一种数据冗余方式</li><li>故障恢复:当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复,实际上是一种服务的冗余</li><li>负载均衡:在主从复制的基础上,配合读写分离,可以由主节点提供写服务,由从节点提供读服务,分担服务器负载</li><li>高可用基石:主从复制是哨兵和集群能够实施的基础,因此说主从复制是Redis高可用的基础</li></ol><h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><strong>默认情况下,每台Redis服务器都是主节点</strong></p><p> 配置从机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF 127.0.0.1 6380 <span class="comment"># SLAVEOF host port</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6380</span><br><span class="line">master_link_status:down</span><br><span class="line">master_last_io_seconds_ago:-1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">master_link_down_since_seconds:-1</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:0ba4b5624f5e254be973621bb67263125a86df74</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>哨兵模式是一种特殊的模式,首先Redis提供了哨兵的命令,哨兵是一个独立的进程,作为进程,它会独立运行.其原理是哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例.</p><p> <img src="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/image-20230820140455722.png" alt="image-20230820140455722"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>配置哨兵配置文件sentinel.conf</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># senrinel monitor name host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ol start="2"><li>启动哨兵</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-内存管理</title>
      <link href="/2023/07/26/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/26/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Go 的内存是自动管理的，我们可以随意定义变量直接使用，不需要考虑变量背后的内存申请和释放的问题。本文意在搞清楚 Go 在方面帮我们做了什么，使我们不用关心那些复杂内存的问题，还依旧能写出较为高效的程序。</p><h1 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h1><p>程序动态申请内存空间，是要使用系统调用的，比如 Linux 系统上是调用 mmap 方法实现的。但对于大型系统服务来说，直接调用 mmap 申请内存，会有一定的代价。比如：</p><ul><li>内核态与用户态之间的切换浪费系统资源</li><li>频繁申请小块内存空间容易造成内存碎片</li><li>为了保证内存访问具有良好的局部性，开发者需要投入大量的精力去做优化，这是一个很重的负担。</li></ul><p>解决方案：<strong>对象池</strong>（缓存）。</p><p>假设系统需要频繁动态申请内存来存放一个数据结构，比如 [10]int 。那么我们完全可以在程序启动之初，一次性申请几百甚至上千个 [10]int 。这样完美的解决了上面遇到的问题：</p><ol><li>不需要频繁申请内存了，而是从对象池里拿，程序不会频繁进入内核态。</li><li>因为一次性申请一个连续的大空间，对象池会被重复利用，不会出现碎片。</li><li>程序频繁访问的就是对象池背后的同一块内存空间，局部性良好。</li></ol><h1 id="Golang内存管理"><a href="#Golang内存管理" class="headerlink" title="Golang内存管理"></a>Golang内存管理</h1><p>Golang 的内存管理本质上就是一个内存池，只不过内部做了很多的优化。比如自动伸缩内存池大小，合理的切割内存块等等。</p><h2 id="内存池mheap"><a href="#内存池mheap" class="headerlink" title="内存池mheap"></a>内存池mheap</h2><p>Golang的程序在启动时，会一次性从操作系统申请一大块内存作为内存池。这块内存空间会放在一个叫mheap的struct中管理，mheap负责将这一块内存切割成不同的区域，并将其中一部分的内存切割成合适的大小。</p><p>关于mheap的几个重要概念：</p><p><strong>page</strong>：内存页，一块8K大小的内存空间。</p><p><strong>span</strong>: 一个或者多个连续的page。</p><p><strong>sizeclass</strong>：空间规格，标记span中的page应该如何使用。</p><p><strong>object</strong>：对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object 。假设 object 的大小是 16B ， span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去。</p><p>示意图：</p><p>内部的整体内存布局如下图所示：</p><ul><li>mheap.spans: 存储page和span信息，比如一个span的起始地址，page数目。</li><li>mheap.bitmap: 存储着各个span中对象的标记信息，比如对象是否可回收。</li><li>mheap.arena_start: 将要分配给应用程序使用的空间。</li></ul><h2 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h2><p><strong>用途相同</strong>的span会以链表的形式组织在一起。这里的用途用sizeclass来表示。</p><p>比如当分配一块大小为 n 的内存时，系统计算 n 应该使用哪种 sizeclass ，然后根据 sizeclass 的值去找到一个可用的 span 来用作分配。其中 sizeclass 一共有 67 种(Go1.5)，如图所示：</p><p>找到合适的 span 后，会从中取一个 object 返回给上层使用。这些 span 被放在一个叫做 mcentral 的结构中管理。</p><p>mheap 将从 OS 那里申请过来的内存初始化成一个大 span (sizeclass&#x3D;0)。然后根据需要从这个大 span 中切出小 span ，放在 mcentral 中来管理。大 span 由 mheap.freelarge 和 mheap.busylarge 等管理。如果 mcentral 中的 span 不够用了，会从 mheap.freelarge 上再切一块，如果 mheap.freelarge 空间不够，会再次从 OS 那里申请内存重复上述步骤。下面是 mheap 和 mcentral 的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">GO</span><br><span class="line">type mheap struct &#123;</span><br><span class="line"></span><br><span class="line">// other fields</span><br><span class="line"></span><br><span class="line">   lock    mutex</span><br><span class="line"></span><br><span class="line">   free    [_MaxMHeapList]mspan // free lists of given length， 1M 以下</span><br><span class="line"></span><br><span class="line">   freelarge mspan         // free lists length &gt;= _MaxMHeapList, &gt;= 1M</span><br><span class="line"></span><br><span class="line">   busy    [_MaxMHeapList]mspan // busy lists of large objects of given length</span><br><span class="line"></span><br><span class="line">   busylarge mspan         // busy lists of large objects length &gt;= _MaxMHeapList</span><br><span class="line"></span><br><span class="line">   central [_NumSizeClasses]struct &#123;// _NumSizeClasses = 67</span><br><span class="line"></span><br><span class="line">     mcentral mcentral</span><br><span class="line"></span><br><span class="line">// other fields</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// other fields</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Central list of free objects of a given size.</span><br><span class="line"></span><br><span class="line">type mcentral struct &#123;</span><br><span class="line"></span><br><span class="line">   lock    mutex // 分配时需要加锁</span><br><span class="line"></span><br><span class="line">   sizeclass int32 // 哪种 sizeclass</span><br><span class="line"></span><br><span class="line">   nonempty  mspan // 还有可用的空间的 span 链表</span><br><span class="line"></span><br><span class="line">   empty   mspan // 没有可用的空间的 span 列表</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h2><p>mcental中有一个lock字段，在高并发场景下必要时用锁来避免冲突。</p><p>但是锁是低效的，在高并发的服务中，它会使内存申请成为整个系统的瓶颈；所以在mcentral的前面又加了一层mchache。</p><p>每一个 mcache 和每一个处理器(P) 是一一对应的，也就是说每一个 P 都有一个 mcache 成员。 Goroutine 申请内存时，首先从其所在的 P 的 mcache 中分配，如果 mcache 没有可用 span ，再从 mcentral 中获取，并填充到 mcache 中。</p><p>从 mcache 上分配内存空间是不需要加锁的，因为在同一时间里，一个 P 只有一个线程在其上面运行，不可能出现竞争。没有了锁的限制，大大加速了内存分配。</p><h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><h2 id="Tiny对象"><a href="#Tiny对象" class="headerlink" title="Tiny对象"></a>Tiny对象</h2><p>面提到的 sizeclass&#x3D;1 的 span，用来给 &lt;&#x3D; 8B 的对象使用，所以像 int32 , byte , bool 以及小字符串等常用的微小对象，都会使用 sizeclass&#x3D;1 的 span，但分配给他们 8B 的空间，大部分是用不上的。并且这些类型使用频率非常高，就会导致出现大量的内部碎片。</p><p>所以 Go 尽量不使用 sizeclass&#x3D;1 的 span， 而是将 &lt; 16B 的对象为统一视为 tiny 对象(tinysize)。配时，从 sizeclass&#x3D;2 的 span 中获取一个 16B 的 object 用以分配。如果存储的对象小于 16B ，这个空间会被暂时保存起来 (mcache.tiny 字段)，下次分配时会复用这个空间，直到这个 object 用完为止。</p><h2 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h2><p>如上面所述，最大的 sizeclass 最大只能存放 32K 的对象。如果一次性申请超过 32K 的内存，系统会直接绕过 mcache 和 mcentral，直接从 mheap 上获取，mheap 中有一个 freelarge 字段管理着超大 span。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2023/07/24/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/24/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h1><p>NOSQL &#x3D; Not Only SQL</p><p>非关系型数据库,为了面对高并发社区.</p><h1 id="Redis的基本数据类型"><a href="#Redis的基本数据类型" class="headerlink" title="Redis的基本数据类型"></a>Redis的基本数据类型</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>判断一个键是否存在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXISTS</span> key</span><br></pre></td></tr></table></figure><p>删除键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key [key...]</span><br></pre></td></tr></table></figure><p>获得键值的数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类型是其他4种数据类型的基础，其他数据类型和字符串类 型的差别从某种角度来说只是组织字符串的形式不同。例如，列表类 型是以列表的形式组织字符串，而集合类型是以集合的形式组织字符串。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol><li>赋值与查询</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> KEY <span class="keyword">VALUE</span></span><br><span class="line"><span class="keyword">GET</span> KEY</span><br></pre></td></tr></table></figure><ol start="2"><li>递增数字</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR NUM</span><br></pre></td></tr></table></figure><p>当要操作的键不存在时会默认键值为0，所以第一次递增后的结果 是1。当键值不是整数时Redis会提示错误。</p><ol start="3"><li>增加&#x2F;减少指定的整数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCRBY KEY INCREMENT</span><br><span class="line">DECRBY KEY DECREMENT</span><br></pre></td></tr></table></figure><ol start="4"><li>增加指定浮点数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure><ol start="5"><li>向尾部追加值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value,即相当于SET key value。返回值是追加字符串的总长度。</p><ol start="6"><li>获取字符串长度</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p>STRLEN命令返回键值的长度，如果键不存在则返回0。</p><p>字符串类型可以存储二进制数据，所以它可以存储任 何编码的字符串。例子中Redis接收到的是使用UTF-8编码的中文，由 于“你”和“好”两个字的UTF-8编码的长度都是3, 因此STRLEN key的返回值为6。</p><ol start="7"><li>同时获取多个键值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key...]</span><br><span class="line">MSET key <span class="keyword">value</span>[key value...]</span><br></pre></td></tr></table></figure><p>MGET&#x2F;MSET 与GET&#x2F;SET 相似，不过MGET&#x2F;MSET 可以同时获 得&#x2F;设置多个键的键值。</p><ol start="8"><li>位操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key <span class="keyword">offset</span></span><br><span class="line">SETBIT key <span class="keyword">offset</span> <span class="keyword">value</span></span><br><span class="line">BITCOUNT key [<span class="keyword">start</span>][<span class="keyword">end</span>]</span><br><span class="line">BITOP operation destkey key [key...]</span><br></pre></td></tr></table></figure><p>一个字节由8个二进制位组成，Redis提供了4个命令可以直接对二 进制位进行操作。为了演示，我们首先将foo键赋值为bar：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> foo bar</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>bar的3个字母“b”“a”和“r”对应的ASCII码分别为98、97和114，转 换成二进制后分别为1100010、1100001和1110010，所以foo键中的二 进制位结构如图所示：</p><p><img src="/2023/07/24/Redis%E5%9F%BA%E7%A1%80/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="二进制存储结构"></p><p>GETBIT命令可以获得一个字符串类型键指定位置的二进制位的 值（0或1），索引从0开始。如果需要获取的二进制位的索引超出了键值的二进制位的实际长 度则默认位值是0。</p><p>SETBIT 命令可以设置字符串类型键指定位置的二进制位的值， 返回值是该位置的旧值。</p><p>BITCOUNT命令可以获得字符串类型键中值是1的二进制位个 数。</p><p>BITOP命令可以对多个字符串类型键进行位运算，并将结果存储 在destkey参数指定的键中。BITOP命令支持的运算操作有AND、OR、 XOR和NOT。如我们可以对bar和aar进行OR运算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> foo1 bar</span><br><span class="line">OK</span><br><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> foo2 aar</span><br><span class="line">OK</span><br><span class="line">redis<span class="operator">&gt;</span> BITOP <span class="keyword">OR</span> res foo1 foo2</span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">GET</span> res</span><br><span class="line">&quot;car&quot;</span><br></pre></td></tr></table></figure><h2 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h2><p>散列类型（hash）的键值也是一种字典结构，其存储了字段 （field）和字段值的映射，但字段值只能是字符串，不支持其他数据类 型，换句话说，散列类型不能嵌套其他的数据类型。一个散列类型键 可以包含至多232−1个字段。</p><p>散列类型适合存储对象：使用对象类别和 ID 构成键名，使用字段 表示对象的属性，而字段值则存储属性值。例如要存储ID为2的汽车对 象，可以分别使用名为color、name和price的3个字段来存储该辆汽车的 颜色、名称和价格。存储结构如图所示：</p><p><img src="/2023/07/24/Redis%E5%9F%BA%E7%A1%80/%E6%95%A3%E5%88%97%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E6%B1%BD%E8%BD%A6%E5%AF%B9%E8%B1%A1.png" alt="散列类型存储汽车对象"></p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ol><li>取值与赋值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field <span class="keyword">value</span></span><br><span class="line">HGET key field</span><br><span class="line">HMSET key field <span class="keyword">value</span> [field <span class="keyword">value</span> …]</span><br><span class="line">HMGET key field [field …]</span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p>HSET命令用来给字段赋值，而HGET命令用来获得字段的值。</p><p>当需要同时设置多个字段的值时，可以使用HMSET命令。相应地，HMGET命令可以同时获得多个字段的值。</p><p>如果想获取键中所有字段和字段值却不知道键中有哪些字段时应该使用HGETALL命令。</p><ol start="2"><li>判断字段是否存在</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p>HEXISTS命令用来判断一个字段是否存在。如果存在则返回1，否 则返回0（如果键不存在也会返回0）。</p><ol start="3"><li>当字段不存在时赋值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>HSETNX命令与HSET命令类似，区别在于如果字段已经存在，HSETNX命令将不进行任何操作。HSETNX命令是原子操作，不用担心竞态条件。</p><ol start="4"><li>增加数字</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure><ol start="5"><li>删除字段</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure><p>HDEL命令可以删除一个或多个字段，返回值是被删除的字段个数。</p><h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ol><li>向列表两端增加元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...]</span><br><span class="line">RPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...]</span><br></pre></td></tr></table></figure><p>LPUSH命令用来向列表左边增加元素，返回值表示增加元素后列表的长度。向列表右边增加元素的话则使用RPUSH命令，其用法和LPUSH命令一样。</p><ol start="2"><li>从列表两端弹出元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure><ol start="3"><li>获取列表中的元素个数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p>LLEN 命令的功能类似SQL语句 SELECT COUNT(*) FROM table_name，但是 LLEN的时间复杂度为O(1)，使用时Redis会直接读 取现成的值，而不需要像部分关系数据库（如使用InnoDB存储引擎的 MySQL表）那样需要遍历一遍数据表来统计条目数量。</p><ol start="4"><li>获取列表片段</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key <span class="keyword">start</span> top</span><br></pre></td></tr></table></figure><p>LRANGE命令是列表类型最常用的命令之一，它能够获得列表中 的某一片段。LRANGE命令将返回索引从 start到 stop之间的所有元素 （包含两端的元素）。与大多数人的直觉相同，Redis的列表起始索引为0。</p><ol start="5"><li>删除列表中指定的值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>LREM命令会删除列表中前count个值为value的元素，返回值是实 际删除的元素个数。根据count值的不同，LREM命令的执行方式会略 有差异。</p><p>（1）当 count &gt; 0时 LREM 命令会从列表左边开始删除前 count 个 值为 value的元素。 </p><p>（2）当 count &lt; 0时 LREM 命令会从列表右边开始删除前|count|个 值为 value 的元素。 </p><p>（3）当 count &#x3D; 0是 LREM命令会删除所有值为 value的元素。</p><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素 是否存在等，由于集合类型在Redis内部是使用值为空的散列表（hash table）实现的，所以这些操作的时间复杂度都是O(1)。多个集合类型键之间可以进行并集、交集和差集运算。</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ol><li>增加&#x2F;删除元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br><span class="line">SREM key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>SADD 命令用来向集合中增加一个或多个元素，如果键不存在则 会自动创建。SREM命令用来从集合中删除一个或多个元素，并返回删除成功的个数。</p><ol start="2"><li>获取集合中所有元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><ol start="3"><li>判断元素是否在集合中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>当值存在时 SISMEMBER命令返回1，当值不存在或键不存在时返回 0。</p><ol start="4"><li>集合间运算</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key „]</span><br><span class="line">SINTER key [key „]</span><br><span class="line">SUNION key [key „]</span><br></pre></td></tr></table></figure><p>SDIFF进行差集运算，SINTER进行交集运算，SUNION进行并集运算。</p><h2 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h2><p>在集合类型的基础上有序集合类型为集合中的每个元素都关联了 一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在 等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元 素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每 个元素都是不同的，但是它们的分数却可以相同。</p><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ol><li>增加元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score <span class="keyword">member</span> [score <span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>ZADD 命令用来向有序集合中加入一个元素和该元素的分数，如 果该元素已经存在则会用新的分数替换原有的分数。ZADD命令的返 回值是新加入到集合中的元素个数（不包含之前已经存在的元素）。</p><ol start="2"><li>获取元素的分数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key <span class="keyword">member</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取排名在某个范围内的元素列表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line">ZREVRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br></pre></td></tr></table></figure><h1 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h1><h2 id="Geospatial地理位置"><a href="#Geospatial地理位置" class="headerlink" title="Geospatial地理位置"></a>Geospatial地理位置</h2><h3 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># geoadd 添加地理位置</span><br><span class="line"># 参数 key 值</span><br><span class="line"><span class="operator">&gt;</span> geoadd china:city <span class="number">39.90</span> <span class="number">116.40</span> beijing</span><br></pre></td></tr></table></figure><h3 id="geoget"><a href="#geoget" class="headerlink" title="geoget"></a>geoget</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># geoget 获取指定城市的经度纬度</span><br></pre></td></tr></table></figure><h3 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># geodist 获取两城市之间的距离</span><br></pre></td></tr></table></figure><h3 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># georadius 以某点为中心查找元素</span><br></pre></td></tr></table></figure><h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><blockquote><p>简介</p></blockquote><p>Redis Hyperloglog 基数统计的算法</p><h3 id="PFadd"><a href="#PFadd" class="headerlink" title="PFadd"></a>PFadd</h3><h3 id="PFcount"><a href="#PFcount" class="headerlink" title="PFcount"></a>PFcount</h3><h3 id="PFmerge"><a href="#PFmerge" class="headerlink" title="PFmerge"></a>PFmerge</h3><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><blockquote><p>位存储</p></blockquote><p>位图,都是操作二进制位来记录,只有0和1两种状态</p><h3 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h3><h3 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h3><h3 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis单条命令保存原子性,但是事务不保证原子性.</p><blockquote><p>本质</p><p>一组命令的集合</p></blockquote><p>一个Redis事务中的所有命令都会被序列化,在事务的执行过程中,会按照顺序执行.<strong>Redis事务没有隔离级别的概念</strong></p><p> <strong>Redis的事务流程</strong></p><ul><li>开启事务 multi</li><li>命令入队</li><li>执行事务</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="编译型异常"><a href="#编译型异常" class="headerlink" title="编译型异常"></a>编译型异常</h3><p>代码有问题,命令有错误,事务中所有命令都不会被执行</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>其他命令可以正常执行,错误命令抛出异常</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul><li>悲观锁 任何情况下都加锁</li><li>乐观锁 任何情况下都不加锁,更新数据的时候去判断一下在此期间是否有人修改过数据</li></ul><p>WATCH命令可以用作实现乐观锁</p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http包</title>
      <link href="/2023/07/21/http%E5%8C%85/"/>
      <url>/2023/07/21/http%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Go 语言中的 http 包提供了创建 http 服务或者访问 http 服务所需要的能力，不需要额外的依赖。在这篇文章中，我们会介绍这些功能的使用，以及看一下 http 包的设计思路。</p><span id="more"></span><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>http标准库的各个组成部分:</p><p>发送GET,HEAD,POST,POSTFORM请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">&quot;http://example.com/form&quot;</span>, url.Values&#123;<span class="string">&quot;key&quot;</span>:&#123;<span class="string">&quot;Value&quot;</span>&#125;, <span class="string">&quot;id&quot;</span>:&#123;<span class="string">&quot;123&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>客户端必须在结束时关闭响应体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := io.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可以配置客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">    CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := client.Get(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://example.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">&quot;If-None-Match&quot;</span>, <span class="string">`W/&quot;wyzzy&quot;`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>为了控制代理，TLS配置，等配置，可以创建一个Transport:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;http.Transport &#123;</span><br><span class="line">    MaxIdleConns:<span class="number">10</span>,</span><br><span class="line">    IdleConnTimeout:<span class="number">30</span> * time.Second,</span><br><span class="line">    DisableCompression:<span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">&quot;http://example.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>ListenAndServe函数使用给定的地址和处理函数开启一个HTTP服务器。handler通常是nil，意味着使用DefaultServeMux。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/foo&quot;</span>, fooHandler)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/bar&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, %q&quot;</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure><p>使用定制的服务器来控制服务器的行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;http.Server &#123;</span><br><span class="line">    Addr:<span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">    Handler:myHandler,</span><br><span class="line">    ReadTimeout:<span class="number">10</span> * time.Second,</span><br><span class="line">    WriteTimeout:<span class="number">10</span> * time.Second,</span><br><span class="line">    MaxHeaderBytes:<span class="number">1</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(s.ListenAndServe())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计</title>
      <link href="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>文章中的代码我都放在了github上，<a href="https://github.com/napleon-liu/XD-SE-OSE-2023spring">有需要的可以自取</a> 。记得点个star。</p><span id="more"></span><h1 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h1><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><p>编写shell脚本，该脚本接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “自己学号的后3位    MYFILE”。</p><p>这个比较简单，稍微了解一下shell编程和常用命令就能写出来，不多赘述。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># read_write.sh</span></span><br><span class="line">filename=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">flag=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$flag</span>&quot;</span> = 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 读取文件内容</span></span><br><span class="line">  content=$(<span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;文件内容：<span class="variable">$content</span>&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$flag</span>&quot;</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 获取学号后3位</span></span><br><span class="line">  student_id=<span class="string">&quot;21069100223&quot;</span></span><br><span class="line">  last_three_digits=<span class="string">&quot;<span class="variable">$&#123;student_id: -3&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 写入文件</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$last_three_digits</span>    MYFILE&quot;</span> &gt; <span class="string">&quot;<span class="variable">$filename</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;已成功写入文件：<span class="variable">$filename</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;无效的标志位!请使用0(读)或1(写)作为第二个参数。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>保存文件，在Terminal中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -x read_write.sh # 给予可执行权限</span><br><span class="line">./read_write_file.sh &quot;test.txt&quot; 1</span><br></pre></td></tr></table></figure><p><img src="/.cn//05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80shell%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE.jpg"></p><h2 id="系统调用编程"><a href="#系统调用编程" class="headerlink" title="系统调用编程"></a>系统调用编程</h2><p>使用系统调用open read write,完成一个C语言程序：该程序接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “学号 MYFILE”，其中学号填为自己的学号。改造上面的程序，使用semaphore，并利用该程序生成2个进程，这两个进程写同一个文件，要求：a.互斥写，即只有一个进程写完后，才能让另一个进程写; b. 一个进程写入内容：“自己学号的后3位PROC1   MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2   MYFILE2”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 1024</span></span><br><span class="line"><span class="type">sem_t</span> semaphore;</span><br><span class="line"><span class="type">int</span> fd; <span class="comment">// 文件描述符</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semaphore);</span><br><span class="line">    <span class="comment">// printf(&quot;223PROC1   MYFILE1\n&quot;);</span></span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC1   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semaphore);</span><br><span class="line">    <span class="comment">// printf(&quot;223PROC2   MYFILE2\n&quot;);</span></span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC2   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @brief 接受两个参数，第一个参数是读写的文件名，第二个参数是标志位，0代表读，1代表写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 参数检测</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: &lt;filename&gt; &lt;flag&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_WRONLY | O_APPEND)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fail to open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[MAX_SIZE];</span><br><span class="line">        read(fd, buf, MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写信息 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_init(&amp;semaphore, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化信号量</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            print2(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print1(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="comment">// 父进程</span></span><br><span class="line"></span><br><span class="line">        sem_destroy(&amp;semaphore); <span class="comment">// 销毁信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: 0:read, 1:write.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译文件的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc read_write.c -o read_write -pthread</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/.cn//05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg"></p><h2 id="内核编程"><a href="#内核编程" class="headerlink" title="内核编程"></a>内核编程</h2><p>添加一个系统调用, 该系统调用接受两个参数：参数1：以整型数表示的自己学号的后3位；参数2：flag，取值为0或1，若为0，该系统调用的返回值为参数1的个位。若为1。该系统调用的返回值为参数1的十位。</p><p>我用的版本是Ubuntu 20.04。源是阿里源。</p><p>本文参考<a href="https://moefactory.com/3041.moe">https://moefactory.com/3041.moe</a></p><!--more--><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><h2 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h2><p>官网地址： <a href="https://www.kernel.org/">https://www.kernel.org/</a> 。本文写作时最新的稳定版为6.2.11。</p><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc make libncurses5-dev openssl libssl-dev build-essential pkg-config libc6-dev bison flex libelf-dev</span><br></pre></td></tr></table></figure><p>系统调用<code>os_exp</code>，添加在<code>kernel/sys.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(os_exp, <span class="type">long</span> <span class="type">long</span>, id) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mod = (id % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1000000</span> : <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">return</span> id % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>include/linux/syscalls.h</code>中添加系统调用的函数声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_os_exp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> id)</span>;</span><br></pre></td></tr></table></figure><p>最后在系统调用表中添加我们自定义的系统调用。<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中，在335号系统调用后添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">335</span>commonos_exp__x64_sys_os_exp</span><br></pre></td></tr></table></figure><p><code>&lt;系统调用编号&gt; common &lt;系统调用名称&gt; &lt;系统调用的函数名称&gt;</code>，这四列之间请使用制表符分隔。注意系统调用的函数名称是有格式要求的，格式为 <code>__x64_sys_&lt;函数名&gt;</code>，而这里的函数名就是之前我们自己拟定的 <code>os_exp</code>。</p><h2 id="配置内核代码"><a href="#配置内核代码" class="headerlink" title="配置内核代码"></a>配置内核代码</h2><p>在下载下来的内核目录下，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -v /boot/config-$(uname -r) .config</span><br></pre></td></tr></table></figure><p>目的是为了使我们编译的内核的配置与当前环境的配置一致。</p><p>修改.config文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vim .config</span></span><br><span class="line"><span class="comment">// / CONFIG_SYSTEM_TRUSTED_KEYS = &quot;&quot;</span></span><br><span class="line"><span class="comment">// / CONFIG_SYSTEM_REVOCATION_KEYS = &quot;&quot;</span></span><br><span class="line"><span class="comment">// 结果如下图所示</span></span><br></pre></td></tr></table></figure><img src="/.cn//Users\79893\blog\source\images\os_expe\.config配置文件.jpg" alt="config配置文件" style="zoom:67%;"><h2 id="编译安装内核"><a href="#编译安装内核" class="headerlink" title="编译安装内核"></a>编译安装内核</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -j4</span><br></pre></td></tr></table></figure><p>分配线程的数目取决于虚拟机的CPU核数以及每个核的线程数，比如我的虚拟机是双核双线程的，因此选择4线程编译。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装内核模块命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure><p>安装内核：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>重启系统并查看新内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="测试系统调用"><a href="#测试系统调用" class="headerlink" title="测试系统调用"></a>测试系统调用</h2><h2 id="驱动编程"><a href="#驱动编程" class="headerlink" title="驱动编程"></a>驱动编程</h2><p>完善1.7节设备驱动例子中的字符设备程序，使之满足以下功能：</p><p>  i.安装设备后从设备中读出字符串为自己学号的后3位；</p><p> ii.  设备支持每次写入字符不超过1024个，超过部分被丢弃，并且能够保存最近一次修改前的rwbuf里的内容。</p><p> iii. 设备支持系统调用ioctl(int d, int req,…),共支持设置三种模式：a. 清除设备中写入的字符串; b. 从设备中读时，读出的是最近一次修改前的内容。 c. 从设备中读时，读出的是最新内容</p><p> iv. 设备关闭前不能被多次打开；</p><p> v. 自己编写测试程序，验证以上功能</p><p>此处参考了小梦学长的 <a href="https://moefactory.com/3041.moe">博客</a>。为了实现读最新内容和读最近一次修改前的内容两种模式，我设置了两个缓冲区。一个存储最新的信息，另一个在更新信息时保存new_buf的信息，以实现保存最近一次修改前的内容。具体细节参见代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rwbuf.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于 ioctl 命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_CLEAR 0x909090</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDOLD 0x909091</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDNEW 0x909092</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;rwbuf&quot;</span></span></span><br><span class="line"><span class="comment">// 锁机制，保证只能有一个打开的设备。0 为未打开，1 为已打开</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inuse = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 缓冲区最大长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RWBUF_MAX_SIZE 1024</span></span><br><span class="line"><span class="comment">// 模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mode = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 缓冲区，初始值需要是学号以便能在设备安装后立刻读出</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> rwbuf_old[RWBUF_MAX_SIZE] = <span class="string">&quot;223&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> old_cnt = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> rwbuf_new[RWBUF_MAX_SIZE] = <span class="string">&quot;223&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> new_cnt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (inuse == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inuse = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// increase the use count in struct module</span></span><br><span class="line">        try_module_get(THIS_MODULE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    inuse = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// decrease the use count in struct module</span></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将内容写入到设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放待写入内容的缓冲区</span></span><br><span class="line"><span class="comment"> * @return 正数表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(rwbuf_old, rwbuf_new);</span><br><span class="line">        old_cnt = new_cnt;</span><br><span class="line">        new_cnt = count &gt; RWBUF_MAX_SIZE ? RWBUF_MAX_SIZE : count;</span><br><span class="line">        copy_from_user(rwbuf_new, buf, new_cnt);</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write successful. After writing, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> new_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write failed. Length of string to be written = %lu\n&quot;</span>, count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从设备中读取内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放读取内容的缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">1</span>) &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_new, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_old, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ioctl 操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param arg 要执行的操作</span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">rwbuf_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] [RW_CLEAR:%x],[cmd:%x]\n&quot;</span>, RW_CLEAR, cmd);</span><br><span class="line">    <span class="keyword">if</span> (cmd == RW_CLEAR) <span class="comment">// 清空缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        new_cnt = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl successful. After doing ioctl, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDNEW) &#123;</span><br><span class="line">        mode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDOLD) &#123;</span><br><span class="line">        mode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 无效命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl failed. new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rwbuf_fops</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        open : rwbuf_open,</span><br><span class="line">        release : rwbuf_release,</span><br><span class="line">        read : rwbuf_read,</span><br><span class="line">        write : rwbuf_write,</span><br><span class="line">        unlocked_ioctl : rwbuf_ioctl</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rwbuf_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Initializing device...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 60: 主设备号，与创建 /dev/rwbuf 时使用的对应</span></span><br><span class="line">    <span class="comment">// DEVICE_NAME: 上面定义的设备名称</span></span><br><span class="line">    <span class="comment">// &amp;rwbuf_fops: VFS 相关</span></span><br><span class="line">    ret = register_chrdev(<span class="number">60</span>, DEVICE_NAME, &amp;rwbuf_fops);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rwbuf_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev(<span class="number">60</span>, DEVICE_NAME);</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Uninstall successful\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rwbuf_init);</span><br><span class="line">module_exit(rwbuf_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>设备的Makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"><span class="comment"># 指定编译器</span></span><br><span class="line">CC := gcc</span><br><span class="line"><span class="comment"># 内核源代码目录</span></span><br><span class="line">KERNEL_DIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="comment"># 模块名称</span></span><br><span class="line">MODULE_NAME := rwbuf</span><br><span class="line"><span class="comment"># 模块源文件</span></span><br><span class="line">MODULE_SRC := rwbuf.c</span><br><span class="line"><span class="comment"># 构建目标</span></span><br><span class="line">obj-m := <span class="variable">$(MODULE_NAME)</span>.o</span><br><span class="line"><span class="comment"># 构建规则</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="comment"># 清理规则</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure><p>测试前需要安装设备，在terminal中依次键入以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mknod</span> /dev/rwbuf c 60 0 <span class="comment"># 创建虚拟字符设备</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /dev/rwbuf <span class="comment"># 修改设备权限</span></span><br><span class="line">sudo insmod rwbuf.ko <span class="comment"># 安装设备驱动</span></span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;/dev/rwbuf&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_CLEAR 0x909090</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDOLD 0x909091</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDNEW 0x909092</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    fd = open(DEVICE_NAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open device error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRead student id...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">3</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read old_buf. Then write aaaaa into buf.\n&quot;</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;aaaaa&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    ioctl(fd, RW_RDOLD);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">3</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Old Buffer:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd, RW_RDNEW);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">5</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;New Buffer:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Write 1100 &#x27;a&#x27;...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(fd, <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>, <span class="number">1100</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRead from device...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">1024</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[<span class="number">1023</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nClear device...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, RW_CLEAR) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device closed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行设备驱动，结果如下图。</p><p>测试结果：</p><p><img src="/.cn//05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/base%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%9C.jpg"></p><p>最后记得卸载设备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod rwbuf</span><br></pre></td></tr></table></figure><h1 id="中级题目"><a href="#中级题目" class="headerlink" title="中级题目"></a>中级题目</h1><h2 id="Shell编程-1"><a href="#Shell编程-1" class="headerlink" title="Shell编程"></a>Shell编程</h2><p>编写一个脚本，能够生成完成基础题目（即：“编写shell脚本，该脚本接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “自己学号的后3位     MYFILE”。“）的脚本，并且自动执行该生成的脚本（执行功能：写入文件）。</p><p>写一个脚本，将基础题目的脚本作为内容写进文件里，然后自动执行生成的文件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># Set the filename and flag variables</span><br><span class="line">filename=<span class="string">&quot;$1&quot;</span></span><br><span class="line">flag=<span class="string">&quot;$2&quot;</span></span><br><span class="line"></span><br><span class="line"># Generate the script content</span><br><span class="line">script_content=$(cat &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">filename=<span class="string">&quot;$1&quot;</span></span><br><span class="line">flag=<span class="string">&quot;$2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$flag&quot;</span> = <span class="string">&quot;0&quot;</span> ]; then</span><br><span class="line">  # Read file content</span><br><span class="line">  content=$(cat <span class="string">&quot;$filename&quot;</span>)</span><br><span class="line">  echo <span class="string">&quot;文件内容：$content&quot;</span></span><br><span class="line">elif [ <span class="string">&quot;$flag&quot;</span> = <span class="string">&quot;1&quot;</span> ]; then</span><br><span class="line">  # Get the last three digits of the student ID</span><br><span class="line">  student_id=<span class="string">&quot;21069100223&quot;</span></span><br><span class="line">  last_three_digits=<span class="string">&quot;$&#123;student_id: -3&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">  # Write to the file</span><br><span class="line">  echo <span class="string">&quot;$last_three_digits    MYFILE&quot;</span> &gt; <span class="string">&quot;$filename&quot;</span></span><br><span class="line">  echo <span class="string">&quot;已成功写入文件：$filename&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  echo <span class="string">&quot;无效的标志位!请使用0(读)或1(写)作为第二个参数。&quot;</span></span><br><span class="line">fi</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Write the script content to a file</span><br><span class="line">script_filename=<span class="string">&quot;rw.sh&quot;</span></span><br><span class="line">echo <span class="string">&quot;$script_content&quot;</span> &gt; <span class="string">&quot;$script_filename&quot;</span></span><br><span class="line">echo <span class="string">&quot;Generated script: $script_filename&quot;</span></span><br><span class="line"></span><br><span class="line"># Make the generated script executable</span><br><span class="line">chmod +x <span class="string">&quot;$script_filename&quot;</span></span><br><span class="line"></span><br><span class="line"># Execute the generated script with the provided arguments</span><br><span class="line">./<span class="string">&quot;$script_filename&quot;</span> <span class="string">&quot;$filename&quot;</span> <span class="string">&quot;$flag&quot;</span></span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/.cn//05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/medium_shell%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg" alt="medium_shell测试结果"></p><h2 id="系统调用编程-1"><a href="#系统调用编程-1" class="headerlink" title="系统调用编程"></a>系统调用编程</h2><p>对于基础题目系统调用编程中的第2题（即：使用semaphore，并利用该程序生成2个进程（注意：非线程），这两个进程写同一个文件，要求：a.互斥写，即只有一个进程写完后，才能让另一个进程写; b. 一个进程写入内容：“自己学号的后3位PROC1 MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2   MYFILE2”），将该程序的semaphore替换成使用strict alternation算法的忙等待互斥锁完成。</p><p>严格轮换法参考课本。我申请了一块共享内存作为lock，对于父子进程均可见。注意，write具有原子性，我身边有很多人使用一个全局变量作为lock，但是write时直接将一句话写进文件里，这样结果看起来是对的，实际上并没有实现互斥。因为fork()出的子进程是父进程的一个副本，二者的地址空间不同，所以lock不是共享的，实现父子进程之间的通信的方法有很多，可以参考我的另外一篇 <a href="https://www.napleon.cn/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">博客</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read_write.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> fd; <span class="comment">// 文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* shm_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (shm_addr[<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC1   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shm_addr[<span class="number">0</span>] = <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (shm_addr[<span class="number">0</span>] == <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC2   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shm_addr[<span class="number">0</span>] = <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>* mode = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="comment">// char* filename = &quot;myfile.txt&quot;;</span></span><br><span class="line">    <span class="comment">// char* mode = &quot;1&quot;;</span></span><br><span class="line"></span><br><span class="line">    key = ftok(<span class="string">&quot;./&quot;</span>, <span class="number">2023</span>);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmid = shmget(key, MAX_SIZE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm_addr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm_addr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fail to open %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(mode, <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[MAX_SIZE];</span><br><span class="line">        read(fd, buf, MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写信息 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            print2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: 0:read, 1:write.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc read_write.c -o read_write -lpthread</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/.cn//05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/medium%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg"></p><h2 id="内核编程-1"><a href="#内核编程-1" class="headerlink" title="内核编程"></a>内核编程</h2><ol><li><p>对于基础题目中的内核编程题（即： 添加一个系统调用, 该系统调用接受两个参数：参数1：以整型数表示的自己学号的后3位；参数2：flag，取值为0或1，若为0，该系统调用的返回值为参数1的个位。若为1。该系统调用的返回值为参数1的十位），进行修改，修改如下：</p><ol><li>声明一个内核全局变量gOSE, 该系统首先将参数1的值赋给gOSE，并且，对于参数2：flag，取值为0或1，若为0，将gOSE的值按位取反，后赋值给gOSE，然后返回gOSE的值；若为1，则将gOSE的值与0Xffffffff异或，后赋值给gOSE，然后返回gOSE的值；</li><li>加入内核互斥锁，使得两个进程在调用该系统调用时，能够做到互斥访问gOSE。</li></ol></li><li><p>对于中级题目中系统调用编程的第1题，给出strict alternation算法中turn变量的虚地址，并且给出该变量的物理地址。</p></li></ol><h2 id="驱动编程-1"><a href="#驱动编程-1" class="headerlink" title="驱动编程"></a>驱动编程</h2><p>对基础题目中的驱动编程进行修改增加mmap接口，使其能够通过mmap读写rwbuf中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于 ioctl 命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_CLEAR 0x909090</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDOLD 0x909091</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDNEW 0x909092</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;rwbuf&quot;</span></span></span><br><span class="line"><span class="comment">// 锁机制，保证只能有一个打开的设备。0 为未打开，1 为已打开</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inuse = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 缓冲区最大长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RWBUF_MAX_SIZE 1024</span></span><br><span class="line"><span class="comment">// 模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mode = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 缓冲区，初始值需要是学号以便能在设备安装后立刻读出</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* rwbuf_old;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> old_cnt = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* rwbuf_new;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> new_cnt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (inuse == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inuse = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// increase the use count in struct module</span></span><br><span class="line">        try_module_get(THIS_MODULE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    inuse = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// decrease the use count in struct module</span></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将内容写入到设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放待写入内容的缓冲区</span></span><br><span class="line"><span class="comment"> * @return 正数表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// rwbuf_old = rwbuf_new;</span></span><br><span class="line">        <span class="built_in">strcpy</span>(rwbuf_old, rwbuf_new);</span><br><span class="line">        old_cnt = new_cnt;</span><br><span class="line">        new_cnt = count &gt; RWBUF_MAX_SIZE ? RWBUF_MAX_SIZE : count;</span><br><span class="line">        copy_from_user(rwbuf_new, buf, new_cnt);</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write successful. After writing, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> new_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write failed. Length of string to be written = %lu\n&quot;</span>, count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从设备中读取内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放读取内容的缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">1</span>) &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_new, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_old, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printk(&quot;[rwbuf] Read successful. After reading, new_cnt = %d\n&quot;, new_cnt);</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ioctl 操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param arg 要执行的操作</span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">rwbuf_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] [RW_CLEAR:%x],[cmd:%x]\n&quot;</span>, RW_CLEAR, cmd);</span><br><span class="line">    <span class="keyword">if</span> (cmd == RW_CLEAR) <span class="comment">// 清空缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        new_cnt = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl successful. After doing ioctl, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDNEW) &#123;</span><br><span class="line">        mode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDOLD) &#123;</span><br><span class="line">        mode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 无效命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl failed. new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pfn_start = (virt_to_phys(rwbuf_new) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> virt_start = (<span class="type">unsigned</span> <span class="type">long</span>)rwbuf_new + offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line">    <span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, </span><br><span class="line">        size,</span><br><span class="line">        vma-&gt;vm_page_prot</span><br><span class="line">    ))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rwbuf_fops</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        open : rwbuf_open,</span><br><span class="line">        release : rwbuf_release,</span><br><span class="line">        read : rwbuf_read,</span><br><span class="line">        write : rwbuf_write,</span><br><span class="line">        unlocked_ioctl : rwbuf_ioctl,</span><br><span class="line">        mmap : rwbuf_mmap,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rwbuf_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    rwbuf_new = kzalloc(RWBUF_MAX_SIZE, GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strcpy</span>(rwbuf_new, <span class="string">&quot;223\0&quot;</span>);</span><br><span class="line">    rwbuf_old = kzalloc(RWBUF_MAX_SIZE, GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strcpy</span>(rwbuf_old, <span class="string">&quot;223\0&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Initializing device...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 60: 主设备号，与创建 /dev/rwbuf 时使用的对应</span></span><br><span class="line">    <span class="comment">// DEVICE_NAME: 上面定义的设备名称</span></span><br><span class="line">    <span class="comment">// &amp;rwbuf_fops: VFS 相关</span></span><br><span class="line">    ret = register_chrdev(<span class="number">60</span>, DEVICE_NAME, &amp;rwbuf_fops);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rwbuf_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev(<span class="number">60</span>, DEVICE_NAME);</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Uninstall successful\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rwbuf_init);</span><br><span class="line">module_exit(rwbuf_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/rwbuf&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *mapped_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开设备文件</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    fd = open(DEVICE_PATH, O_RDWR);</span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 mmap 映射</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    mapped_addr = mmap(<span class="number">0</span>, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// mapped_addr[1023] = &#x27;\0&#x27;;</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (mapped_addr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to mmap&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 从映射的内存读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device Data: %s\n&quot;</span>, mapped_addr);</span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="comment">// 修改映射的内存中的数据</span></span><br><span class="line">    <span class="comment">// mapped_addr[0] = &#x27;A&#x27;;</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    <span class="keyword">if</span> (munmap(mapped_addr, MAP_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to unmap&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="comment">// 关闭设备文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/.cn//05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/medium%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%9C.jpg" alt="medium驱动编程结果"></p><h1 id="高级题目"><a href="#高级题目" class="headerlink" title="高级题目"></a>高级题目</h1><h2 id="制作启动盘-选做"><a href="#制作启动盘-选做" class="headerlink" title="制作启动盘(选做)"></a>制作启动盘(选做)</h2><ol><li><p>使用麒麟桌面操作系统内核（只能使用麒麟桌面操作系统内核），在不重新编译内核的情况下，制作USB启动盘，使得计算机从USB盘上启动，加载initial ramdisk，并能够自动运行一个shell脚本，该shell 脚本在中端上输出自己学号的后·3位。</p></li><li><p>对上题的USB启动盘进行修改（注意，无论何种修改，只能使用麒麟桌面操作系统内核），并不能重新编译内核），能够将USB启动盘作为根目录进行挂载，并且从USB盘上启动后，能够自动运行一个shell脚本，该shell 脚本在将自己学号的后·3位写入USB启动盘上的一个文件中。</p></li></ol><h2 id="系统调用编程-必做"><a href="#系统调用编程-必做" class="headerlink" title="系统调用编程(必做)"></a>系统调用编程(必做)</h2><p>编写一个程序，并利用该程序生成2个进程（注意，非线程），这两个进程写同一个文件，要求：</p><p>a.互斥写，即只有一个进程写完后，才能让另一个进程写;  该互斥实现使用忙等待锁完成互斥。该忙等待锁在x86平台上必须使用xchg和cmp汇编语句完成，如果在arm平台上，必须使用ldrex和strex 和cmp完成，并且，对于锁变量lock，lock为1时表示锁被释放，lock为0时表示上锁。</p><p>b. 一个进程写入内容：“自己学号的后3位PROC1 MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2 MYFILE2”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSZ 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_BUSY 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FREE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span>* lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *lock)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = LOCK_BUSY;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;xchg %0, %1&quot;</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;=r&quot;</span>(tmp)   <span class="comment">//输出部分</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;m&quot;</span>(*lock), <span class="string">&quot;0&quot;</span>(tmp)    <span class="comment">//输入部分</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp == LOCK_BUSY) &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pause&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">        tmp = *lock;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;xchg %0, %1&quot;</span></span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;=r&quot;</span>(tmp)</span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;m&quot;</span>(*lock), <span class="string">&quot;0&quot;</span>(tmp)</span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *lock)</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %1, %0&quot;</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;+m&quot;</span>(*lock) : <span class="string">&quot;r&quot;</span>(LOCK_FREE)</span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_proc</span><span class="params">(<span class="type">char</span>* fname, <span class="type">char</span>* msg)</span>&#123;</span><br><span class="line">    lock_acquire(lock);</span><br><span class="line">    <span class="type">int</span> fd = open(fname, O_CREAT|O_WRONLY|O_APPEND, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write(fd, msg, strlen(msg));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(msg); i++) &#123;</span><br><span class="line">        write(fd, msg+i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    lock_release(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> shmid;</span><br><span class="line"><span class="type">key_t</span> key;</span><br><span class="line"></span><br><span class="line">key = ftok(<span class="string">&quot;./&quot;</span>, <span class="number">2015</span>);</span><br><span class="line"><span class="keyword">if</span> (key == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shmid = shmget(key, BUFSZ, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    lock = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 连接共享内存</span></span><br><span class="line">    *lock = LOCK_FREE;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">char</span> fname[] = <span class="string">&quot;./test.txt&quot;</span>;</span><br><span class="line">    <span class="type">char</span> msg1[<span class="number">128</span>], msg2[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(msg1, <span class="string">&quot;223PROC1 MYFILE1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(msg2, <span class="string">&quot;223PROC2 MYFILE2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pid) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程写文件1</span></span><br><span class="line">        write_proc(fname, msg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程写文件2</span></span><br><span class="line">        write_proc(fname, msg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="驱动编程-选做"><a href="#驱动编程-选做" class="headerlink" title="驱动编程(选做)"></a>驱动编程(选做)</h2><ol><li><p>安装Qemu虚机，注：在线资料中“已安装Qemu的虚机”中解压后是一个vmware虚机，这里称其为VW虚机。VW虚机里面已经安装好Qemu，并且也安装了一个Qemu 虚机，这里称其为QVM，QVM自身并不携带gcc，仅作为示例。VWroot密码是1，QVM的root密码是0；同学可在QVM基础上补完gcc等编程环境，或重新装一个完整的QVM。</p></li><li><p>对于给出edu设备（它是Qemu虚拟化出的一个设备）的驱动，请对其进行改进，使其能够完成DMA数据传输；并且编写相关的用户态下测试程序进行证明。</p></li></ol><h2 id="内核编程-选做"><a href="#内核编程-选做" class="headerlink" title="内核编程(选做)"></a>内核编程(选做)</h2><p>添加系统调用，根据传入的标志位，通过轮询方式、或DMA方式读取上述edu设备驱动程序的结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下进程间通信</title>
      <link href="/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>进程的地址空间是相互独立的，因此进程之间交互数据必须需要专门的通信机制。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux下的主要IPC手段：</p><ul><li>管道pipe。数据只能单方面流通， 只能在父子进程间进行。</li><li>有名管道named pipe。半双工通信方式，可用于非父子进程通信。</li><li>信号量semophore 进程间或不同进程间的同步手段。</li><li>消息队列message queue。消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息量少，管道只能承载无格式字节流以及缓冲区大小受限的缺点。</li><li>信号signal</li><li>共享内存shared memory。 映射一段能被其他进程访问的内存。共享内存能被一个进程创建但是被多个进程访问。</li><li>套接字socket。 可用于不同机器间的通信。</li></ul><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道是一个特殊的文件，这个文件只存在与内存中。创建管道时，系统为管道分配一个页面作为数据缓冲区，进行管道通信的两个进程通过读写这个缓冲区来实现通信。</p><h2 id="dup与dup2"><a href="#dup与dup2" class="headerlink" title="dup与dup2"></a>dup与dup2</h2><p>在子进程调用exec函数执行另外一个程序时，可以将子进程的文件描述符重定向到标准输入，新执行的程序能够从标准输入获取数据，实际上是从父进程获取输入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回文件描述符，为当前可用文件描述符的最小数值。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 利用参数newfd指定欲返回的文件描述符。如果newfd指定的文件描述符已经打开，先将其关闭，然后将oldfd指定的文件描述符赋值给该参数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><h1 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h1><p>有名管道(named pipe或FIFO)。FIFO不同与管道之处在于它提供了一个路径名与之关联，以FIFO的形式存储与文件系统中。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>可以用shell创建或者在程序中用系统函数创建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">path: 有名管道的路径名</span></span><br><span class="line"><span class="comment">mod: 模式</span></span><br><span class="line"><span class="comment">dev: 设备值</span></span><br><span class="line"><span class="comment">return: 成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mod, <span class="type">dev_t</span> dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写方式"><a href="#读写方式" class="headerlink" title="读写方式"></a>读写方式</h2><p>有名管道是一个硬盘上的文件，使用前需要先open()将其打开。</p><p><strong>有名管道是存在与硬盘上的文件，而管道是存在与内存中的特殊文件</strong></p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>消息队列是存放在内核中的一个消息链表，每个消息队列用消息队列标识符标识。与管道不同的是消息队列存放在内核中，只有在内核重启或者显式的删除一个消息队列时，该消息队列才会被真正的删除。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="消息缓冲结构"><a href="#消息缓冲结构" class="headerlink" title="消息缓冲结构"></a>消息缓冲结构</h3><p>向消息队列发送消息时，必须组成合理的数据 结构。Linux系统定义了一个模板数据结构msgbuf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/msg.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="msqid-ds内核数据结构"><a href="#msqid-ds内核数据结构" class="headerlink" title="msqid_ds内核数据结构"></a>msqid_ds内核数据结构</h3><p>Linux中，每个消息队列都维护着一个结构体msqid_ds。该结构体保存着当前消息队列的状态信息。该结构体定义在linux&#x2F;msg.h中，具体定义如下：</p><h3 id="ipc-perm内核数据结构"><a href="#ipc-perm内核数据结构" class="headerlink" title="ipc_perm内核数据结构"></a>ipc_perm内核数据结构</h3><p>ipc_perm保存着消息队列的一些重要信息，比如消息队列关联的键值，消息队列的用户ID、组ID。</p><h2 id="创建与读写"><a href="#创建与读写" class="headerlink" title="创建与读写"></a>创建与读写</h2><h3 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h3><p>消息队列是随着内核的存在而存在的，每个消息队列在系统范围内对应唯一的键值。通过ftok函数获取该键值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">ket_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写消息队列"><a href="#读写消息队列" class="headerlink" title="读写消息队列"></a>读写消息队列</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> mapflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> <span class="type">int</span> msgtyp, itn msgflg)</span>;</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量大于等于0时表示可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数目。</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">sem_perm</span>;</span><span class="comment">// 对信号进行操作的许可权</span></span><br><span class="line">    <span class="type">__kernel_time_t</span>sem_otime;<span class="comment">// 对信号进行操作的最后时间</span></span><br><span class="line">    <span class="type">__kernel_time_t</span>em_ctime;<span class="comment">// 对信号进行修改的最后时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span>*<span class="title">sembase</span>;</span><span class="comment">// 指向第一个信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span><span class="title">sem_pending</span>;</span><span class="comment">// 等待处理的挂起操作</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span><span class="comment">// 撤销的请求</span></span><br><span class="line">    ushortsem_nsems;<span class="comment">// 数组中的信号数目</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><p>共享内存是分配一块能被其他进程访问的内存。每个内存块在内核中维护这一个内部结构shmid_ds(和消息队列，信号量)一样，该结构定义在头文件linux&#x2F;shm.h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">shm_perm</span>;</span></span><br><span class="line">    <span class="type">int</span>shm_segsz;</span><br><span class="line">    ******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存区的创建"><a href="#共享内存区的创建" class="headerlink" title="共享内存区的创建"></a>共享内存区的创建</h2><p>shmget来创建一个共享内存区。原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">key: ftok得到的键值</span></span><br><span class="line"><span class="comment">size: 以字节为单位指定内存的大小</span></span><br><span class="line"><span class="comment">shmflg: 操作标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><h2 id="共享内存区的操作"><a href="#共享内存区的操作" class="headerlink" title="共享内存区的操作"></a>共享内存区的操作</h2><p>在使用共享内存区之前，必须通过shmat将其附加到进程的地址空间。进程就与共享内存建立了连接。shmat调用成功后会返回一个指向共享内存区的指针，使用该指针即可访问共享内存区，如果失败返回-1.代码原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shimid: shmget的返回值</span></span><br><span class="line"><span class="comment">shmaddr: 共享内存的附加点，一般设为空，由MMU自动管理</span></span><br><span class="line"><span class="comment">shmflg: 存取权限标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p>当进程结束使用共享内存区，要通过函数shmdt断开与共享内存区的连接。该函数声明在sys&#x2F;shm.h中代码原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure><p>Linux对共享内存区的控制是通过调用函数shmctl来完成的，该函数定义在头文件sys&#x2F;shm.h中，原型代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shimid: 共享内存区的标识符</span></span><br><span class="line"><span class="comment">buf:指向shmid_ds结构体的指针</span></span><br><span class="line"><span class="comment">cmd：操作标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shimid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈wsl</title>
      <link href="/2023/05/03/%E6%B5%85%E8%B0%88wsl/"/>
      <url>/2023/05/03/%E6%B5%85%E8%B0%88wsl/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍了WSL的工作原理。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Windows Subsystem for Linux（WSL）是一个用于在本地运行linux二进制可执行文件（ELF格式）的<strong>兼容层</strong>。</p><p>在软件工程领域，兼容层是一个允许面向旧或异质系统的二进制文件运行在特定主机系统上的接口。这意味着将面向异质系统的系统调用转换为面向主机系统。有些库会面向异质系统，这通常是为主机系统提供运行异质二进制文件的能力。而硬件兼容层工具允许硬件仿真。</p><p>与虚拟机相比，wsl没有虚拟硬件的过程，而是直接在windows上虚拟一个linux内核，模拟linux系统调用，以运行linux执行文件。</p><p>可以简单的将它理解为可以运行linux可执行文件的、类似于powershell的shell，具有<strong>互操作性</strong>（在linux中执行windows命令，在windows中执行linux命令）。</p><h1 id="虚拟机技术的原理"><a href="#虚拟机技术的原理" class="headerlink" title="虚拟机技术的原理"></a>虚拟机技术的原理</h1><p><img src="/.cn//05/03/%E6%B5%85%E8%B0%88wsl/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="img"></p><h2 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h2><p>Hypervisor（虚拟机管理器）是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor）。</p><h1 id="WSL原理"><a href="#WSL原理" class="headerlink" title="WSL原理"></a>WSL原理</h1><h2 id="wsl组件"><a href="#wsl组件" class="headerlink" title="wsl组件"></a>wsl组件</h2><p><img src="/.cn//05/03/%E6%B5%85%E8%B0%88wsl/wsl%E7%BB%84%E6%88%90.png" alt="wsl组成"></p><p>wsl实现的组件涉及到了用户和内核模式。在Windows NT内核模式中，LXCore，LXSS这两个驱动提供了linux内核调用的实现，即将linux调用转化为对应的windows NT内核调用；还提供了两种文件系统：VolFs（挂载在&#x2F;目录上，支持linux文件系统所有特性）和DriverFs（挂载在&#x2F;mnt&#x2F;c，&#x2F;mnt&#x2F;d等等windows分区，主要为了支持系统间的互操作性）；驱动还会模拟内核的行为，对linux进程进行调度。</p><p>在用户模式下，windows提供了一种特殊的进程类型：Pico进程，来支持linux进程的运行。windows会 “放松” 对该类型进程的控制，主要交由linux虚拟内核调用和管理，即隔离性（因此需要系统的支持，低版本的系统不能使用wls的功能）。pico会将ELF二进制可执行文件装入到自己的地址空间，然后执行在linux虚拟内核提供的兼容层上。一个pico对应一个linux进程，并且pico进程也是windows的一种特殊进程，因此你可以在任务管理器上看到linux进程。</p><p>无论exe还是elf格式的二进制文件，原理上都可以在同架构的cpu上执行，只是结构不同操作系统不能解析罢了。而Pico能够解析ELF格式的二进制文件，只需要linux虚拟内核能够提供正确的系统调用，就能够运行大部分linux命令。</p><p>LXSS管理服务主要用于协调windows和linux进程之间的关系，和给于Bash.exe（并不是shell，只是我们访问wsl的入口）调用linux命令的接口。所有的运行的linux进程都会被加入到叫Linux实例（应该有LXSS记录的）中，只有第一次请求访问linux进程时才会创建Linux实例，才会创建init进程；当window关机时，会自动关闭linux实例，即关闭linux所有进程。</p><p>也就是wsl不会随windows系统自启而自启，同时没有使用发行版的init进程，导致wsl中没有服务的存在。</p><h3 id="COM简介"><a href="#COM简介" class="headerlink" title="COM简介"></a>COM简介</h3><p>Microsoft 组件对象模型 (COM) 定义了一个二进制互操作性标准，用于创建在运行时交互的可重用软件库。 无需将它们编译到应用程序中即可使用 COM 库。 COM 是许多 Microsoft 产品和技术的基础，例如Windows 媒体播放器和Windows服务器。</p><h3 id="Pico-Process"><a href="#Pico-Process" class="headerlink" title="Pico Process"></a>Pico Process</h3><p>As part of Project Drawbridge, the Windows kernel introduced the concept of Pico processes and Pico drivers. Pico processes are OS processes without the trappings of OS services associated with subystems like a Win32 Process Environment Block (PEB). Furthermore, for a Pico process, system calls and user mode exceptions are dispatched to a paired driver.</p><p>Pico processes and drivers provide the foundation for the Windows Subsystem for Linux, which runs native unmodified Linux binaries by loading executable ELF binaries into a Pico process’s address space and executes them atop a Linux-compatible layer of syscalls.</p><h3 id="System-Call"><a href="#System-Call" class="headerlink" title="System Call"></a>System Call</h3><p>WSL executes unmodified Linux ELF64 binaries by virtualizing a Linux kernel interface on top of the Windows NT kernel. </p><p>On native Linux, when a syscall is made from a user mode executable it is handled by the Linux kernel. On WSL, when a syscall is made from the same executable the Windows NT kernel forwards the request to lxcore.sys. Where possible, lxcore.sys translates the Linux syscall to the equivalent Windows NT call which in turn does the heavy lifting. Where there is no reasonable mapping the Windows kernel mode driver must service the request directly.</p><h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><p>File system support in WSL was designed to meet two goals.</p><ol><li>Provide an environment that supports the full fidelity of Linux file systems</li><li>Allow interoperability with drives and files in Windows</li></ol><p>The Windows Subsystem for Linux provides virtual file system support similar to the real Linux kernel. Two file systems are used to provide access to files on the users system: VolFs and DriveFs.</p><h3 id="VolFs"><a href="#VolFs" class="headerlink" title="VolFs"></a>VolFs</h3><p>VolFs is a file system that provides full support for Linux file system features, including:</p><ul><li>Linux permissions that can be modified through operations such as chmod and chroot</li><li>Symbolic links to other files</li><li>File names with characters that are not normally legal in Windows file names</li><li>Case sensitivity</li></ul><p>Directories containing the Linux system, application files (&#x2F;etc, &#x2F;bin, &#x2F;usr, etc.), and users Linux home folder, all use VolFs.</p><p>Interoperability between Windows applications and files in VolFs is not supported</p><h2 id="wsl运行过程"><a href="#wsl运行过程" class="headerlink" title="wsl运行过程"></a>wsl运行过程</h2><p><img src="/.cn//05/03/%E6%B5%85%E8%B0%88wsl/wsl%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="wsl运行过程"></p><p>一个正常完整的Linux系统的启动过程为：引导程序载入内核，内核初始化后载入init进程。init开启各项服务。</p><p>wsl并不是一个真正的系统，它是一个可以执行Linux ELF的程序。wsl的内核是虚拟内核，具有一定的隔离性。</p><p>wsl的工作流程为：windows自启结束并加载了LxCore&#x2F;LXSS两个驱动后，准备工作结束。当用户执行bash.exe时，创建linux实例，执行init<strong>服务进程</strong>。然后创建bash shell和另一个init进程，在本次会话结束时（关闭Bash.exe窗口）这两个进程结束。之后再通过Bash.exe连接wsl，都只会创建bash和右边的init进程。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>上述讲到了，wsl只有两种windows设计的文件系统：VolFs和DriverFs。其中VolFs文件系统主要是为了支持linux文件系统的全部特性，如linux的文件权限、符号链接、不同于windows的文件名、文件名大小写敏感等等。</p><p>而DriveFs主要是为了挂载windows的分区，并且实现互操作性而存在。实际上就是NTFS文件系统的包装，能够让NTFS在linux中使用，即使也提供了大部分linux文件系统特性，但是限制很多，如：</p><ul><li>文件目录权限全为777，实际上就算是root用户，在windows分区中也只有打开Base.exe命令拥有者的权限。说明普通用户使用root权限也不能修改c盘中大部分文件。</li><li>最好不要在windows下创建文件名只有大小写不同的文件，尽管NTFS支持了。</li><li>支持linux符号链接，为windows可执行文件创建符号链接时，注意添加后缀.exe。不要与windows的快捷方式混淆，它们目的一致，但结构不一致，不能在linux中使用。</li></ul><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul><li>并非所有系统调用都被实现。</li><li>WSL不能使用所有的硬件资源。例如，在wsl下不能访问GPU，重复性的计算只能通过CPU完成。</li><li>磁盘IO比原生Linux效率低。后果是，wsl下的编译会很慢。</li></ul><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="wsl1"><a href="#wsl1" class="headerlink" title="wsl1"></a>wsl1</h2><p>WSL 1的设计没有硬件模拟&#x2F;虚拟化（与coLinux等其他项目不同），WSL直接使用主机文件系统（通过VolFS和DrvFS）和硬件的某些部分，例如网络（Web服务器，用于例如，可以通过主机上配置的相同接口和IP地址进行访问，并且对使用需要管理权限的端口或已经被其他应用程序占用的端口共享相同的限制），这保证了互操作性。</p><p>即使从shell运行sudo，某些位置（例如系统文件夹）和配置的访问&#x2F;修改也受到限制。必须启动具有提升权限的实例才能获得“真正的sudo”并允许此类访问。</p><h2 id="wsl2"><a href="#wsl2" class="headerlink" title="wsl2"></a>wsl2</h2><h3 id="Hyper-V"><a href="#Hyper-V" class="headerlink" title="Hyper-V"></a>Hyper-V</h3><p>Microsoft的本地虚拟机管理系统。</p><p>基于Hyper-V的更高层次的虚拟化。</p><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Virtual_Private_Network_overview.svg/330px-Virtual_Private_Network_overview.svg.png" alt="img"></p><p><img src="https://picx.zhimg.com/v2-ceb0b790077a7a895faba61a1e5f3c95_720w.jpg?source=172ae18b" alt="VPN原理与简单应用"></p><p>VPN是通过使用专用线路或在现有网络上使用隧道协议创建一个虚拟的点对点连接而形成的。可从公共 <a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">Internet</a> 获得的 VPN可以提供<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91">广域网</a> (WAN) 的一些好处。 从用户的角度来看，可以远程访问专用网络中可用的资源。</p><p>正常网络通信时，所有网络请求都是通过我们的物理网卡直接发送出去。而VPN是客户端使用相应的VPN协议先与VPN服务器进行通信，成功连接后就在操作系统内建立一个虚拟网卡，一般来说默认PC上所有网络通信都从这虚拟网卡上进出，经过VPN服务器中转之后再到达目的地。</p><p>VPN有多种协议：OPENVPN、PPTP、L2TP&#x2F;IPSec、SSLVPN、IKEv2 VPN，Cisco VPN等。其中的PPTP和L2TP是明文传输协议。只负责传输，不负责加密。分别利用了MPPE和IPSec进行加密。</p><table><thead><tr><th align="left"></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png" alt="PPTP"></a></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/5.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/5.png" alt="L2TP/IPSec"></a></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/6.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/6.png" alt="PENVPN"></a></th></tr></thead><tbody><tr><td align="left">背景</td><td align="left">PPTP 是一个基于 PPP 的很基本的协议。PPTP 是微软 Windows 平台第一个支持的 VPN 协议。PPTP 标准并没有实际描述加密和授权特性，并且依赖于 PPP 协议的隧道来实现安全功能。</td><td align="left">L2TP 是一个在 IETF <a href="https://tools.ietf.org/html/rfc3193">RFC 3193</a> 中被正式标准化的高级协议。推荐在需要安全加密的地方用来替代 PPTP。</td><td align="left">OpenVPN 是一个高级的开源 VPN 解决方案，由 “OpenVPN technologies” 支持，并且已经成为开源网络领域里的事实标准。OpenVPN 使用成熟的 SSL&#x2F;TLS 加密协议。</td></tr><tr><td align="left">数据加密</td><td align="left">PPP 负载是使用微软点对点协议（Microsoft’s Point-to-Point Encryption protocol，<a href="https://en.wikipedia.org/wiki/Microsoft_Point-to-Point_Encryption">MPPE</a>）加密。MPPE 实现了 RSA <a href="https://en.wikipedia.org/wiki/RC4">RC4</a> 加密算法，并使用最长 128 位密钥。</td><td align="left">L2TP 负载使用标准的 IPSec 协议加密。在 <a href="https://tools.ietf.org/html/rfc4835">RFC 4835</a> 中指定了使用 3DES 或 AES 加密算法作为保密方式。</td><td align="left">OpenVPN 使用 <a href="https://en.wikipedia.org/wiki/OpenSSL">OpenSSL</a> 库来提供加密。OpenSSL 支持好几种不同的加密算法，如：3DES，AES，RC5 等。</td></tr><tr><td align="left">安装&#x2F;配置</td><td align="left">Windows 所有版本和大多数其他操作系统包括移动平台都内建了对 PPTP 的支持。PPTP 只需要一个用户名和密码，以及一个服务器地址，所以安装和配置相当简单。</td><td align="left">从 2000&#x2F;XP 起的所有 Windows 平台和 Mac OS X 10.3+ 都内建了 L2TP&#x2F;IPSec 的支持。大多数现代的移动平台比如 iPhone 和 Android 也有内建的客户端。</td><td align="left">OpenVPN 不包含在任何操作系统中，需要安装客户端软件，但安装也是相当简单，基本上 5 分钟可以完成。</td></tr><tr><td align="left">速度</td><td align="left">由于使用 128 位密钥，加密开销相比 OpenVPN 使用 256位密钥要小，所以速度感觉稍快一点，但这个差异微不足道。</td><td align="left">L2TP&#x2F;IPSec 将数据封装两次，所以相比其他竞争者效率稍低，速度也慢一些。</td><td align="left">当使用默认的 UDP 模式，OpenVPN 的表现是最佳的。</td></tr><tr><td align="left">端口</td><td align="left">PPTP 使用 TCP 1723 端口和 GRE（协议 47）。通过限制 GRE 协议，PPTP 可以轻易地被封锁。</td><td align="left">L2TP&#x2F;IPSec 使用 UDP 500 端口用来初始化密钥交换，使用协议 50 用来传输 IPSec 加密的数据（ ESP ），使用 UDP 1701 端口用来初始化 L2TP 的配置，还使用 UDP 4500 端口来穿过 NAT。L2TP&#x2F;IPSec 相比 OpenVPN 容易封锁，因为它依赖于固定的协议和端口。</td><td align="left">OpenVPN 可以很容易的配置为使用任何端口运行，也可以使用 UDP 或 TCP 协议。为了顺利穿越限制性的防火墙，可以将 OpenVPN 配置成使用 TCP 443 端口，因为这样就无法和标准的 HTTPS 无法区分，从而极难被封锁。</td></tr><tr><td align="left">稳定性&#x2F;兼容性</td><td align="left">PPTP 不如 OpenVPN 可靠，也不能像 OpenVPN 那样在不稳定网络中快速恢复。另外还有部分同 GRE 协议和一些路由器的兼容性问题。</td><td align="left">L2TP&#x2F;IPSec 比 OpenVPN 更复杂，为了使在 NAT 路由器下的设备可靠地使用，配置可以会更加困难。但是，只要服务器和客户端都支持 NAT 穿越，那么就没什么问题了。</td><td align="left">无论是无线网络、蜂窝网络，还是丢包和拥塞经常发生的不可靠网络，OpenVPN 都非常稳定、快速。对于那些相当不可以的连接，OpenVPN 有一个 TCP 模式可以使用，但是要牺牲一点速度，因为将 TCP 封装在 TCP 时效率不高。</td></tr><tr><td align="left">安全弱点</td><td align="left">微软实现的 PPTP 有一个严重的安全问题（<a href="https://www.schneier.com/paper-pptpv2.html">serious security vulnerabilities</a>）。对于词典攻击来说 MSCHAP-v2 是很脆弱的，并且 RC4 算法也会遭到“<a href="https://en.wikipedia.org/wiki/Bit-flipping_attack">位翻转攻击（ bit-flipping attack ）</a>”。如果保密是重要的，微软也强烈建议升级到 IPSec。</td><td align="left">IPSec 没有明显的漏洞，当和安全加密算法如 AES 一起使用时，被认为是很安全的。</td><td align="left">OpenVPN 也没有明显漏洞，当和安全加密算法如 AES 一起使用时，也被认为是相当安全的。</td></tr><tr><td align="left">客户端的兼容性</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android、DD-WRT</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android</td><td align="left">Windows、Mac OS X、Linux</td></tr><tr><td align="left">结论</td><td align="left">由于主要的安全漏洞，除了兼容性以外没有好的理由选择使用 PPTP。如果你的设备既不支持 L2TP&#x2F;IPSec 又不支持 OpenVPN，那么 PPTP 是一个合理的选择。如果关心快速安装和简易配置，那么 L2TP&#x2F;IPSec 值得考虑。</td><td align="left">L2TP&#x2F;IPSec 是优秀的，但相比 OpenVPN 的高效和杰出的稳定性要落后一点。如果你使用运行 iOS 或 Android 的移动设备，那么这就是最佳的选择，因为 OpenVPN 目前还不支持这些平台。另外，如果需要快速安装，L2TP&#x2F;IPSec 也是一个较佳的选择。</td><td align="left">对于所有的 Windows, Mac OS X 以及 Linux 桌面用户来说，OpenVPN 是最好的选择。OpenVPN 速度快，并且安全可信。但劣势是缺乏对移动设备的支持，另外还需要安装第三方客户端。</td></tr></tbody></table><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p><strong>代理</strong>（英语：Proxy）也称<strong>网络代理</strong>，是一种特殊的网络服务，允许一个<a href="https://zh.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF">终端</a>（一般为<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>）通过这个服务与另一个终端（一般为<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>）进行非直接的连接。一些<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3">网关</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，在一定程度上能够阻止<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB">网络攻击</a>。</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p><strong>安全外壳协议</strong>（Secure Shell Protocol，简称<strong>SSH</strong>）是一种加密的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">网络传输协议</a>，可在不安全的网络中为网络服务提供安全的传输环境[<a href="https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4251-1">1]</a>。SSH通过在网络中创建<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%89%E5%85%A8%E9%9A%A7%E9%81%93&action=edit&redlink=1">安全隧道</a>来实现SSH客户端与服务器之间的连接[<a href="https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4252-2">2]</a>。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">命令行界面</a>和远程执行命令。SSH使用频率最高的场合是<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F">类Unix系统</a>，但是<a href="https://zh.wikipedia.org/wiki/Windows">Windows</a>操作系统也能有限度地使用SSH。</p>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GORM学习笔记</title>
      <link href="/2023/04/24/GORM%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/04/24/GORM%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>GORM的特性：</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>模型是标准的struct</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID           <span class="type">uint</span></span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Email        *<span class="type">string</span></span><br><span class="line">  Age          <span class="type">uint8</span></span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  MemberNumber sql.NullString</span><br><span class="line">  ActivatedAt  sql.NullTime</span><br><span class="line">  CreatedAt    time.Time</span><br><span class="line">  UpdatedAt    time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>设置字段的权限位只读、只写、只创建、只更新或者被忽略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&quot;`</span>  <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:all&quot;`</span>        <span class="comment">// 通过 struct 读写、迁移会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:migration&quot;`</span>  <span class="comment">// 通过 struct 迁移会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h2><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 db 列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td align="left">serializer</td><td align="left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td align="left">size</td><td align="left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">将列定义为主键</td></tr><tr><td align="left">unique</td><td align="left">将列定义为唯一键</td></tr><tr><td align="left">default</td><td align="left">定义列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">scale</td><td align="left">指定列大小</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">autoIncrementIncrement</td><td align="left">自动步长，控制连续记录之间的间隔</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌入字段的列名前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td align="left">-</td><td align="left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td align="left">comment</td><td align="left">迁移时为字段添加注释</td></tr></tbody></table><h1 id="连接到数据库"><a href="#连接到数据库" class="headerlink" title="连接到数据库"></a>连接到数据库</h1><p>GORM官方支持的数据库类型有：MySQL, PostgreSQL, SQLite, SQL Server 和 TiDB</p><h2 id="连接到MySQL"><a href="#连接到MySQL" class="headerlink" title="连接到MySQL"></a>连接到MySQL</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dsn := <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL驱动程序提供了一些高级配置可以在初始化时使用，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">  DSN: <span class="string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <span class="comment">// DSN data source name</span></span><br><span class="line">  DefaultStringSize: <span class="number">256</span>, <span class="comment">// string 类型字段的默认长度</span></span><br><span class="line">  DisableDatetimePrecision: <span class="literal">true</span>, <span class="comment">// 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持</span></span><br><span class="line">  DontSupportRenameIndex: <span class="literal">true</span>, <span class="comment">// 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引</span></span><br><span class="line">  DontSupportRenameColumn: <span class="literal">true</span>, <span class="comment">// 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列</span></span><br><span class="line">  SkipInitializeWithVersion: <span class="literal">false</span>, <span class="comment">// 根据当前 MySQL 版本自动配置</span></span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建一条记录"><a href="#创建一条记录" class="headerlink" title="创建一条记录"></a>创建一条记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name:<span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line">result := db.Create(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="用所选字段创建记录"><a href="#用所选字段创建记录" class="headerlink" title="用所选字段创建记录"></a>用所选字段创建记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure><p>创建一条记录，忽略未指出的字段。</p><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定插入数量</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu_1&quot;</span>&#125;, ...., &#123;Name: <span class="string">&quot;jinzhu_10000&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch size 100</span></span><br><span class="line">db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="创建Hooks"><a href="#创建Hooks" class="headerlink" title="创建Hooks"></a>创建Hooks</h3><p>GORM提供的hooks有<code>BeforeSave</code>, <code>BeforeCreate</code>,<code>AfterSave</code>,<code>AfterCreate</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    u.UUID = uuid.New()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;invalid role&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询单个对象"><a href="#查询单个对象" class="headerlink" title="查询单个对象"></a>查询单个对象</h3><p>GORM提供了<code>First</code>, <code>Take</code>, <code>Last</code> 方法从数据库中检索对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询主键值第一的记录</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询一条记录</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询主键值倒数第一的记录</span></span><br><span class="line">db.Last(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="根据主键查询"><a href="#根据主键查询" class="headerlink" title="根据主键查询"></a>根据主键查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="字符串条件"><a href="#字符串条件" class="headerlink" title="字符串条件"></a>字符串条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取匹配的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;user)</span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-协程</title>
      <link href="/2023/04/24/go-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2023/04/24/go-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>协程是一种用户态的轻量级线程，又称微线程，协程的调度完全由用户控制。<strong>与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。</strong></p><span id="more"></span><h1 id="1-1-Goroutine"><a href="#1-1-Goroutine" class="headerlink" title="1.1 Goroutine"></a>1.1 Goroutine</h1><p>创建Goroutine的成本很小，它就是一段代码，一个函数入口。以及在堆上为其分配的一个堆栈（初始大小为4K，会随着程序的执行自动增长删除）。因此它非常廉价，Go应用程序可以并发运行数千个Goroutines。</p><ol><li>与线程相比，Goroutines非常便宜。它们只是堆栈大小的几个kb，堆栈可以根据应用程序的需要增长和收缩，而在线程的情况下，堆栈大小必须指定并且是固定的</li><li>Goroutines被多路复用到较少的OS线程。在一个程序中可能只有一个线程与数千个Goroutines。如果线程中的任何Goroutine都表示等待用户输入，则会创建另一个OS线程，剩下的Goroutines被转移到新的OS线程。所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的API。</li><li>当使用Goroutines访问共享内存时，通过设计的通道可以防止竞态条件发生。通道可以被认为是Goroutines通信的管道。</li></ol><h1 id="1-2-主goroutine"><a href="#1-2-主goroutine" class="headerlink" title="1.2 主goroutine"></a>1.2 主goroutine</h1><p>封装main函数的goroutine称为主goroutine。</p><p>主goroutine的任务：</p><ol><li>创建一个<code>defer</code>语句，用于在主goroutine退出时做必要的善后工作。</li><li>启动垃圾回收的gotoutine。</li><li>执行main包中的init函数</li><li>执行main函数。</li></ol><h1 id="1-3-goroutine与线程"><a href="#1-3-goroutine与线程" class="headerlink" title="1.3 goroutine与线程"></a>1.3 goroutine与线程</h1><h2 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h2><p>线程都具有一个固定大小的栈内存(2MB)，作为对比，一个goroutine在生命周期开始时只有一个很小的栈，典型情况为2KB。goroutine的栈不是固定大小的，它可以按需增大或者缩小，goroutine栈最大可达1GB。</p><h2 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h2><p>OS线程由内核调度器函数来调度，过程为：保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。这个过程较为缓慢。</p><p>Go有自己的调度器，采用<code>m:n</code>调度技术(复用&#x2F;调度m个goroutine到n个os线程)。Go调度器和内核调度器的工作类似，但Go调度器只需关心单个Go程序的goroutine调度问题。</p><p>os线程调度器由硬件时钟定期触发，Go调度器并非如此。它不需要切换到内核环境，所以调用一个goroutine比调度一个线程的成本低很多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-垃圾回收</title>
      <link href="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的垃圾回收机制"><a href="#常见的垃圾回收机制" class="headerlink" title="常见的垃圾回收机制"></a>常见的垃圾回收机制</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。</p><p>缺点：</p><ul><li>降低性能</li><li>循环引用</li></ul><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>该方法分为两步：</p><ol><li>标记从根节点开始迭代遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；</li><li>清除操作。对没有被标记的内存进行清除操作。</li></ol><p>缺点：</p><ul><li>启动垃圾回收时会暂停当前所用代码的执行。</li></ul><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>分代收集的基本思想是，将堆划分成两个或者多个称为代的空间。新创建的对象存放在称为新生代中，随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中，因此，新生代垃圾回收和老年代垃圾回收两种方式共存，分别对其空间中的对象进行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。</p><h1 id="Go的GC"><a href="#Go的GC" class="headerlink" title="Go的GC"></a>Go的GC</h1><p>go的垃圾回收机制是标记-清除算法。</p><ul><li>标记阶段。获取这些对象的状态信息。</li><li>清扫阶段。回收状态为unreachable的对象。</li></ul><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><ul><li>白色对象：潜在的垃圾，其内存可能被垃圾收集器回收；</li><li>黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象：活跃的对象，存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。</li></ul><p><img src="/.cn//04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%9C%BA%E5%88%B6.png"></p><p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p><p><img src="/.cn//04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%88%9D%E5%A7%8B%E6%B5%81%E7%A8%8B.png"></p><p>三色标记法的工作流程可以归纳成以下几个步骤：</p><ol><li>从灰色对象的集合中选择一个灰色对象将其标记成黑色。</li><li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li><li>重复上述两个步骤直到对象图中不存在灰色对象。</li></ol><p>当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：</p><p><img src="/.cn//04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%BB%93%E6%9E%9C.png"></p><p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p><p><img src="/.cn//04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%B9%B6%E5%8F%91%E9%94%99%E8%AF%AF%E6%A1%88%E4%BE%8B.png"></p><h2 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h2><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。</li></ul><p><img src="/.cn//04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E4%B8%8D%E5%8F%98%E5%BD%A2.png"></p><p>上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p><p>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p><p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色。</p><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p><h1 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h1><p>运行时通过runtime.gcTrigger.test方法决定是否要触发垃圾回收，当满足垃圾收集的基本条件时–允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同的方式触发不同的检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !meestats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">        <span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">        <span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">        <span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">        <span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">    <span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">        <span class="keyword">return</span> <span class="type">int32</span>(t.n - owrk.cycles) &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、gcTriggerHeap ：堆内存的分配达到达控制器计算的触发堆大小；<br>2、gcTriggerTime ：如果一定时间内没有触发，就会触发新的循环，该出发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟；<br>3、gcTriggerCycle：如果当前没有开启垃圾收集，则触发新的循环；<br>4、runtime.gcpercent 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集。</p><p>用于开启垃圾收集的方法 runtime.gcStart 会接收一个 runtime.gcTrigger 类型的结构，所有出现 runtime.gcTrigger 结构体的位置都是触发垃圾收集的代码：</p><ul><li>runtime.sysmon 和 runtime.forcegchelper ：后台运行定时检查和垃圾收集；</li><li>runtime.GC ：用户程序手动触发垃圾收集；</li><li>runtime.mallocgc ：申请内存时根据堆大小触发垃圾收集。</li></ul><p><img src="/.cn//04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL学习笔记</title>
      <link href="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。</p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p><h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">张老师</td></tr><tr><td align="left">2</td><td align="left">王老师</td></tr><tr><td align="left">3</td><td align="left">李老师</td></tr><tr><td align="left">4</td><td align="left">赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">一班</td></tr><tr><td align="left">2</td><td align="left">二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th align="left">id</th><th align="left">teacher_id</th><th align="left">class_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">2</td></tr><tr><td align="left">3</td><td align="left">2</td><td align="left">1</td></tr><tr><td align="left">4</td><td align="left">2</td><td align="left">2</td></tr><tr><td align="left">5</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left">6</td><td align="left">4</td><td align="left">2</td></tr></tbody></table><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">class_id</th><th align="left">name</th><th align="left">gender</th><th align="left">score</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">小明</td><td align="left">M</td><td align="left">90</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">小红</td><td align="left">F</td><td align="left">95</td></tr><tr><td align="left">3</td><td align="left">1</td><td align="left">小军</td><td align="left">M</td><td align="left">88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>要指定条件“分数在80分或以上的学生”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><p>条件查询的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;TABLENAME&gt; WHERE &lt;CONDITION&gt;</span><br><span class="line"># 多条件</span><br><span class="line"># 与条件： AND</span><br><span class="line"># 或条件： OR</span><br></pre></td></tr></table></figure><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>如果我们想查询某几列的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, name FROM students;</span><br><span class="line"># 返回某几列的数据</span><br><span class="line">SELECT C1, C2, C3</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序使用关键词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ORDER BY</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC;</span><br><span class="line"># 默认为升序</span><br></pre></td></tr></table></figure><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每页的最大数量 LIMIT PAGESIZE</span><br><span class="line"># 查询第n页的数据OFFSET PAGESIZE * (n-1)</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>SQL提供了一些函数用于统计数据，这些函数被称谓聚合函数。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SUM</td><td align="left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td align="left">AVG</td><td align="left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td align="left">MAX</td><td align="left">计算某一列的最大值</td></tr><tr><td align="left">MIN</td><td align="left">计算某一列的最小值</td></tr><tr><td align="left">COUNT</td><td align="left">统计记录数目</td></tr></tbody></table><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p><code>INSERT</code>语句的基本语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br><span class="line"># 例如</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br><span class="line"></span><br><span class="line"># 一次性添加多条数据</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line">  (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81);</span><br></pre></td></tr></table></figure><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>更新数据库中的记录，使用<code>UPDATE</code> 语句。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</span><br><span class="line">UPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><code>DELETE</code>语句的基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;TABLENAME&gt; WHERE...;</span><br><span class="line"></span><br><span class="line"># 例</span><br><span class="line">-- 删除id=1的记录</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">begin;# 开始事务</span><br><span class="line">commit; # 提交事务</span><br><span class="line">rollback; # 回滚</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from runoob_transaction_test;</span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; begin;  # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(5);</span><br><span class="line">Query OK, 1 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(6);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; commit; # 提交事务</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  select * from runoob_transaction_test;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; begin;    # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  insert into runoob_transaction_test values(7);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; rollback;   # 回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>事务是不可分割的最小操作单元，要么全部成功，要么全部失败</strong></p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><strong>事务完成时，必须使全部数据保持一致状态。</strong></p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</strong></p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p><strong>事务一旦提交或者回滚，它对数据库中数据的改变就是永久的</strong></p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>赃读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务隔离级别</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION</span><br><span class="line"></span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MYSQL体系结构"><a href="#MYSQL体系结构" class="headerlink" title="MYSQL体系结构"></a>MYSQL体系结构</h2><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801143250778.png" alt="image-20230801143250778"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 存储引擎是存储数据，建立索引，更新查询数据的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。 </p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是MySQL的默认存储引擎。</p><p>特点：</p><ol><li>DML操作遵循ACID模型，支持事务。</li><li>行级锁，提高并发访问性能。</li><li>支持外键FOREIGN KEY约束，保证数据完整性与正确性。</li></ol><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MYSQL早期默认存储引擎。</p><p>特点：</p><ol><li>不支持事务。</li><li>不支持外键</li><li>访问速度快</li></ol><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>存储在内存中。</p><p>特点：</p><ol><li>访问快</li><li>不可持久化存储</li></ol><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801144732943.png" alt="image-20230801144732943"></p><h1 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h1><p> 高效获取数据的数据结构</p><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801150248347.png" alt="image-20230801150248347"></p><p>无索引进行全表扫描，有索引使用平衡二叉树进行查找。</p><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801150351654.png" alt="image-20230801150351654"></p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801150515948.png" alt="image-20230801150515948"></p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801151114273.png" alt="image-20230801151114273"></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801151311818.png" alt="image-20230801151311818"></p><ol><li>所有数据都会出现在叶子结点</li><li>叶子结点形成一个链表</li></ol><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>采用一定的hash算法，将键值算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 </p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对表中主键创建的索引</td><td>唯一</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>列值不能重复</td><td>可以多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td></td><td>可以多个</td><td></td></tr><tr><td>全文索引</td><td>文本中的关键词，而不是比较索引中的值</td><td>可以多个</td><td>FULLTEXT</td></tr></tbody></table><h3 id="聚集索引和和二级索引"><a href="#聚集索引和和二级索引" class="headerlink" title="聚集索引和和二级索引"></a>聚集索引和和二级索引</h3><p><img src="/image-20230801152859817.png" alt="image-20230801152859817"></p><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是一张虚拟存在的表。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] VIEW AS SELECT语句 [WITH [ CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create or replace viem stu_v_1 as select id,name from student where id &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create view stu_v_1</span><br></pre></td></tr></table></figure><h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-并发编程</title>
      <link href="/2023/04/13/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/13/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>现代操作系统提供了三种基本的构造并发程序的方法：</p><ul><li>进程。每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用显式的进程间通信机制。</li><li>I&#x2F;O多路复用。</li><li>线程</li></ul><span id="more"></span><h1 id="12-1-基于进程的并发编程"><a href="#12-1-基于进程的并发编程" class="headerlink" title="12.1 基于进程的并发编程"></a>12.1 基于进程的并发编程</h1><h2 id="12-1-1-基于进程的并发服务器代码"><a href="#12-1-1-基于进程的并发服务器代码" class="headerlink" title="12.1.1 基于进程的并发服务器代码"></a>12.1.1 基于进程的并发服务器代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHID, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            echo(connfd);</span><br><span class="line">            Close(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-网络编程</title>
      <link href="/2023/04/12/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/12/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本章将开发一个小但功能齐全的Web服务器，能够为Web浏览器提供静态和动态的内容</p><span id="more"></span><h1 id="11-1-客户端-服务器编程模型"><a href="#11-1-客户端-服务器编程模型" class="headerlink" title="11.1 客户端-服务器编程模型"></a>11.1 客户端-服务器编程模型</h1><p>模型的基本操作是事务。</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcEDmtR-tqJ-C9Mr2d%2F-MIcFLCPfWxblhRZ7AP_%2F11-01%20%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%8B%E5%8A%A1.png?alt=media&token=78c8799d-c6de-4407-8770-609fff26bf02" alt="img"></p><p><strong>客户端和服务器是进程。</strong> 一台主机可以同时运行许多不同的客户端和服务器。</p><h1 id="11-2-网络"><a href="#11-2-网络" class="headerlink" title="11.2 网络"></a>11.2 网络</h1><p>对于主机而言，网络只是I&#x2F;O设备，是数据源与数据接收方。网络主机的硬件组成如图所示：</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcFnVWynYxtK3NJ2f-%2F11-02%20%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png?alt=media&token=3b44a186-e4d9-4249-be30-51873d1fbe14" alt="img" style="zoom:67%;"><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种局域网技术。一个以太网段如下图所示：</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcG2K-973Kc7SXR3lj%2F11-03%20%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%AE%B5.png?alt=media&token=f1e8e061-ce6a-4f49-be7f-5a7c3444cf39" alt="img"></p><p>电缆的一段连接到主机的适配器，一段连接到集线器的一个端口上。集线器会将数据复制到每个端口上。</p><p><strong>每一个以太网适配器都有一个唯一的48位地址。</strong></p><p>以太网段通过<strong>网桥</strong> 连接成较大的局域网，被称为桥接以太网。在一个桥接以太网里，一些电缆连接网桥与网桥，而另外一些连接网桥和集线器。这些电缆的带宽可以是不同的。在我们的示例中，网桥与网桥之间的电缆有 1 Gb&#x2F;s 的带宽，而四根网桥和集线器之间电缆的带宽却是 100 Mb&#x2F;s。</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcGBwQgcFq_cQ41BB3%2F11-04%20%E6%A1%A5%E6%8E%A5%E4%BB%A5%E5%A4%AA%E7%BD%91.png?alt=media&token=be280145-d387-4296-bc60-2d05e2a78e02" alt="img" style="zoom:67%;"><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>多个不兼容的局域网通过路由器连接起来。路由器对于它连接到的每个网络都有一个端口。简化的广域网模型如下：</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcGwrig9daBai1FRYF%2F11-06%20%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C.png?alt=media&token=5bcd8467-c2bb-470e-bed0-fac5b929f4e1" alt="img"></p><h2 id="数据通过互联网传送的过程"><a href="#数据通过互联网传送的过程" class="headerlink" title="数据通过互联网传送的过程"></a>数据通过互联网传送的过程</h2><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcHP1NeaIedAWbfoVx%2F11-07%20%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E4%BB%8E%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA%E4%BC%A0%E9%80%81%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA.png?alt=media&token=581d6613-fcdc-4710-b94f-23b375c3423f" alt="img"></p><ol><li><p>运行在主机 A 上的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区中。</p></li><li><p>主机 A 上的协议软件通过在数据前附加互联网络包头和 LAN1 帧头，创建了一个 LAN1 的帧。互联网络包头寻址到互联网络主机 B。LAN1 帧头寻址到路由器。然后它传送此帧到适配器。注意，LAN1 帧的有效载荷是一个互联网络包，而互联网络包的有效载荷是实际的用户数据。这种封装是基本的网络互联方法之一。</p></li><li><p>LAN1 适配器复制该帧到网络上。</p></li><li><p>当此帧到达路由器时，路由器的 LAN1 适配器从电缆上读取它，并把它传送到协议软件。</p></li><li><p>路由器从互联网络包头中提取出目的互联网络地址，并用它作为路由表的索引，确定向哪里转发这个包，在本例中是 LAN2。路由器剥落旧的 LAN1 的帧头，加上寻址到主机 B 的新的 LAN2 帧头，并把得到的帧传送到适配器。</p></li><li><p>路由器的 LAN2 适配器复制该帧到网络上。</p></li><li><p>当此帧到达主机 B 时，它的适配器从电缆上读到此帧，并将它传送到协议软件。</p></li><li><p>最后，主机 B 上的协议软件剥落包头和帧头。当服务器进行一个读取这些数据的系统调用时，协议软件最终将得到的数据复制到服务器的虚拟地址空间。</p></li></ol><h1 id="11-3-全球IP因特网"><a href="#11-3-全球IP因特网" class="headerlink" title="11.3 全球IP因特网"></a>11.3 全球IP因特网</h1><p>下图展示了一个因特网客户端—服务器应用程序的基本硬件和软件组织。</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcHkeFKYXQWEZwjoyA%2F-MIcHnJyVgajdck33wQY%2F11-08%20%E4%B8%80%E4%B8%AA%E5%9B%A0%E7%89%B9%E7%BD%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%84%E7%BB%87.png?alt=media&token=83af1809-b538-4c75-a756-b72fce11d12e" alt="img"></p><p>因特网的客户端和服务器混合使用<strong>套接字接口</strong>函数和 Unix l&#x2F;O 函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的 TCP&#x2F;IP 函数。</p><p>TCP&#x2F;IP 实际是一个协议族，其中每一个都提供不同的功能。</p><p>从程序员的视角来看，因特网是一个世界范围内的主机集合，满足以下特性：</p><ul><li>主机集合被映射为一组32位的IP地址（IPV4,IPV6为128位的地址）。</li><li>IP地址被映射为一组称为因特网域名的标识符。</li><li>因特网主机上的进程能够通过连接来与任何其他因特网主机上的进程通信。</li></ul><h2 id="11-3-1-IP地址"><a href="#11-3-1-IP地址" class="headerlink" title="11.3.1 IP地址"></a>11.3.1 IP地址</h2><p>一个IP地址就是一个32位无符号整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-2-因特网连接"><a href="#11-3-2-因特网连接" class="headerlink" title="11.3.2 因特网连接"></a>11.3.2 因特网连接</h2><p>一个套接字是连接的一个端点，每个套接字都有相应的套接字地址。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的端口组成的。</p><p>一个连接是偶遇它两端的套接字地址唯一确定的，这对地址叫做套接字对。</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcIVA8Oa5oAQmnqcsA%2F-MIcIdkIs4DHVjeiXnbH%2F11-11%20%E5%9B%A0%E7%89%B9%E7%BD%91%E8%BF%9E%E6%8E%A5%E5%88%86%E6%9E%90.png?alt=media&token=53e83d73-f626-4f94-abc4-71e9dfb9ecf7" alt="img"></p><h1 id="11-4-套接字接口"><a href="#11-4-套接字接口" class="headerlink" title="11.4 套接字接口"></a>11.4 套接字接口</h1><p>套接字接口是一组函数，它们和Unix I&#x2F;O函数结合起来，用以创建网络应用。</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcIVA8Oa5oAQmnqcsA%2F-MIcIpAw0dyTG0YUwyFW%2F11-12%20%E5%9F%BA%E4%BA%8E%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A6%82%E8%BF%B0.png?alt=media&token=74a1bb56-bc88-4cd7-afe6-0f209890a137" alt="img" style="zoom:67%;"><h2 id="11-4-1-套接字地址结构"><a href="#11-4-1-套接字地址结构" class="headerlink" title="11.4.1 套接字地址结构"></a>11.4.1 套接字地址结构</h2><p>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span>       sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">    <span class="type">uint16_t</span>       sin_port;     <span class="comment">/* Port number in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/* IP address in network byte order */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  sin_zero[<span class="number">8</span>];  <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span>  sa_family;    <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="type">char</span>      sa_data[<span class="number">14</span>];  <span class="comment">/* Address data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-4-2-socket函数"><a href="#11-4-2-socket函数" class="headerlink" title="11.4.2 socket函数"></a>11.4.2 socket函数</h2><p>客户端和服务器使用socket函数来创建一个套接字描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><h2 id="11-4-3-connect函数"><a href="#11-4-3-connect函数" class="headerlink" title="11.4.3 connect函数"></a>11.4.3 connect函数</h2><p>客户端通过connect函数来建立和服务器的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>connect 函数试图与套接字地址为addr的服务器建立一个因特网连接，connect函数会一直阻塞直至成功建立连接或者是发生错误。</p><h2 id="11-4-4-bind函数"><a href="#11-4-4-bind函数" class="headerlink" title="11.4.4 bind函数"></a>11.4.4 bind函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">// bind 函数告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来。参数 addrlen 就是 sizeof(sockaddr_in)。对于 socket 和 connect，最好的方法是用 getaddrinfo 来为 bind 提供参数</span></span><br></pre></td></tr></table></figure><h2 id="11-4-5-listen函数"><a href="#11-4-5-listen函数" class="headerlink" title="11.4.5 listen函数"></a>11.4.5 listen函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// listen 函数将 sockfd 从一个主动套接字转化为一个监听套接字（listening socket），该套接字可以接受来自客户端的连接请求。backlog 参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。通常我们会把它设置为一个较大的值，比如 1024。</span></span><br></pre></td></tr></table></figure><h2 id="11-4-6-accept函数"><a href="#11-4-6-accept函数" class="headerlink" title="11.4.6 accept函数"></a>11.4.6 accept函数</h2><p>服务器通过调用 accept 函数来等待来自客户端的连接请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">// accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个已连接描述符（connected descriptor），这个描述符可被用来利用 Unix I/O 函数与客户端通信。</span></span><br></pre></td></tr></table></figure><p>监听描述符是作为客户端连接请求的一个端点。它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点。</p><p>下图描绘了监听描述符和已连接描述符的角色</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcIVA8Oa5oAQmnqcsA%2F-MIcJ4OomcM5yziiKQoR%2F11-14%20%E7%9B%91%E5%90%AC%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E5%B7%B2%E8%BF%9E%E6%8E%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E8%A7%92%E8%89%B2.png?alt=media&token=da343219-c801-4a60-bdbe-d6ef74511cec" alt="img"></p><p><strong>区分监听描述符和已连接描述符的目的：</strong></p><p>因为它使得我们可以. 建立并发服务器，它能够同时处理许多客户端连接。例如，每次一个连接请求到达监听描述符时，我们可以派生（fork）—个新的进程，它通过已连接描述符与客户端通信。</p><h2 id="11-4-7-主机和服务的转换"><a href="#11-4-7-主机和服务的转换" class="headerlink" title="11.4.7 主机和服务的转换"></a>11.4.7 主机和服务的转换</h2><ol><li>getaddrinfo函数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo **result)</span>;</span><br><span class="line"><span class="comment">// 返回：如果成功则为 0，如果错误则为非零的错误代码。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *result)</span>;</span><br><span class="line"><span class="comment">// 返回：无。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>;</span><br><span class="line"><span class="comment">// 返回：错误消息。</span></span><br></pre></td></tr></table></figure><h1 id="11-5-Web服务器"><a href="#11-5-Web服务器" class="headerlink" title="11.5 Web服务器"></a>11.5 Web服务器</h1><h2 id="11-5-1-Web基础"><a href="#11-5-1-Web基础" class="headerlink" title="11.5.1 Web基础"></a>11.5.1 Web基础</h2><p>Web客户端与服务器之间的交互HTTP协议。HTTP 是一个简单的协议。一个 Web 客户端（即浏览器）打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p><h2 id="11-5-2-Web内容"><a href="#11-5-2-Web内容" class="headerlink" title="11.5.2 Web内容"></a>11.5.2 Web内容</h2><p><strong>Web服务器向客户端提供内容的方式</strong></p><ul><li>读取磁盘内容并返回给服务器。静态内容。</li><li>返回可执行文件的输出。动态内容。</li></ul><p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 <strong>URL</strong>（Universal Resource Locator，通用资源定位符）。</p><p>可执行文件的 URL 可以在文件名后包括程序参数。“?” 字符分隔文件名和参数，而且每个参数都用 “&amp;” 字符分隔开。</p><h2 id="11-5-3-HTTP事务"><a href="#11-5-3-HTTP事务" class="headerlink" title="11.5.3 HTTP事务"></a>11.5.3 HTTP事务</h2><h3 id="1-HTTP请求"><a href="#1-HTTP请求" class="headerlink" title="1 HTTP请求"></a>1 HTTP请求</h3><p>一个请求行+请求报头。</p><h3 id="2-HTTP响应"><a href="#2-HTTP响应" class="headerlink" title="2 HTTP响应"></a>2 HTTP响应</h3><p>响应行+响应报头+响应体。</p><p>响应行： version + status-code + status-message</p><table><thead><tr><th>状态代码</th><th>状态消息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>处理请求无误</td></tr><tr><td>301</td><td>永久移动</td><td>内容已移动到 location 头中指明的主机上</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不能理解请求</td></tr><tr><td>403</td><td>禁止</td><td>服务器无权访问所请求的文件</td></tr><tr><td>404</td><td>未发现</td><td>服务器不能找到所请求的文件</td></tr><tr><td>501</td><td>未实现</td><td>服务器不支持请求的方法</td></tr><tr><td>505</td><td>HTTP 版本不支持</td><td>服务器不支持请求的版本</td></tr></tbody></table><h2 id="11-5-4-服务动态内容"><a href="#11-5-4-服务动态内容" class="headerlink" title="11.5.4 服务动态内容"></a>11.5.4 服务动态内容</h2><p> <strong>CGI</strong>（Common Gateway Interface，通用网关接口）。</p><h3 id="1-客户端如何将程序参数传递给服务器"><a href="#1-客户端如何将程序参数传递给服务器" class="headerlink" title="1 客户端如何将程序参数传递给服务器"></a>1 客户端如何将程序参数传递给服务器</h3><p>GET请求的参数在url中传递。</p><p>POST请求的参数在请求主题中传递。</p><h3 id="2-服务器如何将参数传递给子进程"><a href="#2-服务器如何将参数传递给子进程" class="headerlink" title="2 服务器如何将参数传递给子进程"></a>2 服务器如何将参数传递给子进程</h3><p>服务器接收请求后通过fork创建一个子进程，并调用execve执行程序。</p><h3 id="3-服务器如何将其他信息传递给子进程"><a href="#3-服务器如何将其他信息传递给子进程" class="headerlink" title="3 服务器如何将其他信息传递给子进程"></a>3 服务器如何将其他信息传递给子进程</h3><p>CGI 定义了大量的其他环境变量，一个 CGI 程序在它运行时可以设置这些环境变量。</p><table><thead><tr><th>环境变量</th><th>描述</th></tr></thead><tbody><tr><td>QUERY_STRING</td><td>程序参数</td></tr><tr><td>SERVER_PORT</td><td>父进程侦听的端口</td></tr><tr><td>REQUEST_METHOD</td><td>GET 或 POST</td></tr><tr><td>REMOTE_HOST</td><td>客户端的域名</td></tr><tr><td>REMOTE_ADDR</td><td>客户端的点分十进制 IP 地址</td></tr><tr><td>CONTENT_TYPE</td><td>只对 POST 而言：请求体的 MIME 类型</td></tr><tr><td>CONTENT_LENGTH</td><td>只对 POST 而言：请求体的字节大小</td></tr></tbody></table><h3 id="4-子进程将他的输出发送到哪里"><a href="#4-子进程将他的输出发送到哪里" class="headerlink" title="4 子进程将他的输出发送到哪里"></a>4 子进程将他的输出发送到哪里</h3><p>一个 CGI 程序将它的动态内容发送到标准输出。在子进程加载并运行 CGI 程序之前，它使用 Linux dup2 函数将标准输出重定向到和客户端相关联的已连接描述符。因此，任何 CGI 程序写到标准输出的东西都会直接到达客户端。</p><p>下面展示了一个简单的 CGI 程序，它对两个参数求和，并返回带结果的 HTML 文件给客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf, *p;</span><br><span class="line">    <span class="type">char</span> arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extract the two arguments */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(buf, ’&amp;’);</span><br><span class="line">        *p = ’\<span class="number">0</span>’;</span><br><span class="line">        <span class="built_in">strcpy</span>(arg1, buf);</span><br><span class="line">        <span class="built_in">strcpy</span>(arg2, p + <span class="number">1</span>);</span><br><span class="line">        n1 = atoi(arg1);</span><br><span class="line">        n2 = atoi(arg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the response body */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;Welcome to add.com: &quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sTHE Internet addition portal.\r\n&lt;p&gt;&quot;</span>, content);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe answer is: %d + %d = %d\r\n&lt;p&gt;&quot;</span>,</span><br><span class="line">            content, n1, n2, n1 + n2);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThanks for visiting!\r\n&quot;</span>, content);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Generate the HTTP response */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-length: %d\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(content));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈mmap</title>
      <link href="/2023/04/09/%E6%B5%85%E8%B0%88mmap/"/>
      <url>/2023/04/09/%E6%B5%85%E8%B0%88mmap/</url>
      
        <content type="html"><![CDATA[<p>mmap能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。普通文件在被映射到进程地址空间后，进程可以像访问普通内存一样访问文件，不必通过read()、write()等系统调用来访问文件。</p><span id="more"></span><h4 id="mmap接口描述"><a href="#mmap接口描述" class="headerlink" title="mmap接口描述"></a>mmap接口描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// addr: 内存空间上的起始地址，一般为NULL，内核自动分配</span></span><br><span class="line"><span class="comment">// length: 字节数</span></span><br><span class="line"><span class="comment">// prot: 共享内存的访问权限</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PROT_READ</span></span><br><span class="line"><span class="comment">PROT_WRITE</span></span><br><span class="line"><span class="comment">PROT_EXEC</span></span><br><span class="line"><span class="comment">PROT_NONE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// flags:</span></span><br><span class="line"><span class="comment">// fd: 文件描述符</span></span><br><span class="line"><span class="comment">// offset: 偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值: 文件映射到进程空间的地址。</span></span><br></pre></td></tr></table></figure><h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><p>匿名映射没有对应的文件。fork()得到的子进程会拷贝父进程映射后的空间，同时也继承了mmap()的返回地址，从而实现进程间的通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名映射的例子</span></span><br><span class="line">ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">switch</span>(pid) &#123;</span><br><span class="line">    <span class="keyword">case</span> pid &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> pid = <span class="number">0</span>:</span><br><span class="line">        lock(ptr);</span><br><span class="line">        critical_section();</span><br><span class="line">        unlock(ptr);</span><br><span class="line">    <span class="keyword">case</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        lock(ptr);</span><br><span class="line">        critical_section();</span><br><span class="line">        unlock(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7:链接</title>
      <link href="/2023/04/09/7-%E9%93%BE%E6%8E%A5/"/>
      <url>/2023/04/09/7-%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。</p><span id="more"></span><h1 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h1><p>下面是两个运行示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux下编译该C程序的命令</span></span><br><span class="line">linux&gt; gcc -Og -o prog main.c sum.c</span><br></pre></td></tr></table></figure><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8jCXJzp_pYD5VGG8o%2F-MI8oSBe7kBcpszDCC7T%2F07-02%20%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5.png?alt=media&token=4a1bcea6-9bd1-4222-98e3-fc37075a2c56" alt="img" style="zoom:50%;"><h1 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h1><p>静态链接器 (static linker)以一组可重定向的目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。</p><p>input:</p><p>​由各种不同的的代码和数据节构成，每一节都是一个连续的字节序列。</p><p>链接器的任务：</p><ul><li>符号解析。将每个符号引用与每个符号定义关联起来。</li><li>重定位。 编译器和汇编器生成从地址0开始代码和数据节。链接器通过把每个符号定义和内存位置关联起来，从而重定向这些节。然后修改所有对这些符号的引用。使得他们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。</li></ul><h1 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h1><p>目标文件有三种形式：</p><ul><li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接复制到内存并执行。</li><li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li></ul><h1 id="7-4-可重定向目标文件"><a href="#7-4-可重定向目标文件" class="headerlink" title="7.4 可重定向目标文件"></a>7.4 可重定向目标文件</h1><p>下图展示了一个典型的ELF可重定向目标文件的格式。</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8p7rbEV-s_nV5Ru6X%2F-MI8pJh5IxzFL80HMTY3%2F07-03%20%E5%85%B8%E5%9E%8B%E7%9A%84ELF%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.png?alt=media&token=d9d57c1c-24ef-401a-bf91-04bdf60fad68" alt="img" style="zoom:80%;"><p><strong>ELF 头</strong>（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。</p><p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节： </p><ul><li><strong>.text：</strong>已编译程序的机器代码。</li><li><strong>.rodata：</strong>只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li><li><strong>.data：</strong>已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li><li><strong>.bss：</strong>未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li><li><strong>.symtab：</strong>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li><li><strong>.rel.text：</strong>一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li><li><strong>.rel.data：</strong>被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li><strong>.debug：</strong>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li><li><strong>.line：</strong>原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li><li><strong>.strtab：</strong>一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li></ul><h1 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h1><p>在链接器的上下文中，有三种不同的符号：</p><ul><li><p>由模块 m 定义并能被其他模块引用的<strong>全局符号</strong>。全局链接器符号对应于非静态的 C 函数和全局变量。</p></li><li><p>由其他模块定义并被模块 m 引用的<strong>全局符号</strong>。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。</p></li><li><p>只被模块 m 定义和引用的<strong>局部符号</strong>。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。</p></li></ul><p>.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ELF符号表条目</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;<span class="comment">// 字符串表中的字节偏移</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>;<span class="comment">// 函数或者数据</span></span><br><span class="line">    <span class="type">char</span> binding:<span class="number">4</span>; <span class="comment">// 本地或者全局</span></span><br><span class="line">    <span class="type">short</span> section;<span class="comment">// 分配的目标文件的节</span></span><br><span class="line">    <span class="type">long</span> value;<span class="comment">// 对齐要求</span></span><br><span class="line">    <span class="type">long</span> size;<span class="comment">// 最小的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h1><h2 id="7-6-1-链接器如何解析多重定义的全局符号"><a href="#7-6-1-链接器如何解析多重定义的全局符号" class="headerlink" title="7.6.1 链接器如何解析多重定义的全局符号"></a>7.6.1 链接器如何解析多重定义的全局符号</h2><p>在编译时，编译器向汇编器输出每个全局符号的强弱类型。汇编器将这个信息编码在可重定向目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p><p>链接器处理多重定义的符号名的规则如下：</p><ul><li><p><strong>规则 1：</strong>不允许有多个同名的强符号。</p></li><li><p><strong>规则 2：</strong>如果有一个强符号和多个弱符号同名，那么选择强符号。</p></li><li><p><strong>规则 3：</strong>如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</p></li></ul><h2 id="7-6-2-与静态链接库"><a href="#7-6-2-与静态链接库" class="headerlink" title="7.6.2 与静态链接库"></a>7.6.2 与静态链接库</h2><p>编译系统提供了一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，可以作为链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标板块。</p><p>与静态库链接的示意图如下图所示：</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8p7rbEV-s_nV5Ru6X%2F-MI8pkPoBiVWj0eMXoIA%2F07-08%20%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5.png?alt=media&token=fcb51f44-d9fc-4e95-8889-4888b9f920ae" alt="img" style="zoom:80%;"><h2 id="7-6-3-链接器如何使用静态库来解析引用"><a href="#7-6-3-链接器如何使用静态库来解析引用" class="headerlink" title="7.6.3 链接器如何使用静态库来解析引用"></a>7.6.3 链接器如何使用静态库来解析引用</h2><h1 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h1><p>当在命令号中键入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; ./prog</span><br></pre></td></tr></table></figure><p>Shell调用被称为加载器的操作系统代码来运行该可执行目标文件。任何Linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存当中，然后通过跳转到程序的第一条指令或入口点来运行该程序。</p><h1 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h1><p><strong>共享库</strong>（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking），是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。共享库也称为<strong>共享目标</strong>（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。</p><p>动态链接过程如下图所示：</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8qpMNa8rVv2h1gw56%2F-MI8r4myxZNQCTrFzKsH%2F07-16%20%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93.png?alt=media&token=0901e781-87bf-4e4f-b1f9-31ca05c51f7c" alt="img" style="zoom:67%;"><p>为了构造图中示例向量例程的共享库，我们调用编译器驱动程序，给编译器和链接器如下指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c</span><br><span class="line"><span class="comment">// -shared选项指示链接器创建一个共享的目标文件</span></span><br><span class="line"><span class="comment">// -fpic选项指示编译器生成与位置无关的代码</span></span><br></pre></td></tr></table></figure><p>链接的指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; gcc -o prog2l main2.c ./libvector.so</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10:系统级IO</title>
      <link href="/2023/04/08/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
      <url>/2023/04/08/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
      
        <content type="html"><![CDATA[<p>I&#x2F;O是在主存和外部设备之间拷贝数据的过程。本章介绍Unix I&#x2F;O 和一般I&#x2F;O的基本概念。并展示在C程序中如何可靠地使用这些接口。</p><span id="more"></span><h1 id="10-1-Unix-I-x2F-O"><a href="#10-1-Unix-I-x2F-O" class="headerlink" title="10.1 Unix I&#x2F;O"></a>10.1 Unix I&#x2F;O</h1><p>在UNIX系统中，一切都被认为是字节序列(文件), 因而所有的输入域输出都能以统一的方式进行。</p><ul><li><p><strong>打开文件</strong> 内核打开文件后，会返回一个小的非负整数，叫做 <strong>描述符</strong> ，用于表示文件。</p></li><li><p><strong>改变当前文件的位置</strong> 内核保持文件位置k，是文件开头起始的字节偏移量。<code>seek</code>操作可以显式的设置文件的当前位置k。</p></li><li><p><strong>读写文件</strong> </p><ul><li>读操作。从文件拷贝n个字节到存储器，偏移量k&#x3D;k+n。若文件大小为m，当k大于等于m时，触发EOF。</li><li>写操作。从存储器拷贝n&gt;0个字节到一个文件，文件k&#x3D; k + n。</li></ul></li><li><p><strong>关闭文件</strong></p></li></ul><h1 id="10-2-打开和关闭文件"><a href="#10-2-打开和关闭文件" class="headerlink" title="10.2 打开和关闭文件"></a>10.2 打开和关闭文件</h1><p>open函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>* filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flags</span></span><br><span class="line"><span class="comment">// O_RDONLY: 只读</span></span><br><span class="line"><span class="comment">// O_WRONLY: 只写</span></span><br><span class="line"><span class="comment">// O_RDWR: 读写</span></span><br><span class="line"><span class="comment">// O_CREAT: 如果文件不存在，就创建它的一个截断的文件</span></span><br><span class="line"><span class="comment">// O_TRUNC: 如果文件已经存在，就截断它</span></span><br><span class="line"><span class="comment">// O_APPEND 打开文件时设置文件位置到文件的结尾处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mode: 新文件的访问权限位</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="10-3-读写文件"><a href="#10-3-读写文件" class="headerlink" title="10.3 读写文件"></a>10.3 读写文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span>, n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 成功：读/写的字节数</span></span><br><span class="line"><span class="comment">// EOF: 0</span></span><br><span class="line"><span class="comment">// 失败： -1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ssize_t和size_t的区别</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ssize_t</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> <span class="type">unsigned</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><h1 id="10-4-用RIO包健壮的读写"><a href="#10-4-用RIO包健壮的读写" class="headerlink" title="10.4 用RIO包健壮的读写"></a>10.4 用RIO包健壮的读写</h1><h2 id="10-4-1-RIO无缓冲输入输出函数"><a href="#10-4-1-RIO无缓冲输入输出函数" class="headerlink" title="10.4.1 RIO无缓冲输入输出函数"></a>10.4.1 RIO无缓冲输入输出函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值与read和write类似</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* userbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span>* bufp = usrbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno = EINTR)</span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">char</span>* bufp = usrbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-2-RIO带缓冲的输入函数"><a href="#10-4-2-RIO带缓冲的输入函数" class="headerlink" title="10.4.2 RIO带缓冲的输入函数"></a>10.4.2 RIO带缓冲的输入函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">// 将描述符fd和地址rp处读缓冲区联系起来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="comment">// 从一个内部 读缓冲区 拷贝一个文本行，当缓冲区变空时，会自动调用read重新填满缓冲区。最多写maxlen - 1 个字节，然后用一个空字符截断。</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 从文件rp中最多读n个字节到存储器位置usrbuf。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从标准输入拷贝一个文本文件到标准输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;rio, STDIN_FILENO);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">        Rio_writen(STDOUT_FILENO, buf, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个类型为rio_t的读缓冲区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;<span class="comment">// 缓冲区关联的文件描述符</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;<span class="comment">// 缓冲区中未读的字节数</span></span><br><span class="line">    <span class="type">char</span>* rio_bufptr;<span class="comment">// 缓冲区中下一个字节的位置</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];<span class="comment">//内部缓冲区大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rio_readinitb函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rio_read函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">char</span>* usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno !=EINTR)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>)</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rio_readlineb 的一个实现</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> maxlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, rc;</span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (n  = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">           *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((rc == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// EOF, no data read</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// EOF, read some data;</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *bufp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-5-读取文件元数据"><a href="#10-5-读取文件元数据" class="headerlink" title="10.5 读取文件元数据"></a>10.5 读取文件元数据</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数输入的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>st_dev;<span class="comment">// 设备</span></span><br><span class="line">    <span class="type">ino_t</span>st_ino;<span class="comment">// inode</span></span><br><span class="line">    <span class="type">mode_t</span>st_mode;<span class="comment">// 保护和文件类型</span></span><br><span class="line">    <span class="type">nlink_t</span>st_nlink;<span class="comment">// 硬链接数目</span></span><br><span class="line">    <span class="type">uit_t</span>st_uid;<span class="comment">// 文件拥有者的用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>st_gid;<span class="comment">// 文件拥有者的组ID</span></span><br><span class="line">    <span class="type">dev_t</span>st_rdev;<span class="comment">// 设备类型</span></span><br><span class="line">    <span class="type">off_t</span>st_size;<span class="comment">// 总大小(字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize;<span class="comment">// 文件系统I/O的块大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks;<span class="comment">// 分配的块数</span></span><br><span class="line">    <span class="type">time_t</span>st_atime;<span class="comment">// 最后一次进入的时间</span></span><br><span class="line">    <span class="type">time_t</span>st_mtime;<span class="comment">// 最后一次更新的时间</span></span><br><span class="line">    <span class="type">time_t</span>st_ctime;<span class="comment">// 最后一次改变的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询和处理一个文件的st_mode位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span>* type, *readok;</span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((stat.st_mode &amp; S_ISUSR))</span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-6-共享文件"><a href="#10-6-共享文件" class="headerlink" title="10.6 共享文件"></a>10.6 共享文件</h1><p>内核用三个相关的数据结构描述打开的文件：</p><ul><li>描述符表。 每个进程都有独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</li><li>文件表。打开的文件的集合，由所有的进程共享。</li><li>v-node表。同文件表一样，由所有的进程共享。</li></ul><h1 id="10-7-I-x2F-O重定向"><a href="#10-7-I-x2F-O重定向" class="headerlink" title="10.7 I&#x2F;O重定向"></a>10.7 I&#x2F;O重定向</h1><p>Unix Shell提供了I&#x2F;O重定向机制，允许用户将磁盘文件和标准输入输出联系起来。例如：</p><p><code>unix&gt; ls &gt; foo.txt</code></p><p>下面使用dup2函数实现I&#x2F;O重定向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> new fd)</span>;</span><br><span class="line"><span class="comment">// dup2函数拷贝描述符表表项oldfd到描述符表表项newfd，覆盖描述符表表项newfd以前的内容。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iris:day1</title>
      <link href="/2023/04/08/iris%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/04/08/iris%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Iris是一个Go语言下的MVC框架。</p><span id="more"></span><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>MVC架构模式的示意图：</p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/1280px-MVC-Process.svg.png" style="zoom:25%;"><p>下面是一个使用MVC架构实现的一个简单Iris App</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris/middleware/logger&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris/middleware/recover&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris/mvc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := iris.New()</span><br><span class="line">    app.Use(<span class="built_in">recover</span>.New())</span><br><span class="line">    app.Use(logger.New())</span><br><span class="line"></span><br><span class="line">mvc.New(app).Handle(<span class="built_in">new</span>(ExampleController))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// http://localhost:8080</span></span><br><span class="line">    <span class="comment">// http://localhost:8080/ping</span></span><br><span class="line">    <span class="comment">// http://localhost:8080/hello</span></span><br><span class="line">    app.Run(iris.Addr(<span class="string">&quot;:8080&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExampleController serves the &quot;/&quot;, &quot;/ping&quot; and &quot;/hello&quot;.</span></span><br><span class="line"><span class="keyword">type</span> ExampleController <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get serves</span></span><br><span class="line"><span class="comment">// Method:   GET</span></span><br><span class="line"><span class="comment">// Resource: http://localhost:8080</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ExampleController)</span></span> Get() mvc.Result &#123;</span><br><span class="line">    <span class="keyword">return</span> mvc.Response&#123;</span><br><span class="line">        ContentType: <span class="string">&quot;text/html&quot;</span>,</span><br><span class="line">        Text:        <span class="string">&quot;&lt;h1&gt;Welcome&lt;/h1&gt;&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPing serves</span></span><br><span class="line"><span class="comment">// Method:   GET</span></span><br><span class="line"><span class="comment">// Resource: http://localhost:8080/ping</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ExampleController)</span></span> GetPing() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetHello serves</span></span><br><span class="line"><span class="comment">// Method:   GET</span></span><br><span class="line"><span class="comment">// Resource: http://localhost:8080/hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ExampleController)</span></span> GetHello() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello Iris!&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HTTP主机配置"><a href="#HTTP主机配置" class="headerlink" title="HTTP主机配置"></a>HTTP主机配置</h1><h2 id="监听和服务"><a href="#监听和服务" class="headerlink" title="监听和服务"></a>监听和服务</h2><p>服务器的初始化用Run方法执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Tcp 上监听网络地址 0.0.0.0:8080</span></span><br><span class="line">app.Run(iris.Addr(<span class="string">&quot;:8080&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和前面一样，但是使用自定义 http.Server 也可以在其他地方运行</span></span><br><span class="line">app.Run(iris.Server(&amp;http.Server&#123;Addr:<span class="string">&quot;:8080&quot;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自定义的或者标准的net.Listener并传递给app.Run</span></span><br><span class="line"><span class="comment">// 使用自定义 net.Listener</span></span><br><span class="line">l, err := net.Listen(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">app.Run(iris.Listener(l))</span><br></pre></td></tr></table></figure><p>下面是一个完整的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := iris.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UNIX socket</span></span><br><span class="line">    <span class="keyword">if</span> errOs := os.Remove(socketFile); errOs != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(errOs) &#123;</span><br><span class="line">        app.Logger().Fatal(errOs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l, err := net.Listen(<span class="string">&quot;unix&quot;</span>, socketFile)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        app.Logger().Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = os.Chmod(socketFile, mode); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        app.Logger().Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.Run(iris.Listener(l))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主机配置程序"><a href="#主机配置程序" class="headerlink" title="主机配置程序"></a>主机配置程序</h2><p>以上所有的监听都是接收 <code>func(*iris.Supervisor)</code>为最后一个变量。可以通过这些函数传递的特定主机来添加配置程序。</p><p>下面的示例代码在服务器关闭时触发一个回调函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.Run(iris.Addr(<span class="string">&quot;:8080&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(h *iris.Supervisor)</span></span> &#123;</span><br><span class="line">    h.RegisterOnShutdown(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;server terminated&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h1 id="HTTP路由"><a href="#HTTP路由" class="headerlink" title="HTTP路由"></a>HTTP路由</h1><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p> <code>Handler</code> 用于处理请求</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>iris提供了所有的HTTP方法，第一个参数是路由路径，第二个可变参数是一个或者多个iris.Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">app := iris.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;GET&quot;</span></span><br><span class="line">app.Get(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;POST&quot;</span></span><br><span class="line">app.Post(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;PUT&quot;</span></span><br><span class="line">app.Put(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;DELETE&quot;</span></span><br><span class="line">app.Delete(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;OPTIONS&quot;</span></span><br><span class="line">app.Options(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;TRACE&quot;</span></span><br><span class="line">app.Trace(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;CONNECT&quot;</span></span><br><span class="line">app.Connect(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;HEAD&quot;</span></span><br><span class="line">app.Head(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;PATCH&quot;</span></span><br><span class="line">app.Patch(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于所有 HTTP 方法</span></span><br><span class="line">app.Any(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(ctx iris.Context)</span></span>&#123;</span><br><span class="line">    ctx.Writef(<span class="string">&quot;Hello from method: %s and path: %s&quot;</span>, ctx.Method(), ctx.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h2><p>一组路由可以用前缀路径分组，组之间共享相同的中间件和模板布局，组内可以嵌套组。</p><p><code>.Party</code> 被用于分组路由，开发者可以声明不限数量的分组。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app := iris.New()</span><br><span class="line"></span><br><span class="line">users := app.Party(<span class="string">&quot;/users&quot;</span>, myAuthMiddlewareHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:8080/users/42/profile</span></span><br><span class="line">users.Get(<span class="string">&quot;/&#123;id:int&#125;/profile&quot;</span>, userProfileHandler)</span><br><span class="line"><span class="comment">// http://localhost:8080/users/messages/1</span></span><br><span class="line">users.Get(<span class="string">&quot;/messages/&#123;id:int&#125;&quot;</span>, userMessageHandler)</span><br></pre></td></tr></table></figure><h1 id="Context机制"><a href="#Context机制" class="headerlink" title="Context机制"></a>Context机制</h1><p><strong>上下文是服务器用于所有客户端的中间人“对象”</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文是服务器用于所有客户端的中间人 &quot;对象&quot;。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 对于每一个新的连接，会从 sync.Pool 中获取一个新上下文对象。</span></span><br><span class="line"><span class="comment">// 上下文是 iris 的 http 流中最重要的部分。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 开发者发送响应到客户端的请求通过一个上下文。</span></span><br><span class="line"><span class="comment">// 开发者获取请求信息从客户端的请求上下文中。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// context 是 context.Context 子包的一个实现。</span></span><br><span class="line"><span class="comment">// context.Context 是很好扩展，所以开发者可以按照实际所需重写它的方法。</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ResponseWriter 如期返回一个兼容 http.ResponseWriter 的 响应writer。</span></span><br><span class="line">    ResponseWriter() ResponseWriter</span><br><span class="line">    <span class="comment">// ResetResponseWriter 应该改变或者升级上下文的 ResponseWriter。</span></span><br><span class="line">    ResetResponseWriter(ResponseWriter)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request 方法如期返回原始的 *http.Request。</span></span><br><span class="line">    Request() *http.Request</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SetCurrentRouteName 方法设置内部路由名称，为了当开发者调用</span></span><br><span class="line">    <span class="comment">// `GetCurrentRoute()` 方法的时候能够正确返回当前 「只读」 路由。</span></span><br><span class="line">    <span class="comment">// 它使用 Router 初始化，如果你手动更改了名称，除了当你是使用`GetCurrentRoute()` </span></span><br><span class="line">    <span class="comment">// 的时候将获取到其他路由，其它没啥变化。</span></span><br><span class="line">    <span class="comment">// 为了从上下文中执行一个不同的路径，你应该使用 `Exec` 函数，</span></span><br><span class="line">    <span class="comment">// 或者通过 `SetHandlers/AddHandler` 函数改变处理方法。</span></span><br><span class="line"></span><br><span class="line">    SetCurrentRouteName(currentRouteName <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// GetCurrentRoute 返回当前注册到当前请求路径的 「只读」路由。</span></span><br><span class="line">    GetCurrentRoute() RouteReadOnly</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddHandler 可以在服务时添加处理方法到当前请求，但是这些处理方法不会持久化到路由。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// Router 将会调用这些添加到某个路由的处理方法。如果 AddHandler 被调用，</span></span><br><span class="line">    <span class="comment">// 那么处理方法将被添加到已经定义的路由的处理方法的后面。</span></span><br><span class="line">    AddHandler(...Handler)</span><br><span class="line">    <span class="comment">// SetHandlers 替换所有原有的处理方法。</span></span><br><span class="line">    SetHandlers(Handlers)</span><br><span class="line">    <span class="comment">// Handlers 记录当前的处理方法。</span></span><br><span class="line">    Handlers() Handlers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HandlerIndex 设置当前上下文处理方法链中当前索引。</span></span><br><span class="line">    <span class="comment">// 如果传入 -1 ，不会当前索引。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 也可以查看 Handlers(), Next() and StopExecution()。</span></span><br><span class="line">    HandlerIndex(n <span class="type">int</span>) (currentIndex <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// HandlerName 返回当前路由名称，方便调试。</span></span><br><span class="line">    HandlerName() <span class="type">string</span></span><br><span class="line">    <span class="comment">// Next 调用从处理方法链中选择剩下的进行调用，他应该被用于一个中间件中。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 提醒：自定义的上下文应该重写这个方法，以便能够传入他自己的 context.Context 实现。</span></span><br><span class="line">    Next()</span><br><span class="line">    <span class="comment">// NextHandler 从处理链中返回下一个处理方法(但不执行)。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 为了执行下一个 ，可以使用 .Skip() 跳过某个处理方法。</span></span><br><span class="line">    NextHandler() Handler</span><br><span class="line">    <span class="comment">// Skip 从处理链中 忽略/跳过 下一个处理方法。</span></span><br><span class="line">    <span class="comment">// 它应该在中间件内使用。</span></span><br><span class="line">    Skip()</span><br><span class="line">    <span class="comment">// 如果调用了 StopExecution ，接下来的 .Next 调用将被局略。</span></span><br><span class="line">    StopExecution()</span><br><span class="line">    <span class="comment">// IsStopped 检查当前位置的Context是否是255, 如果是, 则返回true, 意味着 StopExecution() 被调用了。</span></span><br><span class="line">    IsStopped() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 当前的 &quot;user/request&quot; 存储                                    |</span></span><br><span class="line">    <span class="comment">//  | 处理方法之间共享信息 - Values().                                  |</span></span><br><span class="line">    <span class="comment">//  | 保存并获取路径参数 - Params()                                    |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Params 返回当前URL中的命名参数。命名的路径参数是被保存在这里的。</span></span><br><span class="line">    <span class="comment">// 这个存储对象随着整个上下文，存活于每个请求声明周期。</span></span><br><span class="line">    Params() *RequestParams</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values 返回当前 「用户」的存储信息。</span></span><br><span class="line">    <span class="comment">// 命名路径参数和任何可选数据可以保存在这里。</span></span><br><span class="line">    <span class="comment">// 这个存储对象，也是存在于整个上下文，每个请求的声明周期中。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 你可以用这个函数设置和获取用于在处理方法和中间件之间共享信息的局部值。</span></span><br><span class="line">    Values() *memstore.Store</span><br><span class="line">    <span class="comment">// Translate 是 i18n 函数，用于本地化。它调用 Get(&quot;translate&quot;) 返回翻译值。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/miscellaneous/i18n</span></span><br><span class="line">    Translate(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 路径, 主机, 子域名, IP, HTTP 头 等                            |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method 返回 request.Method， 客户端的请求方法。</span></span><br><span class="line">    Method() <span class="type">string</span></span><br><span class="line">    <span class="comment">// Path 返回完整请求路径，如果 EnablePathEscape 为 True，将会转义。</span></span><br><span class="line">    Path() <span class="type">string</span></span><br><span class="line">    <span class="comment">// RequestPath 返回转义过的请求完整路径。</span></span><br><span class="line">    RequestPath(escape <span class="type">bool</span>) <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host 返回当前URL的主机部分。</span></span><br><span class="line">    Host() <span class="type">string</span></span><br><span class="line">    <span class="comment">// Subdomain 返回当前请求的子域名，如果有。</span></span><br><span class="line">    <span class="comment">// 提醒，这个方法可能在某些情况下不能正常使用。</span></span><br><span class="line">    Subdomain() (subdomain <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// RemoteAddr 尝试解析并返回客户端正式IP。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 基于允许的头名称，可以通过 Configuration.RemoteAddrHeaders  修改。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果基于这些请求头的解析失败，将会 Request 的 `RemoteAddr` 字段，它在 Http 处理方法之前有 server 填充。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 查看 `Configuration.RemoteAddrHeaders`,</span></span><br><span class="line">    <span class="comment">//      `Configuration.WithRemoteAddrHeader(...)`,</span></span><br><span class="line">    <span class="comment">//      `Configuration.WithoutRemoteAddrHeader(...)` 获取更多信息。</span></span><br><span class="line">    RemoteAddr() <span class="type">string</span></span><br><span class="line">    <span class="comment">// GetHeader 返回指定的请求头值。</span></span><br><span class="line">    GetHeader(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// IsAjax 返回这个请求是否是一个 &#x27;ajax request&#x27;( XMLHttpRequest)。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 不能百分之百确定一个请求是否是Ajax模式。</span></span><br><span class="line">    <span class="comment">// 永远不要信任来自客户端的数据，他们很容易被篡改。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 提醒，&quot;X-Requested-With&quot; 头可以被任何客户端修改，对于十分严重的情况，不要依赖于 IsAjax。</span></span><br><span class="line">    <span class="comment">// 试试另外的鉴别方式，例如，内容类型（content-type）。</span></span><br><span class="line">    <span class="comment">// 有很多描述这些问题的博客并且提供了很多不同的解决方案，这就是为什么说 `IsAjax` </span></span><br><span class="line">    <span class="comment">// 太简单，只能用于一般目的。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 更多请看： https://developer.mozilla.org/en-US/docs/AJAX</span></span><br><span class="line">    <span class="comment">// 以及： https://xhr.spec.whatwg.org/</span></span><br><span class="line">    IsAjax() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 响应头助手                                                   |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Header 添加响应头到响应 writer。</span></span><br><span class="line">    Header(name <span class="type">string</span>, value <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContentType 设置响应头 &quot;Content-Type&quot; 为 &#x27;cType&#x27;。</span></span><br><span class="line">    ContentType(cType <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// GetContentType 返回响应头 &quot;Content-Type&quot; 的值。</span></span><br><span class="line">    GetContentType() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// StatusCode 设置响应状态码。</span></span><br><span class="line">    <span class="comment">// 也可查看 .GetStatusCode。</span></span><br><span class="line">    StatusCode(statusCode <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// GetStatusCode 返回当前响应的状态码。</span></span><br><span class="line">    <span class="comment">// 也可查阅 StatusCode。</span></span><br><span class="line">    GetStatusCode() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redirect 发送一个重定向响应到客户端，接受两个参数，字符串和可选的证书。</span></span><br><span class="line">    <span class="comment">// 第一个参数是重定向的URL，第二个是重定向状态码，默认是302。</span></span><br><span class="line">    <span class="comment">// 如果必要，你可以设置为301，代表永久转义。</span></span><br><span class="line">    Redirect(urlToRedirect <span class="type">string</span>, statusHeader ...<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 各种请求和 POST 数据                                         |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// URLParam 返回请求中的参数，如果有。</span></span><br><span class="line">    URLParam(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// URLParamInt 从请求返回 int 类型的URL参数，如果解析失败，返回错误。</span></span><br><span class="line">    URLParamInt(name <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// URLParamInt64 从请求返回 int64 类型的参数，如果解析失败，返回错误。</span></span><br><span class="line">    URLParamInt64(name <span class="type">string</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// URLParams 返回请求查询参数映射，如果没有，返回为空。</span></span><br><span class="line">    URLParams() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FormValue 返回一个表单值。</span></span><br><span class="line">    FormValue(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// FormValues 从 data，get，post 和 查询参数中返回所有的数据值以及他们的键。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 提醒: 检查是否是 nil 是很有必要的。</span></span><br><span class="line">    FormValues() <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br><span class="line">    <span class="comment">// PostValue 仅仅根据名称返回表单的post值，类似于 Request.PostFormValue。</span></span><br><span class="line">    PostValue(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// FormFile 返回键指定的第一个文件。</span></span><br><span class="line">    <span class="comment">// 如果有必要，FormFile 调用 ctx.Request.ParseMultipartForm 和 ParseForm。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 类似于 Request.FormFile.</span></span><br><span class="line">    FormFile(key <span class="type">string</span>) (multipart.File, *multipart.FileHeader, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 自定义 HTTP 错误                                             |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NotFound 发送一个 404 错误到客户端，使用自定义的错误处理方法。</span></span><br><span class="line">    <span class="comment">// 如果你不想剩下的处理方法被执行，你可能需要去调用 ctx.StopExecution()。</span></span><br><span class="line">    <span class="comment">// 你可以将错误码改成更具体的，例如：</span></span><br><span class="line">    <span class="comment">// users := app.Party(&quot;/users&quot;)</span></span><br><span class="line">    <span class="comment">// users.Done(func(ctx context.Context)&#123; if ctx.StatusCode() == 400 &#123; /*  custom error code for /users */ &#125;&#125;)</span></span><br><span class="line">    NotFound()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | Body Readers                                               |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SetMaxRequestBodySize 设置请求体大小的上限，应该在读取请求体之前调用。</span></span><br><span class="line">    SetMaxRequestBodySize(limitOverBytes <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UnmarshalBody 读取请求体，并把它绑定到一个任何类型或者指针的值。</span></span><br><span class="line">    <span class="comment">// 使用实例: context.ReadJSON, context.ReadXML。</span></span><br><span class="line">    UnmarshalBody(v <span class="keyword">interface</span>&#123;&#125;, unmarshaler Unmarshaler) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ReadJSON 从请求体读取 JSON，并把它绑定到任何json有效类型的值。</span></span><br><span class="line">    ReadJSON(jsonObject <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ReadXML 从请求体读取 XML，并把它绑定到任何xml有效类型的值。</span></span><br><span class="line">    ReadXML(xmlObject <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ReadForm 是用表单数据绑定 formObject，支持任何类型的结构体。</span></span><br><span class="line">    ReadForm(formObject <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | Body (raw) Writers                                         |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write 将数据作为一个HTTP响应的一部分写入连接。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 如果 WriteHeader 还没有调用，Write 将在 写入数据之前调用 WriteHeader(http.StatusOK)。</span></span><br><span class="line">    <span class="comment">// 如果 Header 没有 Content-Type，Write 添加一个 Content-Type，设置为写入数据的前</span></span><br><span class="line">    <span class="comment">// 512 字节的类型。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 取决于 HTTP 版本和客户端，调用 Write 或者 WriteHeader 可能组织以后读取 Request.Body。</span></span><br><span class="line">    <span class="comment">// 对于 HTTP/1.x 请求，处理方法应该在写入响应之前读取所有必要的请求体数据。一旦 HTTP 头被清掉</span></span><br><span class="line">    <span class="comment">// (显示调用 Flusher.Flush 或者写入了足够的数据触发了清空操作)，请求体可能变得不可用。</span></span><br><span class="line">    <span class="comment">// 对于 HTTP/2 请求，Go HTTP 服务器允许在写入响应的同时读取请求体。然而，这种行为可能不被所有</span></span><br><span class="line">    <span class="comment">// HTTP/2 客户端支持。处理方法应该尽可能读取最大量的数据在写入之前。</span></span><br><span class="line">    Write(body []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Writef 根据格式声明器格式化，然后写入响应。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回写入的字节数量以及任何写入错误。</span></span><br><span class="line">    Writef(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// WriteString 将一个简单的字符串写入响应。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回写入的字节数量以及任何写入错误。</span></span><br><span class="line">    WriteString(body <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// WriteWithExpiration 很像 Write，但是它发送了一个失效时间，它会被每个包级别的</span></span><br><span class="line">    <span class="comment">// `StaticCacheDuration` 字段刷新。</span></span><br><span class="line">    WriteWithExpiration(body []<span class="type">byte</span>, modtime time.Time) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// StreamWriter 注册给定的流用于发布响应体。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这个函数可能被用于一下这些情况：</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">//     * 如果响应体太大（超过了iris.LimitRequestBodySize）</span></span><br><span class="line">    <span class="comment">//     * 如果响应体是慢慢从外部资源流入</span></span><br><span class="line">    <span class="comment">//     * 如果响应体必须分片流向客户端（例如 `http server push`）</span></span><br><span class="line">    StreamWriter(writer <span class="function"><span class="keyword">func</span><span class="params">(w io.Writer)</span></span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 带压缩的 Body Writers                            |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">// 如果客户端支持 gzip 压缩，ClientSupportsGzip 返回 true。</span></span><br><span class="line">    ClientSupportsGzip() <span class="type">bool</span></span><br><span class="line">    <span class="comment">// WriteGzip accepts bytes, which are compressed to gzip format and sent to the client.</span></span><br><span class="line">    <span class="comment">// WriteGzip 接受压缩成 gzip 格式的字节然后发送给客户端，并返回写入的字节数量和错误（如果错误不支持 gzip 格式）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。</span></span><br><span class="line">    WriteGzip(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// TryWriteGzip 接受 gzip 格式压缩的字节，然后发送给客户端。</span></span><br><span class="line">    <span class="comment">// 如果客户端不支持 gzip，就按照他们原来未压缩的样子写入。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。</span></span><br><span class="line">    TryWriteGzip(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// GzipResponseWriter converts the current response writer into a response writer</span></span><br><span class="line">    <span class="comment">// GzipResponseWriter 将当前的响应 writer 转化为一个 gzip 响应 writer。</span></span><br><span class="line">    <span class="comment">// 当它的 .Write 方法被调用的时候，数据被压缩成 gzip 格式然后把他们写入客户端。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 也可以使用 .Disable 禁用以及使用 .ResetBody 回滚到常规的响应写入器。</span></span><br><span class="line">    GzipResponseWriter() *GzipResponseWriter</span><br><span class="line">    <span class="comment">// Gzip 开启或者禁用 gzip 响应写入器，如果客户端支持 gzip 压缩，所以接下来的响应数据将被作为</span></span><br><span class="line">    <span class="comment">// 压缩的 gzip 数据发送给客户端。</span></span><br><span class="line">    Gzip(enable <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 富文本内容渲染器                                              |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewLayout 设置 「布局」选项，如果随后在相同的请求中 .View 被调用。</span></span><br><span class="line">    <span class="comment">// 当需要去改变或者设置处理链中前一个方法的布局时很有用。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 注意 &#x27;layoutTmplFile&#x27; 参数可以被设置为 iris.NoLayout 或者 view.NoLayout 去禁用某个试图渲染动作的布局。</span></span><br><span class="line">    <span class="comment">// 它禁用了配置项的布局属性。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 也可查看 .ViewData 和 .View。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/</span></span><br><span class="line">    ViewLayout(layoutTmplFile <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewData 保存一个或者多个键值对为了在后续的 .View 被调用的时候使用。</span></span><br><span class="line">    <span class="comment">// 当需要处理链中前一个处理器的模板数据的时候是很有用的。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果 .View 的绑定参数不是 nil 也不是 map 类型，这些数据就会被忽略，绑定是有优先级的，所以住路由的处理方法仍然有效。</span></span><br><span class="line">    <span class="comment">// 如果绑定是一个map或者context.Map，这些数据然后就被添加到视图数据然后传递给模板。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// .View 调用之后，这些数据不会被丢掉，为了在必要的时候重用（再次声明，同一个请求中），为了清除这些数据，开发者可以调用</span></span><br><span class="line">    <span class="comment">// ctx.Set(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey(), nil)。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 如果 &#x27;key&#x27; 是空的，然后 值被作为它的（struct 或者 map）添加，并且开发者不能添加其他值。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 推荐查看 .ViewLayout 和 .View。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/</span></span><br><span class="line">    ViewData(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetViewData 返回 `context#ViewData` 注册的值。</span></span><br><span class="line">    <span class="comment">// 返回值是 `map[string]interface&#123;&#125;` 类型，这意味着如果一个自定义的结构体被添加到 ViewData， 这个函数将把它解析成</span></span><br><span class="line">    <span class="comment">// map，如果失败返回 nil。</span></span><br><span class="line">    <span class="comment">// 如果不同类型的值或者没有数据通过 `ViewData` 注册，检查是否为nil总是好的编程规范。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 类似于 `viewData := ctx.Values().Get(&quot;iris.viewData&quot;)` 或者 </span></span><br><span class="line">    <span class="comment">// `viewData := ctx.Values().Get(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey())`。</span></span><br><span class="line">    GetViewData() <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// View 基于适配的视图引擎渲染模板。第一个参数是接受相对于视图引擎目录的文件名，</span></span><br><span class="line">    <span class="comment">// 例如如果目录是 &quot;./templates&quot;，想要渲染： &quot;./templates/users/index.html&quot;</span></span><br><span class="line">    <span class="comment">// 你应该传递 &quot;users/index.html&quot; 作为文件名参数。</span></span><br><span class="line">    <span class="comment">// 也可以查看 .ViewData 和 .ViewLayout。</span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/view/</span></span><br><span class="line">    View(filename <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary 将原生字节作为二进制数据返回。</span></span><br><span class="line">    Binary(data []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Text 将字符串作为空白文本返回。</span></span><br><span class="line">    Text(text <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// HTML 将字符串作为 text/html 返回.</span></span><br><span class="line">    HTML(htmlContents <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// JSON 格式化给定的数据并且返回 json 数据。</span></span><br><span class="line">    JSON(v <span class="keyword">interface</span>&#123;&#125;, options ...JSON) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// JSONP 格式化给定的数据并且返回 json 数据。</span></span><br><span class="line">    JSONP(v <span class="keyword">interface</span>&#123;&#125;, options ...JSONP) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// XML 格式话给定数据，并返回 XML 数据。</span></span><br><span class="line">    XML(v <span class="keyword">interface</span>&#123;&#125;, options ...XML) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Markdown 解析 markdown 数据为 HTML 返回给客户端。</span></span><br><span class="line">    Markdown(markdownB []<span class="type">byte</span>, options ...Markdown) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 文件响应                                                     |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServeContent 返回的内容头是自动设置的，接受三个参数，它是一个低级的函数，你可以调用 .ServeFile(string,bool)/SendFile(string,string)。</span></span><br><span class="line">    <span class="comment">// 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，不要实现 resuming，而应该使用 ctx.SendFile。</span></span><br><span class="line">    ServeContent(content io.ReadSeeker, filename <span class="type">string</span>, modtime time.Time, gzipCompression <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ServeFile 渲染一个视图文件，如果要发送一个文件（例如zip文件）到客户端，你应该使用 SendFile(serverfilename,clientfilename)。</span></span><br><span class="line">    <span class="comment">// 接受两个参数：</span></span><br><span class="line">    <span class="comment">// filename/path (string)</span></span><br><span class="line">    <span class="comment">// gzipCompression (bool)</span></span><br><span class="line">    <span class="comment">// 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，这个函数没有实现 resuming，你应该使用 ctx.SendFile。</span></span><br><span class="line">    ServeFile(filename <span class="type">string</span>, gzipCompression <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">    <span class="comment">// SendFile 发送强制下载的文件到客户端</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 使用这个而不是 ServeFile 用于大文件下载到客户端。</span></span><br><span class="line">    SendFile(filename <span class="type">string</span>, destinationName <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | Cookies                                                    |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SetCookie 添加cookie</span></span><br><span class="line">    SetCookie(cookie *http.Cookie)</span><br><span class="line">    <span class="comment">// SetCookieKV 添加一个 cookie，仅仅接受一个名字（字符串）和一个值（字符串）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果你用这个方法设置cookie，它将在两小时之后失效。</span></span><br><span class="line">    <span class="comment">// 如果你想去设置或者改变更多字段，使用 ctx.SetCookie 或者 http.SetCookie。</span></span><br><span class="line">    SetCookieKV(name, value <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// GetCookie 通过名称返回值，如果没找到返回空字符串。</span></span><br><span class="line">    GetCookie(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// RemoveCookie 通过名字删除 cookie。</span></span><br><span class="line">    RemoveCookie(name <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// VisitAllCookies 接受一个 visitor 循环每个cookie，visitor 接受两个参数：名称和值。</span></span><br><span class="line">    VisitAllCookies(visitor <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, value <span class="type">string</span>)</span></span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxAge 返回 &quot;cache-control&quot; 请求头的值，单位为：秒，类型为 int64</span></span><br><span class="line">    <span class="comment">// 如果头没有发现或者解析失败返回 -1。</span></span><br><span class="line">    MaxAge() <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 高级部分: 响应记录器和事务                                     |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record 转化上下文基本的 responseWriter 为 ResponseRecorder，它可以被用于在任何时候重置内容体，</span></span><br><span class="line">    <span class="comment">// 重置响应头，获取内容体，获取和设置状态码。</span></span><br><span class="line">    Record()</span><br><span class="line">    <span class="comment">// Recorder 返回上下文的 ResponseRecorder，如果没有 recording 然后它将开始记录并返回新的上下文的 ResponseRecorder。</span></span><br><span class="line">    Recorder() *ResponseRecorder</span><br><span class="line">    <span class="comment">// IsRecording 返回响应记录器以及一个bool值</span></span><br><span class="line">    <span class="comment">// true 表示响应记录器正在记录状态码，内容体，HTTP 头以及更多，否则就是 false</span></span><br><span class="line">    IsRecording() (*ResponseRecorder, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeginTransaction 开启一个有界事务。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 你可以搜索第三方文章或者查看事务 Transaction 如何工作（这里相当简单特别）。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 记着这个是唯一的，也是新的，目前为止，我没有在这个项目中看到任何例子和代码，就大多数 iris 功能而言。</span></span><br><span class="line">    <span class="comment">// 它没有覆盖所有路径，例如数据库，这个应该由你使用的创建数据库连接的库管理，这个事务域仅仅用于上下文响应，</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 阅读 https://github.com/kataras/iris/tree/master/_examples/ 查看更多。</span></span><br><span class="line">    BeginTransaction(pipe <span class="function"><span class="keyword">func</span><span class="params">(t *Transaction)</span></span>)</span><br><span class="line">    <span class="comment">// 如果调用 SkipTransactions 将跳过剩余的事务，或者如果在第一个事务之前调用，将跳过所有</span></span><br><span class="line">    SkipTransactions()</span><br><span class="line">    <span class="comment">// TransactionsSkipped 返回事务到底被跳过还是被取消了。</span></span><br><span class="line">    TransactionsSkipped() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec根据这个上下文调用framewrok的ServeCtx，但是改变了方法和路径，就像用户请求的那样，但事实并非如此。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 离线意味着路线已注册到 iris 并具有正常路由所具有的所有功能。</span></span><br><span class="line">    <span class="comment">// 但是它不能通过浏览获得，它的处理程序仅在其他处理程序的上下文调用它们时执行，它可以验证路径，拥有会话，路径参数等。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 你可以通过 app.GetRoute(&quot;theRouteName&quot;) 找到路由，你可以设置一个路由名称如：</span></span><br><span class="line">    <span class="comment">// myRoute := app.Get(&quot;/mypath&quot;, handler)(&quot;theRouteName&quot;)</span></span><br><span class="line">    <span class="comment">// 这个将给路由设置一个名称并且返回它的 RouteInfo 实例为了进一步使用。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 它不会更改全局状态，如果路由处于“脱机”状态，它将保持脱机状态。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// app.None(...) and app.GetRoutes().Offline(route)/.Online(route, method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 实例：https://github.com/kataras/iris/tree/master/_examples/routing/route-state</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 用户可以通过简单调用得到响应：rec := ctx.Recorder(); rec.Body()/rec.StatusCode()/rec.Header()</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Context 的 Values 和 Session 被记住为了能够通过结果路由通信，</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 它仅仅由于特别案例，99% 的用户不会用到的。</span></span><br><span class="line">    Exec(method <span class="type">string</span>, path <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Application 返回 属于这个上下文的 iris 实例。</span></span><br><span class="line">    <span class="comment">// 值得留意的是这个函数返回 Application 的一个接口，它包含的方法能够安全地在运行是执行。</span></span><br><span class="line">    <span class="comment">// 为了开发者的安全性，整个 app 的 字段和方法这里是不可用的。</span></span><br><span class="line">    Application() Application</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:并发</title>
      <link href="/2023/04/07/go-%E5%B9%B6%E5%8F%91/"/>
      <url>/2023/04/07/go-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该代码的运行结果不唯一，因为是两个goroutine在执行</span></span><br></pre></td></tr></table></figure><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>通道是用来传递数据的数据结构</p><p>通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于制定通道的方向，如果未指定方向，则为双向通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v<span class="comment">// 把v发送到ch</span></span><br><span class="line">v := &lt;-ch<span class="comment">// 从ch接收数据</span></span><br><span class="line"><span class="comment">// 并把值赋给v</span></span><br><span class="line"><span class="comment">// 声明一个通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p><strong>默认情况下，通道是不带缓冲区的。</strong></p><h2 id="带缓冲区的通道"><a href="#带缓冲区的通道" class="headerlink" title="带缓冲区的通道"></a>带缓冲区的通道</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><p>Go通过range关键字来实现遍历读取到的数据，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;- ch</span><br></pre></td></tr></table></figure><h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2><p>如果通道接收不到数据后ok就为false，这时通道就可以使用close函数来关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:方法与接口</title>
      <link href="/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="7-1-接口的定义"><a href="#7-1-接口的定义" class="headerlink" title="7.1 接口的定义"></a>7.1 接口的定义</h1><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。</p><p>Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab *itab;</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="7-2-接口使用实例"><a href="#7-2-接口使用实例" class="headerlink" title="7.2 接口使用实例"></a>7.2 接口使用实例</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;<span class="comment">// 定义了一个接口Phone, 有方法call()</span></span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;<span class="comment">// 接口Phone的一个实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;<span class="comment">// 接口Phone的一个实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone<span class="comment">// 利用接口实现多态</span></span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:数据</title>
      <link href="/2023/04/05/go-%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/05/go-%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-字符串string"><a href="#5-1-字符串string" class="headerlink" title="5.1 字符串string"></a>5.1 字符串string</h1><p><strong>字符串是不可变字符序列</strong></p><p><strong>默认值为空串，而不是空指针。</strong></p><p><strong>遍历</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&#x27;Hello, world&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// byte</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rune</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;%d ,[%c]\n&quot;</span>, i, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="5-2-数组"><a href="#5-2-数组" class="headerlink" title="5.2 数组"></a>5.2 数组</h1><h2 id="5-2-1-数组的初始化"><a href="#5-2-1-数组的初始化" class="headerlink" title="5.2.1 数组的初始化"></a>5.2.1 数组的初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">4</span>]<span class="type">int</span><span class="comment">// 元素自动初始成0</span></span><br><span class="line">    b := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">5</span>&#125;<span class="comment">// 剩余元素自动初始化成0</span></span><br><span class="line">    c := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">3</span>:<span class="number">10</span>&#125;;<span class="comment">// 指定索引位置</span></span><br><span class="line">    d := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">// 编译器确定数组长度</span></span><br><span class="line">    <span class="comment">// 在定义多维数组时， 仅第一维允许使用...</span></span><br><span class="line">    b := [...][<span class="number">2</span>]<span class="type">int</span> &#123;</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>&#125;, </span><br><span class="line">        &#123;<span class="number">30</span> ,<span class="number">40</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-2-指针"><a href="#5-2-2-指针" class="headerlink" title="5.2.2 指针"></a>5.2.2 指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">10</span> ,<span class="number">20</span></span><br><span class="line">    a := [...]*<span class="type">int</span>&#123;&amp;x, &amp;y&#125;<span class="comment">//指针数组</span></span><br><span class="line">    p = &amp;a<span class="comment">//数组指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-3-复制"><a href="#5-2-3-复制" class="headerlink" title="5.2.3 复制"></a>5.2.3 复制</h2><p><strong>与C数组变量隐式作为指针使用不同， Go数组是值类型，赋值和传参工作都会复制整个数组数据</strong></p><h1 id="5-3-切片"><a href="#5-3-切片" class="headerlink" title="5.3 切片"></a>5.3 切片</h1><p><strong>slice本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="keyword">type</span> slice strcut &#123;</span><br><span class="line">    arrary unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span><span class="comment">//限定可读的写元素数量</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span><span class="comment">// 切片所引用数组片段的真实长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切片本身是一个只读对象， 其工作机制类似数组指针的一种包装</strong></p><h2 id="5-3-1-创建切片对象"><a href="#5-3-1-创建切片对象" class="headerlink" title="5.3.1 创建切片对象"></a>5.3.1 创建切片对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)<span class="comment">//指定len, cap, 底层数组初始化成零值 </span></span><br><span class="line">    s2 := <span class="built_in">make</span>([<span class="type">int</span>], <span class="number">3</span>)<span class="comment">// 省略cap, 和len相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片是包装过的数组对象，用来代替数组减少值传递带来的开销</p><h1 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: <span class="number">1</span>, </span><br><span class="line">        <span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断key是否存在</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := m[<span class="string">&quot;d&quot;</span>]; ok &#123;</span><br><span class="line">        <span class="built_in">println</span>(v)</span><br><span class="line">    &#125;<span class="comment">// 访问不存在的键值， 默认返回零值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.虚拟内存</title>
      <link href="/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><strong>虚拟存储器</strong>：</p><p>三个能力：</p><ol><li>将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li><li>为每个进程提供了一致的地址空间，从而简化了存储管理。</li><li>保护了每个进程的地址空间不被其他进程破坏。</li></ol><span id="more"></span><h2 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h2><p>CPU—(VA)–&gt;MMU—-&gt;PA—–&gt;Memory</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.异常控制流</title>
      <link href="/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>CSAPP关于异常处理的章节。</p><span id="more"></span><h1 id="8-4进程控制"><a href="#8-4进程控制" class="headerlink" title="8.4进程控制"></a>8.4进程控制</h1><h2 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取进程的pid</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 获取进程父进程的pid</span></span><br></pre></td></tr></table></figure><h2 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">exit函数以status退出状态来终止进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父进程通过调用fork函数创建一个新的运行的子进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：子进程返回0，父进程返回子进程的PID，如果出错，返回-1.</span></span><br></pre></td></tr></table></figure><p>fork被调用一次，却会返回两次：父进程返回子进程的PID，子进程返回0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        prinf(<span class="string">&quot;child: x = %d\n&quot;</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prinf(<span class="string">&quot;parent: x = %d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">parent: x = 0</span></span><br><span class="line"><span class="comment">child: x = 2</span></span><br><span class="line"><span class="comment">or </span></span><br><span class="line"><span class="comment">child: x = 2</span></span><br><span class="line"><span class="comment">parent: x = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h2><p>如果一个父进程终止，内核会安排init进程成为他的孤儿进程的养父</p><h2 id="8-4-6"><a href="#8-4-6" class="headerlink" title="8.4.6"></a>8.4.6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个简单的shell的main例程 */</span></span><br><span class="line"><span class="comment">/*shellex.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128</span></span><br><span class="line"><span class="comment">/* Function protoytpes */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span>* buf, <span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];<span class="comment">// Command line</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Evaluate a commmand line*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS];</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> bg;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">// Ignore empty line</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Parent waits for foreground job to terminate</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If first arg is a builtin command, run it and return true*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* parseline - Parse the command line and build the argv array*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span>* buf, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* delim;<span class="comment">// points to the first space delimiter</span></span><br><span class="line">    <span class="type">int</span> argc;<span class="comment">// number of args</span></span><br><span class="line">    <span class="type">int</span> bg;</span><br><span class="line">    </span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        buf ++;</span><br><span class="line">    <span class="comment">/* build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (delm = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>) ) ) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">            buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h1><p><strong>Linux信号: 软件形式的异常</strong></p><h2 id="8-5-1-信号的术语"><a href="#8-5-1-信号的术语" class="headerlink" title="8.5.1 信号的术语"></a>8.5.1 信号的术语</h2><p>发送信号到用户进程的步骤：</p><ul><li><p>发送信号。 方式： 更新进程上下文的状态。 发送信号的原因： 1. 监测到异常、2进程调用了kill。</p></li><li><p>接收信号。进程接收信号并将信号转移给信号处理程序。</p></li></ul><h2 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h2><h3 id="1-进程组"><a href="#1-进程组" class="headerlink" title="1. 进程组"></a>1. 进程组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">pid <span class="title function_">getgrp</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 返回进程的进程组id</span></span><br><span class="line"><span class="comment">// 子进程与父进程的进程组id默认相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;<span class="comment">// 改变进程的进程组id</span></span><br></pre></td></tr></table></figure><h3 id="2-用-x2F-bin-x2F-kill程序发送信号"><a href="#2-用-x2F-bin-x2F-kill程序发送信号" class="headerlink" title="2. 用&#x2F;bin&#x2F;kill程序发送信号"></a>2. 用&#x2F;bin&#x2F;kill程序发送信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; /bin/kill <span class="number">-9</span> <span class="number">15213</span></span><br><span class="line"><span class="comment">// 发送信号SIGKILL给pid为15213的进程</span></span><br><span class="line">linux&gt; /bin/kill <span class="number">-9</span> <span class="number">-15213</span></span><br><span class="line"><span class="comment">// 发送信号SIGKILL给pgid为15213下的所有进程</span></span><br></pre></td></tr></table></figure><h3 id="3-从键盘发送信号"><a href="#3-从键盘发送信号" class="headerlink" title="3.从键盘发送信号"></a>3.从键盘发送信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + C <span class="comment">// 终止前台作业</span></span><br><span class="line">Ctrl + C <span class="comment">// 挂起前台作业</span></span><br></pre></td></tr></table></figure><h3 id="4-用kill函数发送信号"><a href="#4-用kill函数发送信号" class="headerlink" title="4. 用kill函数发送信号"></a>4. 用kill函数发送信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
