<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go-内置数据结构的实现原理</title>
      <link href="/2024/04/19/go-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2024/04/19/go-%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p><strong>每个切片都指向一个底层数组</strong></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/slice.go:slice</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span> </span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="使用数组创建slice"><a href="#使用数组创建slice" class="headerlink" title="使用数组创建slice"></a>使用数组创建slice</h3><p>使用数组创建slice时，slice将与原数组共用一部分内存。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>扩容的本质：重新分配内存(len &gt; cap时)，拷贝数据，追加数据。</p><ol><li>cap &lt; 1024, cap &#x3D; 2 * cap</li><li>cap &gt; 1024, cap &#x3D; 1.25 cap</li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Go语言的map基于Hash表实现。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapInitByMake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">   m[<span class="string">&quot;banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s-%d\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapCRUD</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span> (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>)</span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="string">&quot;red&quot;</span><span class="comment">// append</span></span><br><span class="line">    m[<span class="string">&quot;apple&quot;</span>] = <span class="string">&quot;green&quot;</span> <span class="comment">// alter</span></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;apple&quot;</span>)<span class="comment">// delete</span></span><br><span class="line">    v, exist := m[<span class="string">&quot;apple&quot;</span>]<span class="comment">// query</span></span><br><span class="line">    <span class="keyword">if</span> exist &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;apple-%s\n&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素使用内置函数delete完成</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>map的数据结构</li></ol><p>一个Hash表中可以有多个bucket，每个bucket保存了map中的一个或多个键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/map.go:hmap</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count<span class="type">int</span> <span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    B<span class="type">uint8</span><span class="comment">// bucket数组的大小</span></span><br><span class="line">    bucketsunsafe.Pointer<span class="comment">// bucket数组, 2^B</span></span><br><span class="line">    oldbuckets unsafe.Pointer<span class="comment">// 旧bucket数组,用于扩容</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>bucket的数据结构</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/map.go:bmap</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    data []<span class="type">byte</span></span><br><span class="line">    overflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个bucket可以存储8个键值对</p><ul><li>tophash是一个长度为8的整型数组，Hash值低位相同的键存入当前bucket时会将Hash值的高位存储在该数组中，以便后续匹配。</li></ul><h2 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h2><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ul><li>负载因子大于6.5</li><li>overflow &gt; 2^15</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>oldbuckets指向原buckets数组</li><li>申请新buckets &#x3D; 2 * buckets</li><li>更新buckets指针</li><li>迁移数组</li><li>释放oldbuckets</li></ol><h2 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li><p>根据key计算hash值</p></li><li><p>hash低位 % hmap.B</p></li><li><p>取hash值高位，在tophash数组中查询</p></li><li><p>若tophash[i] &#x3D;&#x3D; key.hash，则获取tophash[i]的key值进行比较</p></li><li><p>当前bucket中没有找到，则依次从溢出的bucket中查找</p></li></ol><h1 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h1><h2 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h2><h3 id="Tag的本质"><a href="#Tag的本质" class="headerlink" title="Tag的本质"></a>Tag的本质</h3><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><blockquote><p>特点：string使用8比特字节的集合来存储字符，存储的是字符的UTF-8编码。在使用for-range遍历时,index可能不连续</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringIteration</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;中国&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index: %d, value: %c\n&quot;</span>, i, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 0, 中</span></span><br><span class="line"><span class="comment">// 3, 国</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>string转[]byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToByte</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := []<span class="type">byte</span>&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">    s := <span class="type">string</span>(b)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[]byte转string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ByteToString</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    b := []<span class="type">byte</span>(s)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/string.go:stringStruct</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer<span class="comment">// 首地址</span></span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span><span class="comment">// 长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B-Test-Environment</title>
      <link href="/2024/04/17/B-Test-Environment/"/>
      <url>/2024/04/17/B-Test-Environment/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于学校要求的软件版本与较新版本的Win10, Win11有冲突，导致在配置环境过程中可能会出很多问题，eNSP模拟器的AR201路由器无法正常工作，下文尽量给出了解决方案</p><h1 id="Windows硬件虚拟化技术"><a href="#Windows硬件虚拟化技术" class="headerlink" title="Windows硬件虚拟化技术"></a>Windows硬件虚拟化技术</h1><h2 id="开启硬件虚拟化"><a href="#开启硬件虚拟化" class="headerlink" title="开启硬件虚拟化"></a>开启硬件虚拟化</h2><p>解释：启动硬件虚拟化使得VirtualBox可以模拟硬件</p><p><a href="https://forum.huawei.com/enterprise/zh/thread/593224413229236224">参考文章</a>:具体过程如下：</p><p>1、电脑开机时，按F1,F2或F12或DEL或ESC等键进入BIOS，不同电脑进入BIOS的按键有一定不同。</p><p>2、进入BIOS后，找到Configuration选项并打开。</p><p>3、选择Intel Virtual Technology并回车。</p><p>4、将光标移至Enabled，然后再回车。</p><p>5、按F10保存并退出即可。</p><h2 id="关闭Hyper-V"><a href="#关闭Hyper-V" class="headerlink" title="关闭Hyper-V"></a>关闭Hyper-V</h2><p>解释：Hyper-V是微软提供的虚拟化技术，可能与VirtualBox的方案冲突。</p><p><a href="https://blog.csdn.net/Dontla/article/details/134564070">参考文章</a>具体过程如下：</p><p>Win+X, 点击以管理员权限启动Windows PowerShell,输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off</span><br></pre></td></tr></table></figure><p>从而关闭Hyper-V支持。</p><h1 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h1><p><a href="https://blog.csdn.net/weixin_43113691/article/details/124847964">参考文章</a></p><p>有些文件的版本号与参考文章不同</p><h2 id="WinPcap下载"><a href="#WinPcap下载" class="headerlink" title="WinPcap下载"></a>WinPcap下载</h2><p><a href="https://cloud.rsecc.cn/softlink/WinPcap_4_1_3.exe">下载地址</a></p><p>版本号：WinPcap_4_1_3</p><p>安装选项均为默认。</p><h2 id="Wireshark下载"><a href="#Wireshark下载" class="headerlink" title="Wireshark下载"></a>Wireshark下载</h2><p><a href="https://cloud.rsecc.cn/softlink/Wireshark-win64-3.0.6.exe">下载地址</a></p><p>版本号：Wireshark-win64-3.0.6</p><p>安装选项均为默认。</p><h2 id="VirtualBox下载"><a href="#VirtualBox下载" class="headerlink" title="VirtualBox下载"></a>VirtualBox下载</h2><p><a href="https://download.virtualbox.org/virtualbox/5.2.44/VirtualBox-5.2.44-139111-Win.exe">下载地址</a></p><p>版本号: 5.2.44 </p><p>5.2.44 版本是 VirtualBox 5.2 系列的最后一个维护更新，较为稳定，兼容性好，更高版本可能与学校要求的eNSP版本不兼容。</p><p>安装选项均为默认</p><h2 id="eNSP下载"><a href="#eNSP下载" class="headerlink" title="eNSP下载"></a>eNSP下载</h2><p><a href="https://cloud.rsecc.cn/softlink/eNSP%20V100R003C00SPC100%20Setup.exe">下载地址</a></p><p>版本号：V100R003C00SPC100</p><p>安装选项均为默认。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="如何重装VirtualBox"><a href="#如何重装VirtualBox" class="headerlink" title="如何重装VirtualBox"></a>如何重装VirtualBox</h2><p><a href="https://blog.csdn.net/AD_00001/article/details/135150460">参考文章</a></p><p>VirtualBox重装时卸载不干净会引发一些问题，因此重装时要注意彻底卸载</p><ol><li>控制面板卸载程序。</li><li>注册表管理器卸载相关注册表文件。</li><li>使用everything，删除与VirtualBox有关的文件夹。</li></ol><h2 id="依然出现40报错"><a href="#依然出现40报错" class="headerlink" title="依然出现40报错"></a>依然出现40报错</h2><p><a href="https://forum.huawei.com/enterprise/zh/thread/593224413229236224">参考文章</a></p><p>可能的解决方案：删除AR设备，重新注册AR_Base。</p><h2 id="关闭Windows防火墙"><a href="#关闭Windows防火墙" class="headerlink" title="关闭Windows防火墙"></a>关闭Windows防火墙</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bustub总结帖</title>
      <link href="/2024/03/27/bustub%E6%80%BB%E7%BB%93%E5%B8%96/"/>
      <url>/2024/03/27/bustub%E6%80%BB%E7%BB%93%E5%B8%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Buffer-Manager"><a href="#Buffer-Manager" class="headerlink" title="Buffer Manager"></a>Buffer Manager</h1><h2 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h2><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h1><p><img src="/bustub%E6%80%BB%E7%BB%93%E5%B8%96/image-20240328110407102.png" alt="image-20240328110407102"></p><h2 id="B-Tree-node"><a href="#B-Tree-node" class="headerlink" title="B+Tree node"></a>B+Tree node</h2><h3 id="base-page"><a href="#base-page" class="headerlink" title="base page"></a>base page</h3><p><img src="/bustub%E6%80%BB%E7%BB%93%E5%B8%96/image-20240327163206884.png" alt="image-20240327163206884"></p><h3 id="leaf-page"><a href="#leaf-page" class="headerlink" title="leaf page"></a>leaf page</h3><p><img src="/bustub%E6%80%BB%E7%BB%93%E5%B8%96/image-20240327173308284.png" alt="image-20240327173308284"></p><h3 id="internal-page"><a href="#internal-page" class="headerlink" title="internal page"></a>internal page</h3><p><img src="/bustub%E6%80%BB%E7%BB%93%E5%B8%96/image-20240327173909865.png" alt="image-20240327173909865"></p>]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xv6总结帖</title>
      <link href="/2024/03/20/xv6%E6%80%BB%E7%BB%93%E5%B8%96/"/>
      <url>/2024/03/20/xv6%E6%80%BB%E7%BB%93%E5%B8%96/</url>
      
        <content type="html"><![CDATA[<h1 id="XV6是怎么运行的"><a href="#XV6是怎么运行的" class="headerlink" title="XV6是怎么运行的"></a>XV6是怎么运行的</h1><p>在真实的物理环境中。涉及到从硬件加电或重置到操作系统完全接管控制的过程。</p><p>这个过程大概分为以下几个步骤：</p><ol><li>引导加载程序。 BIOS初始化硬件，找到设备，执行硬盘引导扇区的初始化代码。</li><li>引导加载程序加载内核。 引导加载程序读取磁盘上的内核映像到内存中，并跳转到内核的入口点开始执行。</li><li>内核初始化。设置中断描述符表，建立虚拟内存。在xv6中，这部分逻辑开始于<code>main</code>函数，该函数定义在<code>kernel/main.c</code>中。</li><li>启动进程。 创世纪进程<code>init</code></li></ol><h2 id="kernel-x2F-main-c"><a href="#kernel-x2F-main-c" class="headerlink" title="kernel&#x2F;main.c"></a>kernel&#x2F;main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123; <span class="comment">// 这个条件判断确保只有一个CPU（通常是CPU 0）执行以下的初始化任务，因为在多核系统中，所有的CPU核心几乎同时启动，但系统初始化只需执行一次。</span></span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode table</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    started = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>printf是如何执行的：简单来说，将待输出字符转换成字符流，写入内存缓冲区，调用驱动输出到控制台(或指定的输出设备、文件)</p></blockquote><h3 id="物理内存的初始化"><a href="#物理内存的初始化" class="headerlink" title="物理内存的初始化"></a>物理内存的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这部分代码中，从内存的下界到内存的上界，调用kfree函数释放内存页，使其可以被重新分配和使用。</p><h3 id="内核页表初始化"><a href="#内核页表初始化" class="headerlink" title="内核页表初始化"></a>内核页表初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kvmmap</code>函数在xv6操作系统中用于在内核的页表中添加一个新的虚拟地址到物理地址的映射。</p><ul><li><strong>pagetable_t kpgtbl</strong>: 这是一个页表的指针，指向当前的内核页表。在xv6中，页表用于存储虚拟地址到物理地址的映射信息。</li><li><strong>uint64 va</strong>: 虚拟地址（Virtual Address），这是要添加映射的虚拟内存地址。</li><li><strong>uint64 pa</strong>: 物理地址（Physical Address），这是va参数所指定的虚拟地址对应的物理内存地址。</li><li><strong>uint64 sz</strong>: 映射区域的大小，单位是字节。这个参数指定了从<code>va</code>开始，需要映射多大的内存区域到物理地址<code>pa</code>。</li><li><strong>int perm</strong>: 映射的权限设置，这些权限包括读（PTE_R）、写（PTE_W）和执行（PTE_X）。权限参数决定了CPU如何访问映射的内存区域，例如，一个只读的内存区域会阻止写入操作。</li></ul><p>内核页表初始化的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make a direct-map page table for the kernel.</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers UART（通用异步接收器/发送器，一种常用的串行通信设备）</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface virtio磁盘接口（一种I/O虚拟化框架）的MMIO（Memory-Mapped I/O）</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC 平台级中断控制器（PLIC）</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// map kernel text executable and read-only. 内核的可执行文本</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of. 内核数据及其后的物理内存区域</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to 中断入口/出口的trampoline代码映射了一个页面，它位于内核的最高虚拟地址。</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel stacks</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程表初始化"><a href="#进程表初始化" class="headerlink" title="进程表初始化"></a>进程表初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  initlock(&amp;wait_lock, <span class="string">&quot;wait_lock&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">      p-&gt;kstack = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为每个进程分配一个锁和一个栈。</p><h3 id="初始化中断设置"><a href="#初始化中断设置" class="headerlink" title="初始化中断设置"></a>初始化中断设置</h3><p>设置中断向量和中断处理程序</p><h3 id="初始化文件系统"><a href="#初始化文件系统" class="headerlink" title="初始化文件系统"></a>初始化文件系统</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="meta"># inode kernel/fs.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; itable;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  initlock(&amp;itable.lock, <span class="string">&quot;itable&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NINODE; i++) &#123;</span><br><span class="line">    initsleeplock(&amp;itable.inode[i].lock, <span class="string">&quot;inode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inode表中有一个锁和一个inode列表，初始化inode表为每个节点分配一个锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># kernel/file.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;</span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br><span class="line">-----------------------</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[<span class="title">NDEV</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;ftable.lock, <span class="string">&quot;ftable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于inode表，分配锁。</p><h3 id="创建第一个用户进程"><a href="#创建第一个用户进程" class="headerlink" title="创建第一个用户进程"></a>创建第一个用户进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>设置进程的初始内存映射</li><li>设置进程的初始大小</li><li>准备从内核返回到用户空间</li></ol><h1 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h1><h2 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># user/uthread.c</span></span><br><span class="line"><span class="comment">/* Possible states of a thread: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE 0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUNNING 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUNNABLE 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 8192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_THREAD 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span> state;              <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">all_thread</span>[<span class="title">MAX_THREAD</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">current_thread</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">thread_switch</span><span class="params">(uint64, uint64)</span>;</span><br></pre></td></tr></table></figure><p>包括线程状态，线程的结构体，线程组，当前线程，线程切换。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>设置<code>current_thread</code>为第一个线程。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>遍历所有线程，寻找一个状态为<code>RUNNABLE</code>的线程作为<code>next_thread</code>，然后通过调用<code>thread_switch</code>函数来切换到这个线程执行。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在<code>all_thread</code>数组中找到一个状态为<code>FREE</code>的线程结构，然后将其状态设置为<code>RUNNABLE</code>，并初始化它的栈和执行函数。</p><h3 id="让出CPU"><a href="#让出CPU" class="headerlink" title="让出CPU"></a>让出CPU</h3><p>这个函数允许当前线程主动放弃CPU，将自己的状态设置为<code>RUNNABLE</code>并调用<code>thread_schedule</code>来重新调度。</p><h2 id="线程编程"><a href="#线程编程" class="headerlink" title="线程编程"></a>线程编程</h2><ol><li>参考kernel&#x2F;switch.S代码，完成用户态线程切换汇编代码</li><li>给thread结构体添加context</li><li>线程创建时，为context,stack分配内存，state设置成runable</li><li>线程切换，调用汇编程序</li></ol><h3 id="解决哈希表的race"><a href="#解决哈希表的race" class="headerlink" title="解决哈希表的race"></a>解决哈希表的race</h3><p>多线程情况下存在race condition。改善这个hashtable.</p><p>为每个<strong>bucket</strong>配置一个<strong>pthread_mutex</strong>锁来保证只有一个线程可以读这个<strong>bucket</strong>里的所有数据进行读和写的操作即可.</p><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><p>每个线程都会呼叫<strong>barrier()<strong>函数, 将会卡在里面直到每个需要synchronize的线程都进入这个函数. 需要使用</strong>conditional variable</strong>来实现等待和唤醒的功能.</p><h1 id="networking"><a href="#networking" class="headerlink" title="networking"></a>networking</h1><h2 id="transmit"><a href="#transmit" class="headerlink" title="transmit"></a>transmit</h2><p><strong>e1000_transmit</strong>是给了一个新的<strong>packet</strong>, 我们需要在ring里找到下一个空余位置, 然后把它放进去等待传输.</p><h2 id="recieve"><a href="#recieve" class="headerlink" title="recieve"></a>recieve</h2><p><strong>e1000_recv</strong>是需要遍历这个ring, 把所有新到来的<strong>packet</strong>交由网络上层的协议&#x2F;应用去处理.</p><h1 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h1><h2 id="memory-allocator"><a href="#memory-allocator" class="headerlink" title="memory allocator"></a>memory allocator</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(name, <span class="number">8</span>, <span class="string">&quot;kmem-%d&quot;</span>, i);</span><br><span class="line">    initlock(&amp;kmem[i].lock, name);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为每一个<strong>cpu</strong>核维系一个freelist空闲内存页链表, 只有在本核的内存不够时, 才试图去偷取别的核的内存.</p><h2 id="buffer-cache"><a href="#buffer-cache" class="headerlink" title="buffer cache"></a>buffer cache</h2><p>这个实验其实和上一个<strong>memory allocator</strong>很类似, 主打一个”回收利用”的思想. <strong>xv6</strong>会缓存一些经常使用的<strong>block</strong>块在内存里(即这个<strong>buffer cache pool</strong>), 使得每次重复调用这个<strong>block</strong>块时直接从<strong>内存</strong>读取, 而不用做<strong>磁盘I&#x2F;O</strong>.</p><p>原始版本的<strong>buffer cache</strong>由一个大锁<strong>bcache.lock</strong>保护, 限制了并行运行的效率. 我们要把它拆解为更精细的锁管理, 用hash bucket的思想. 并且放弃双链表的管理方式, 直接使用<strong>ticks</strong>时间戳来实现<strong>LRU</strong>(least-recently-used)算法.</p><h1 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h1><h2 id="large-files"><a href="#large-files" class="headerlink" title="large files"></a>large files</h2><p><img src="/xv6%E6%80%BB%E7%BB%93%E5%B8%96/v2-fd9e7485a86ee7c0f7726c88100e274b_720w.webp" alt="img"></p><p>双层映射，取余数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bn &lt; NINDIRECT2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">  bp = bread(ip-&gt;dev, addr);</span><br><span class="line">  a = (uint *)bp-&gt;data;</span><br><span class="line">  <span class="keyword">if</span> ((addr = a[bn / NINDIRECT]) == <span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 之后的每一个映射可以吃下NINDIRECT个blocks</span></span><br><span class="line">    a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the 2nd indirect block, allocating if necessary</span></span><br><span class="line">  bp2 = bread(ip-&gt;dev, addr);</span><br><span class="line">  b = (uint *)bp2-&gt;data;</span><br><span class="line">  <span class="keyword">if</span> ((addr = b[bn % NINDIRECT]) == <span class="number">0</span>)</span><br><span class="line">  &#123; <span class="comment">// 取余数</span></span><br><span class="line">    b[bn % NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bp2);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp2);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>设置inode的type为T_SYMLINK，在data里记录target的path。</p><p>打开一个软链接类型的文件时，需要递归寻址，设置最大递归深度以防止陷入死循环。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java框架</title>
      <link href="/2024/02/02/Java%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/02/02/Java%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="/Java%E6%A1%86%E6%9E%B6/image-20240202160101109.png" alt="image-20240202160101109"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="IoC控制反转"><a href="#IoC控制反转" class="headerlink" title="IoC控制反转"></a>IoC控制反转</h3><p>为了解决耦合度偏高的问题，在使用对象时，程序中不要主动使用new产生对象，转换成由外部提供对象。</p><p><img src="/Java%E6%A1%86%E6%9E%B6/v2-005b53a7d400a5c21314ae58cbd606b7_720w.png" alt="img"></p><h3 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h3 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h3><p>作用：在不惊动原始设计的基础上为其进行功能增强</p><p>Spring思想：无侵入式编程</p><p><img src="/Java%E6%A1%86%E6%9E%B6/image-20240215214517977.png" alt="image-20240215214517977"></p><p><img src="/Java%E6%A1%86%E6%9E%B6/image-20240215214900105.png" alt="image-20240215214900105"></p><p><img src="/Java%E6%A1%86%E6%9E%B6/image-20240216194828172.png" alt="image-20240216194828172"></p><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2024/01/18/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/01/18/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment">*<span class="doctag">@Author</span></span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240119111129169.png" alt="image-20240119111129169"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240126222847781.png" alt="image-20240126222847781"></p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240126222900923.png" alt="image-20240126222900923"></p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包机制用于区别命名空间</p><h2 id="Java-Doc"><a href="#Java-Doc" class="headerlink" title="Java Doc"></a>Java Doc</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@author</span> 作者名</span><br><span class="line"><span class="meta">@version</span> 版本号</span><br><span class="line"><span class="meta">@since</span> 最早jdk版本</span><br><span class="line"><span class="meta">@param</span> 参数名</span><br><span class="line"><span class="meta">@return</span> 返回值情况</span><br><span class="line"><span class="meta">@throws</span> 异常抛出情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p>next和nextline的区别</p><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240127175646898.png" alt="image-20240127175646898"></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>名字相同，参数列表不同</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>一个类会有默认的构造器。</p><p>构造器：</p><ol><li>函数名与类名相同</li><li>没有返回值</li></ol><p>Java里有有参构造和无参构造两种构造器</p><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240127221537017.png" alt="image-20240127221537017"></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>暴露少量方法给外部使用</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extends关键字</p><p>子类 is a 父类</p><p>Java中所有类都默认继承Object类</p><p>Java中只有单继承</p><p>Super关键字可以访问父类的公共变量，方法</p><p>子类的构造函数默认调用了父类的无参构造。 </p><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240129151412553.png" alt="image-20240129151412553"></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>判断对象A是否是类B的一个实例</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240129180104621.png" alt="image-20240129180104621"></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>普通类只有具体实现，抽象类具体实现和规范都有，接口只有规范，自己无法写方法</p><p>Java可以利用接口实现多继承。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240129231738374.png" alt="image-20240129231738374"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// try监控区域</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 捕捉异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 善后工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240129233418869.png" alt="image-20240129233418869"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>作用：加载class文件~ </p><p>new的过程：</p><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240130003809897.png" alt="image-20240130003809897"></p><ol><li>虚拟机自带的加载器</li><li>启动类加载器</li><li>扩展类加载器</li><li>应用程序类加载器</li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心是沙箱，沙箱是限制程序运行的环境。</p><p>沙箱机制就是将Java代码限定在JVM的运行范围中，限制对系统资源的访问。</p><p>Java将执行程序分为本地代码和远程代码两种，本地代码默认视为可信任的。 远程代码看做是不可信的。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h1 id="Javaweb"><a href="#Javaweb" class="headerlink" title="Javaweb"></a>Javaweb</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240130005303636.png" alt="image-20240130005303636"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>自动导入配置jar包，架构管理工具。</p><p>Maven核心思想：约定大于配置。</p><ul><li>有约束，不要去违反</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>动态web技术</p><p>步骤：</p><ol><li>编写一个类，实现Servlet接口</li><li>把开发好的JAVA类部署到web服务器中</li></ol><p><img src="/Java%E5%9F%BA%E7%A1%80/image-20240202003611694.png" alt="image-20240202003611694"></p><h3 id="Servlet-Context"><a href="#Servlet-Context" class="headerlink" title="Servlet Context"></a>Servlet Context</h3><p>Web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p><ul><li><p>共享数据</p></li><li><p>获取初始化参数</p></li><li><p>请求转发</p></li><li><p>读取资源文件</p></li></ul><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><ol><li>要下载文件的路径</li><li>下载的文件名</li><li>获取下载文件的输入流</li><li>创建缓冲区</li><li>获取OutputStream对象</li><li>将FileOutputStream流写入到buffer缓冲区</li><li>使用OutputStream将缓冲区中的数据输出到客户端</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2023/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><p> 知道属性a -&gt; 推导出属性b</p><h2 id="Armstrong’s-Axioms"><a href="#Armstrong’s-Axioms" class="headerlink" title="Armstrong’s Axioms"></a>Armstrong’s Axioms</h2><p><img src="/2023/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231114221017332.png" alt="image-20231114221017332"></p><h2 id="Implications"><a href="#Implications" class="headerlink" title="Implications"></a>Implications</h2><p><img src="/2023/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231114221158204.png" alt="image-20231114221158204"></p><h1 id="Closure-of-FDs"><a href="#Closure-of-FDs" class="headerlink" title="Closure of FDs"></a>Closure of FDs</h1><h1 id="正则覆盖"><a href="#正则覆盖" class="headerlink" title="正则覆盖"></a>正则覆盖</h1><p>函数依赖集F能推出函数依赖集G。</p><h2 id="Minimal-Cover"><a href="#Minimal-Cover" class="headerlink" title="Minimal Cover"></a>Minimal Cover</h2><h1 id="Candidate-Key"><a href="#Candidate-Key" class="headerlink" title="Candidate Key"></a>Candidate Key</h1><ol><li>决定性： K -&gt; R</li><li>K中的每个属性都不可或缺</li></ol><p><strong>主属性</strong>:出现在候选码中的属性</p><h2 id="Algorithm-to-compute-Candidate-Key"><a href="#Algorithm-to-compute-Candidate-Key" class="headerlink" title="Algorithm to compute Candidate Key"></a>Algorithm to compute Candidate Key</h2><p><img src="/2023/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/image-20231115102842208.png" alt="image-20231115102842208"></p><h1 id="Normalization-Based-on-FD"><a href="#Normalization-Based-on-FD" class="headerlink" title="Normalization Based on FD"></a>Normalization Based on FD</h1><h2 id="Normal-Forms-–-1NF"><a href="#Normal-Forms-–-1NF" class="headerlink" title="Normal Forms – 1NF"></a>Normal Forms – 1NF</h2><p><strong>Concepts</strong>:A relational schema R is in first normal form if the domains of all attributes of R are atomic.</p><p>原子性：</p><ol><li>不能有组合属性如：customer(id, name(first-name,middle-initial,last-name),date-of-birth)</li><li>一个tuple每个属性只能有一个值，如电话的值不能为(18637047510,13781481432)这样的列表形式</li><li>每个属性都是独立的值，不能从中提取信息。如学号可以得到入学年份，但我们认为学号是一个独&#96;立的值</li></ol><h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h2><p>不存在非主属性部分依赖于候选码</p><h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><p>不存在非主属性对码的传递依赖</p><h2 id="BCNF-Boyce-Codd-Normal-Form"><a href="#BCNF-Boyce-Codd-Normal-Form" class="headerlink" title="BCNF Boyce-Codd Normal Form"></a>BCNF Boyce-Codd Normal Form</h2><p>if $\alpha \rightarrow \beta$ then $\alpha$ is a superkey for R</p><h1 id="基于多值依赖的规范化"><a href="#基于多值依赖的规范化" class="headerlink" title="基于多值依赖的规范化"></a>基于多值依赖的规范化</h1><h2 id="Multi-Valued-Depedency"><a href="#Multi-Valued-Depedency" class="headerlink" title="Multi-Valued Depedency"></a>Multi-Valued Depedency</h2><h1 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h1><p>把一个关系分成多个关系模式</p><ol><li>分过之后的关系模式必须是之前的关系模式的真子集</li><li>分解后的属性集并起来等于原属性集</li></ol><h2 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h2><p>分解后的通过自然连接能够还原成原关系模式</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2023/11/29/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/11/29/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h1><h2 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性 Atomicity"></a>原子性 Atomicity</h2><p>一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p><h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 Consistency"></a>一致性 Consistency</h2><p>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</p><h2 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性 Isolation"></a>隔离性 Isolation</h2><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</p><h2 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性 Durability"></a>持久性 Durability</h2><p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h1 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h1><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>如果一个事务读到了另一个未提交事务修改过的数据，就意味着发生了脏读。</p><p><img src="/image-20231029155726297.png" alt="image-20231029155726297"></p><p>因为事务A还没提交事务，所以随时可能发生rollback，这样B读到的数据就是过期的数据，这种现象被称为脏读。</p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>在一个事务中多次读取同一个数据，如果前后两次得到的结果不一样，就意味着发生了不可重复读现象。</p><p><img src="/image-20231029160004590.png" alt="image-20231029160004590"></p><p>A事务的持续时间比B长，B提交事务后A又读到了数据，前后结果不一致。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>在一个事务内多次查询某个符合条件的记录数量，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象。</p><p><img src="/image-20231029160310737.png" alt="image-20231029160310737"></p><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><ul><li>读未提交 read uncommitted 一个事务未提交时，它做的变更就能被其他事务看到；</li><li>读提交 read committed 一个事务提交之后，他做的变更才能被其他事务看到；</li><li>可重复读 repeatable 一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的；</li><li>串行化 serializable 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p><p><img src="/image-20231029160756260.png" alt="image-20231029160756260"></p><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><h2 id="Transaction-State"><a href="#Transaction-State" class="headerlink" title="Transaction State"></a>Transaction State</h2><ul><li>Active 初始状态；事务执行的时候处于这个状态</li><li>Partially committed 最终状态执行后</li><li>Failed 发生异常之后</li><li>Aborted 回滚，数据库将该状态存储在事务的开始。抛出异常后可以选择重启事务或者停止事务</li><li>Committed  成功结束后</li><li>Terminated 要么提交要么抛出异常</li></ul><p><img src="/image-20231121112001543.png" alt="image-20231121112001543"></p><p><img src="/image-20231121112017030.png" alt="image-20231121112017030"></p><h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><p><img src="/image-20231121113611323.png" alt="image-20231121113611323"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/2023/11/29/%E6%97%A5%E5%BF%97/"/>
      <url>/2023/11/29/%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log 回滚日志"></a>undo log 回滚日志</h1><p>Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。</p><p>undo log是一种用于撤销回退的日志。在事务没提交前，MySQL会先记录更新前的数据到undo log日志文件里面，当事务回滚时，可以利用undo log 来进行回滚。 如下图：</p><img src="/image-20231030104531461.png" alt="image-20231030104531461" style="zoom:67%;" /><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul><p>版本链如下图：</p><img src="/image-20231030105445664.png" alt="image-20231030105445664" style="zoom: 67%;" /><p>另外， undo log 还有一个作用，通过ReadView + undo log 实现 MVCC （多版本并发控制）</p><p>undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><h1 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log 重做日志"></a>redo log 重做日志</h1><p>Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复。</p><p>Buffer Pool 是基于内存的，而内存总是不可靠。</p><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p>过程如下图：</p><img src="/image-20231030110842998.png" alt="image-20231030110842998" style="zoom: 67%;" /><h2 id="redo-log什么时候刷盘"><a href="#redo-log什么时候刷盘" class="headerlink" title="redo log什么时候刷盘"></a>redo log什么时候刷盘</h2><p>主要有下面几个 timing:</p><ul><li>MySQL 正常关闭时；</li><li>redo log buffer中记录的写入量大于redo log buffer内存空间的一半时，会触发落盘</li><li>InnoDB 的后台进程每隔1s，将redo log buffer 持久化到磁盘</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li></ul><h1 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog 归档日志"></a>binlog 归档日志</h1><p>是Server层生成的日志，主要用于数据备份和主从复制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethereum安全分析工具</title>
      <link href="/2023/09/18/Ethereum%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/09/18/Ethereum%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Mythril"><a href="#Mythril" class="headerlink" title="Mythril"></a>Mythril</h2><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通过 <code>myth -h</code>命令可以查看Mythril的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; myth -h</span><br><span class="line">usage: myth [-h] [-v LOG_LEVEL]</span><br><span class="line">            &#123;safe-functions,analyze,a,disassemble,d,foundry,f,list-detectors,read-storage,function-to-hash,hash-to-address,version,<span class="built_in">help</span>&#125; ...</span><br><span class="line"></span><br><span class="line">Security analysis of Ethereum smart contracts</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;safe-functions,analyze,a,disassemble,d,foundry,f,list-detectors,read-storage,function-to-hash,hash-to-address,version,<span class="built_in">help</span>&#125;</span><br><span class="line">                        Commands</span><br><span class="line">    safe-functions      Check <span class="built_in">functions</span> <span class="built_in">which</span> are completely safe using symbolic execution</span><br><span class="line">    analyze (a)         Triggers the analysis of the smart contract <span class="comment"># 分析智能合约</span></span><br><span class="line">    disassemble (d)     Disassembles the smart contract <span class="comment"># 拆解合约，返回合约对应的字节码</span></span><br><span class="line">    foundry (f)         Triggers the analysis of the smart contract</span><br><span class="line">    list-detectors      Lists available detection modules <span class="comment"># 列出可用的安全检测模型</span></span><br><span class="line">    read-storage        Retrieves storage slots from a given address through rpc</span><br><span class="line">    function-to-hash    Returns the <span class="built_in">hash</span> signature of the <span class="keyword">function</span></span><br><span class="line">    hash-to-address     converts the hashes <span class="keyword">in</span> the blockchain to ethereum address</span><br><span class="line">    version             Outputs the version</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -v LOG_LEVEL          <span class="built_in">log</span> level (0-5)</span><br></pre></td></tr></table></figure><h3 id="Slither"><a href="#Slither" class="headerlink" title="Slither"></a>Slither</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Slither 是用python 3编写的智能合约静态分析框架提供如下功能：</p><ul><li>自动化漏洞检测。</li><li>自动优化检测。</li><li>代码理解。绘制合约的继承拓扑图，合约方法调用关系图，帮助开发者理解代码。</li><li>辅助代码审查。</li></ul><h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol><li>合约源码经过solc编译后得到 AST 作为 Slither 的输入。</li><li>通过 information recovery， Slither 生成合约的继承图，控制流图(CFG)以及合约中函数列表。</li><li>经过SlithID转换，将合约代码转换成SlithIR,目的是通过简单的API实现高精度分析，支持污点和值的跟踪，从而支持检测复杂的模型。</li><li>在代码分析阶段，Slither运行一组预定义的分析，包括合约中变量、函数的依赖关系；变量的读写和函数的权限控制。</li><li>在代码分析阶段，Slither运行一组预定义的分析，包括合约中变量、函数的依赖关系；变量的读写和函数的权限控制。</li></ol><p><img src="/v2-d1f9722506f3fab11d8c510be7a9e1eb_r.jpg" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC</title>
      <link href="/2023/08/20/gRPC/"/>
      <url>/2023/08/20/gRPC/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RPC(Remote Procedure Call, 远程过程调用).是一种协议,用来屏蔽分布式计算当中的各种调用细节,使得可以像是本地调用一样直接调用一个远程函数.</p><p>gRPC是一个高性能的开源的RPC框架.</p><p>通过某种方式描述一个服务,这种描述方式是语言无关的.在这个”服务定义”的过程中,我们描述了我们提供的服务名是什么,有哪些方法可以被调用,这些方法以什么样的方式入参,有什么的回参.</p><p>定义好服务之后,gRPC会屏蔽底层的细节,client只需要直接调用定义好的方法,就能拿到预期的结果.server端还需要实现定义的方法.</p><blockquote><p>Protocol Buffss</p><p>这是谷歌开源的一套成熟的数据结构序列化机制</p><p>这个工具可以把我们定义的方法,转换成特定语言的代码.在发送请求和接收响应时,这个工具还会完成对应的编码和解码工作.</p></blockquote><p><img src="/landing-2.svg"></p><h1 id="proto文件"><a href="#proto文件" class="headerlink" title="proto文件"></a>proto文件</h1><blockquote><p>message</p></blockquote><p>需要传输的数据格式的定义</p><blockquote><p>字段规则</p></blockquote><p>required: </p><p>optional:</p><p>repeated:</p><blockquote><p>消息号</p></blockquote><p>每个字段都必须要有一个唯一的标识号[1, 2^29-1]</p><blockquote><p>服务</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line"># <span class="function"><span class="keyword">rpc</span> 服务函数名 (参数) 返回 (返回参数)</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Search(SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="服务端编写"><a href="#服务端编写" class="headerlink" title="服务端编写"></a>服务端编写</h1><ul><li>创建gRPC Server对象</li><li>将server注册到gRPC Server的内部注册中心</li><li>创建Listen, 监听TCP端口</li><li>gRPC Server 开始lis.Accept, 直到Stop</li></ul><h1 id="客户端编写"><a href="#客户端编写" class="headerlink" title="客户端编写"></a>客户端编写</h1><ul><li>创建与给定目标的连接交互</li><li>创建server的客户端对象</li><li>发送RPC请求,等待同步响应,得到回调后返回响应结果</li><li>输出响应结果</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Web </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethereum</title>
      <link href="/2023/08/17/Ethereum/"/>
      <url>/2023/08/17/Ethereum/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>新一代比特币,实现了去中心化的合约.</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="EVM"><a href="#EVM" class="headerlink" title="EVM"></a>EVM</h3><p>以太坊虚拟机是一个全局虚拟计算机，以太坊网络中的每个参与者都会存储并一致同意其状态。 任何参与者都可以请求在以太坊虚拟机上执行任意代码；代码执行会改变以太坊虚拟机的状态。</p><h3 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h3><p>存储以太坊虚拟机状态的实体计算机。节点间相互通信，传播关于以太坊状态的信息及其新的状态变化。 任何用户还可以通过广播来自节点的代码执行请求来请求代码执行。 以太坊网络本身就是所有以太坊节点及其通信的集合。</p><h3 id="帐户"><a href="#帐户" class="headerlink" title="帐户"></a>帐户</h3><p>帐户是存储以太币之处。 用户可以初始化帐户，将以太币存入帐户，并将自己帐户中的以太币转账给其他用户。 帐户和帐户余额存储在以太坊虚拟机中的一个大表格中，是以太坊虚拟机总体状态的一部分。</p><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>“交易请求”是表示以太坊虚拟机上的代码执行请求的正式术语。“交易”是指已完成的交易请求和相关的以太坊虚拟机状态变化。 任何用户都可以从节点向网络广播交易请求。 为了使交易请求影响一致同意的以太坊虚拟机状态，就必须由其他节点对其进行验证、执行并“提交到网络”。 执行任何代码都会导致以太坊虚拟机状态变化；一旦提交后，该状态变化将广播到网络中的所有节点。</p><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>交易量巨大，因此交易分批或分区块“提交”。 区块通常包含数十至数百笔交易。</p><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>应用开发者将程序上传到以太坊虚拟机状态，用户发出请求以使用不同参数执行这些代码片段。我们将这些上传至网络并由网络执行的程序称为智能合约。</p><h2 id="ETH"><a href="#ETH" class="headerlink" title="ETH"></a>ETH</h2><h3 id="铸造"><a href="#铸造" class="headerlink" title="铸造"></a>铸造</h3><p>创造新以太币的过程。</p><p>奖励提议的每个区块和在每个时段的检查点奖励验证者执行和达成共识的其他活动。</p><p>总发行量取决于验证者的数量和它们质押的以太币数量。</p><h3 id="燃烧"><a href="#燃烧" class="headerlink" title="燃烧"></a>燃烧</h3><p>当 ETH 被燃烧掉，它也就永久退出流通。</p><h3 id="面额"><a href="#面额" class="headerlink" title="面额"></a>面额</h3><table><thead><tr><th>面额</th><th>ETH值</th><th>常见用法</th></tr></thead><tbody><tr><td>Wei</td><td>10^{-18}</td><td>技术实现</td></tr><tr><td>Gwei</td><td>10^{-9}</td><td>可读gas费用</td></tr></tbody></table><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>以太坊上的每笔交易都包含一个 <code>value</code> 字段，指定从发送者地址发送到接收者地址的以太币转账金额（以 Wei 为单位）。</p><p>当接收者地址是<a href="https://ethereum.org/zh/developers/docs/smart-contracts/">智能合约</a>时，在智能合约执行其代码后，这些转账的以太币可用于支付燃料费用。</p><h2 id="DAPP"><a href="#DAPP" class="headerlink" title="DAPP"></a>DAPP</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>后端代码运行在一个去中心化的P2P网络上。</p><ul><li><strong>去中心化</strong> dapp在以太坊上运行，这是一个开放的公共去中心化平台，没有任何一个人或团体可以控制</li><li><strong>确定性</strong> 无论执行的环境如何，都执行相同的功能</li><li><strong>图灵完备</strong> dapp可以根据所需资源执行任何操作</li><li><strong>隔离性</strong> 运行在EVM虚拟环境中。即使智能合约出现问题，也不会妨碍区块链网络的正常运行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC-挖矿</title>
      <link href="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/"/>
      <url>/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p> <img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230806181708790.png" alt="image-20230806181708790"></p><h2 id="比特币调整挖矿难度"><a href="#比特币调整挖矿难度" class="headerlink" title="比特币调整挖矿难度"></a>比特币调整挖矿难度</h2><p>H(block header) &lt;&#x3D; target</p><p>比特币使用SHA-256算法，输出值有256位，结果共有2^256中可能。</p><p>挖矿难度与目标阈值成反比。</p><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><h3 id="全节点"><a href="#全节点" class="headerlink" title="全节点"></a>全节点</h3><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230810143121047.png" alt="image-20230810143121047"></p><h3 id="轻节点"><a href="#轻节点" class="headerlink" title="轻节点"></a>轻节点</h3><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230810143247194.png" alt="image-20230810143247194"></p><h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230816181732178.png" alt="image-20230816181732178"></p><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;result&quot; : &#123;</span><br><span class="line">&quot;txid&quot;: &quot;021a...dd24&quot;,</span><br><span class="line">&quot;hash&quot;: &quot;021a...dd24&quot;,</span><br><span class="line">&quot;version&quot;: &quot;1&quot;,</span><br><span class="line">&quot;size&quot;: 226,</span><br><span class="line">&quot;locktime&quot;: 0,</span><br><span class="line">&quot;vin&quot;: [...],</span><br><span class="line">&quot;vout&quot;: [...],</span><br><span class="line">&quot;blockhash&quot;: &quot;000000000000002c510d...&quot;,</span><br><span class="line">&quot;confirmations&quot;: 23,</span><br><span class="line">&quot;time&quot;:1530846727,</span><br><span class="line">&quot;blocktime&quot;: 1530846727</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="交易的输入"><a href="#交易的输入" class="headerlink" title="交易的输入"></a>交易的输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;vin&quot; : [&#123;</span><br><span class="line">&quot;txid&quot;: &quot;c0cb...c57b&quot;,</span><br><span class="line">&quot;vout&quot;: 0,</span><br><span class="line">&quot;scriptSig&quot;: &#123;</span><br><span class="line">&quot;asm&quot;: &quot;3045...0018&quot;,</span><br><span class="line">&quot;hex&quot;: &quot;4830...0018&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><h4 id="交易的输出"><a href="#交易的输出" class="headerlink" title="交易的输出"></a>交易的输出</h4><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230816182723205.png" alt="image-20230816182723205"></p><h4 id="转账"><a href="#转账" class="headerlink" title="转账"></a>转账</h4><p><img src="/2023/08/06/BTC-%E6%8C%96%E7%9F%BF/image-20230816183210931.png" alt="image-20230816183210931"></p><h2 id="分叉fork"><a href="#分叉fork" class="headerlink" title="分叉fork"></a>分叉fork</h2><h3 id="state-fork"><a href="#state-fork" class="headerlink" title="state fork"></a>state fork</h3><p>对比特币当前状态有意见分析产生的分叉.</p><h3 id="soft-fork"><a href="#soft-fork" class="headerlink" title="soft fork"></a>soft fork</h3><h3 id="hard-fork"><a href="#hard-fork" class="headerlink" title="hard fork"></a>hard fork</h3><h2 id="匿名性"><a href="#匿名性" class="headerlink" title="匿名性"></a>匿名性</h2>]]></content>
      
      
      
        <tags>
            
            <tag> BlockChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BTC-协议与实现</title>
      <link href="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>虚拟货币需要解决的两个问题：</p><ol><li>谁有权发行货币。</li><li>如何验证交易的合法性。</li></ol><span id="more"></span><h3 id="Double-Spending"><a href="#Double-Spending" class="headerlink" title="Double-Spending"></a>Double-Spending</h3><p>区块链的交易存储方案如下图所示：</p><p> <img src="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230731153829071.png" alt="image-20230731153829071"></p><h3 id="Consensus-in-BitCoin"><a href="#Consensus-in-BitCoin" class="headerlink" title="Consensus in BitCoin"></a>Consensus in BitCoin</h3><h4 id="假设：只有少部分节点是恶意节点"><a href="#假设：只有少部分节点是恶意节点" class="headerlink" title="假设：只有少部分节点是恶意节点"></a>假设：只有少部分节点是恶意节点</h4><p>接受的合法区块必须在最长合法链上。</p><p><img src="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230731161551774.png" alt="image-20230731161551774"></p><p>分叉攻击：通过在区块链中间插入节点，达到回滚的效果。</p><h3 id="等长分叉"><a href="#等长分叉" class="headerlink" title="等长分叉"></a>等长分叉</h3><p>系统中两个矿工同时发布一个区块，分叉会存在一段时间，直至某条分叉胜出。</p><p><img src="/2023/07/31/BTC-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%9E%E7%8E%B0/image-20230731161833665.png" alt="image-20230731161833665"></p><p>失败的节点被称为orphan block。</p><h3 id="Bitcoin的实现"><a href="#Bitcoin的实现" class="headerlink" title="Bitcoin的实现"></a>Bitcoin的实现</h3><p>比特币中的全节点要维护UTXO的数据结构</p><h4 id="UTXO：Unspent-Transaction-Output"><a href="#UTXO：Unspent-Transaction-Output" class="headerlink" title="UTXO：Unspent Transaction Output"></a>UTXO：Unspent Transaction Output</h4><p>避免Double-Spending问题。</p><h4 id="Block-headers"><a href="#Block-headers" class="headerlink" title="Block headers"></a>Block headers</h4><p><img src="/image-20230801110417429.png" alt="image-20230801110417429"></p><h4 id="Bernoulli-trial-a-random-experiment-with-binary-outcome"><a href="#Bernoulli-trial-a-random-experiment-with-binary-outcome" class="headerlink" title="Bernoulli trial: a random experiment with binary outcome"></a>Bernoulli trial: a random experiment with binary outcome</h4><h4 id="Bernoulli-process-a-sequence-of-independent-Bernoulli-trials-memoryless"><a href="#Bernoulli-process-a-sequence-of-independent-Bernoulli-trials-memoryless" class="headerlink" title="Bernoulli process: a sequence of independent Bernoulli trials memoryless"></a>Bernoulli process: a sequence of independent Bernoulli trials memoryless</h4><h4 id="Poisson-precess-矿工挖到矿的概率"><a href="#Poisson-precess-矿工挖到矿的概率" class="headerlink" title="Poisson precess(矿工挖到矿的概率)"></a>Poisson precess(矿工挖到矿的概率)</h4><h4 id="exponential-distribution-系统挖到矿的概率"><a href="#exponential-distribution-系统挖到矿的概率" class="headerlink" title="exponential distribution(系统挖到矿的概率)"></a>exponential distribution(系统挖到矿的概率)</h4><p>出块事件服从指数分布。 </p><p>指数分布的无记忆性保证了挖矿的公平性。</p><h4 id="Bitcoin-is-secured-by-mining"><a href="#Bitcoin-is-secured-by-mining" class="headerlink" title="Bitcoin is secured by mining"></a>Bitcoin is secured by mining</h4><h4 id="six-confirmation-防范double-spending问题"><a href="#six-confirmation-防范double-spending问题" class="headerlink" title="six confirmation 防范double-spending问题"></a>six confirmation 防范double-spending问题</h4><p> <img src="/image-20230801112639365.png" alt="image-20230801112639365"></p><p>等待6个confirmation平均要等1个小时。</p><h4 id="selfish-mining"><a href="#selfish-mining" class="headerlink" title="selfish mining"></a>selfish mining</h4><p>造成分块攻击。</p><p>误导别的矿工无用功，减少竞争。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go标准库-os</title>
      <link href="/2023/07/31/go%E6%A0%87%E5%87%86%E5%BA%93-os/"/>
      <url>/2023/07/31/go%E6%A0%87%E5%87%86%E5%BA%93-os/</url>
      
        <content type="html"><![CDATA[<p>os包提供了操作系统函数的不依赖平台的接口。设计为Unix风格的，虽然错误处理是go风格的；失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。例如，如果某个使用一个文件名的调用（如Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为*PathError，其内部可以解包获得更多信息。</p><span id="more"></span><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    O_RDONLY <span class="type">int</span> = syscall.O_RDONLY <span class="comment">// 只读模式打开文件</span></span><br><span class="line">    O_WRONLY <span class="type">int</span> = syscall.O_WRONLY <span class="comment">// 只写模式打开文件</span></span><br><span class="line">    O_RDWR   <span class="type">int</span> = syscall.O_RDWR   <span class="comment">// 读写模式打开文件</span></span><br><span class="line">    O_APPEND <span class="type">int</span> = syscall.O_APPEND <span class="comment">// 写操作时将数据附加到文件尾部</span></span><br><span class="line">    O_CREATE <span class="type">int</span> = syscall.O_CREAT  <span class="comment">// 如果不存在将创建一个新文件</span></span><br><span class="line">    O_EXCL   <span class="type">int</span> = syscall.O_EXCL   <span class="comment">// 和O_CREATE配合使用，文件必须不存在</span></span><br><span class="line">    O_SYNC   <span class="type">int</span> = syscall.O_SYNC   <span class="comment">// 打开文件用于同步I/O</span></span><br><span class="line">    O_TRUNC  <span class="type">int</span> = syscall.O_TRUNC  <span class="comment">// 如果可能，打开时清空文件</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>用于包装底层系统的参数用于Open函数，不是所有的flag都能在特定系统里使用的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SEEK_SET <span class="type">int</span> = <span class="number">0</span> <span class="comment">// 相对于文件起始位置seek</span></span><br><span class="line">    SEEK_CUR <span class="type">int</span> = <span class="number">1</span> <span class="comment">// 相对于文件当前位置seek</span></span><br><span class="line">    SEEK_END <span class="type">int</span> = <span class="number">2</span> <span class="comment">// 相对于文件结尾位置seek</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>指定Seek函数从何处开始搜索（即相对位置）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PathSeparator     = <span class="string">&#x27;/&#x27;</span> <span class="comment">// 操作系统指定的路径分隔符</span></span><br><span class="line">    PathListSeparator = <span class="string">&#x27;:&#x27;</span> <span class="comment">// 操作系统指定的表分隔符</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInvalid    = errors.New(<span class="string">&quot;invalid argument&quot;</span>)</span><br><span class="line">    ErrPermission = errors.New(<span class="string">&quot;permission denied&quot;</span>)</span><br><span class="line">    ErrExist      = errors.New(<span class="string">&quot;file already exists&quot;</span>)</span><br><span class="line">    ErrNotExist   = errors.New(<span class="string">&quot;file does not exist&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="func-Hostname"><a href="#func-Hostname" class="headerlink" title="func Hostname"></a>func <a href="https://github.com/golang/go/blob/master/src/os/doc.go?name=release#92">Hostname</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Hostname() (name string, err error)</span><br></pre></td></tr></table></figure><p>Hostname返回内核提供的主机名。</p><h3 id="func-Getpagesize"><a href="#func-Getpagesize" class="headerlink" title="func Getpagesize"></a>func <a href="https://github.com/golang/go/blob/master/src/os/types.go?name=release#13">Getpagesize</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpagesize() int</span><br></pre></td></tr></table></figure><p>Getpagesize返回底层的系统内存页的尺寸。</p><h3 id="func-Environ"><a href="#func-Environ" class="headerlink" title="func Environ"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#101">Environ</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Environ() []string</span><br></pre></td></tr></table></figure><p>Environ返回表示环境变量的格式为”key&#x3D;value”的字符串的切片拷贝。</p><h3 id="func-Getenv"><a href="#func-Getenv" class="headerlink" title="func Getenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#79">Getenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getenv(key string) string</span><br></pre></td></tr></table></figure><p>Getenv检索并返回名为key的环境变量的值。如果不存在该环境变量会返回空字符串。</p><h3 id="func-Setenv"><a href="#func-Setenv" class="headerlink" title="func Setenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#86">Setenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Setenv(key, value string) error</span><br></pre></td></tr></table></figure><p>Setenv设置名为key的环境变量。如果出错会返回该错误。</p><h3 id="func-Clearenv"><a href="#func-Clearenv" class="headerlink" title="func Clearenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#95">Clearenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Clearenv()</span><br></pre></td></tr></table></figure><p>Clearenv删除所有环境变量。</p><h3 id="func-Exit"><a href="#func-Exit" class="headerlink" title="func Exit"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#36">Exit</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Exit(code int)</span><br></pre></td></tr></table></figure><p>Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行。</p><h3 id="func-Expand"><a href="#func-Expand" class="headerlink" title="func Expand"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#13">Expand</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Expand(s string, mapping func(string) string) string</span><br></pre></td></tr></table></figure><p>Expand函数替换s中的${var}或$var为mapping(var)。例如，os.ExpandEnv(s)等价于os.Expand(s, os.Getenv)。</p><h3 id="func-ExpandEnv"><a href="#func-ExpandEnv" class="headerlink" title="func ExpandEnv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#32">ExpandEnv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ExpandEnv(s string) string</span><br></pre></td></tr></table></figure><p>ExpandEnv函数替换s中的${var}或$var为名为var 的环境变量的值。引用未定义环境变量会被替换为空字符串。</p><h3 id="func-Getuid"><a href="#func-Getuid" class="headerlink" title="func Getuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#15">Getuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getuid() int</span><br></pre></td></tr></table></figure><p>Getuid返回调用者的用户ID。</p><h3 id="func-Geteuid"><a href="#func-Geteuid" class="headerlink" title="func Geteuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#18">Geteuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Geteuid() int</span><br></pre></td></tr></table></figure><p>Geteuid返回调用者的有效用户ID。</p><h3 id="func-Getgid"><a href="#func-Getgid" class="headerlink" title="func Getgid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#21">Getgid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgid() int</span><br></pre></td></tr></table></figure><p>Getgid返回调用者的组ID。</p><h3 id="func-Getegid"><a href="#func-Getegid" class="headerlink" title="func Getegid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#24">Getegid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getegid() int</span><br></pre></td></tr></table></figure><p>Getegid返回调用者的有效组ID。</p><h3 id="func-Getgroups"><a href="#func-Getgroups" class="headerlink" title="func Getgroups"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#27">Getgroups</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgroups() ([]int, error)</span><br></pre></td></tr></table></figure><p>Getgroups返回调用者所属的所有用户组的组ID。</p><h3 id="func-Getpid"><a href="#func-Getpid" class="headerlink" title="func Getpid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#67">Getpid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpid() int</span><br></pre></td></tr></table></figure><p>Getpid返回调用者所在进程的进程ID。</p><h3 id="func-Getppid"><a href="#func-Getppid" class="headerlink" title="func Getppid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#70">Getppid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getppid() int</span><br></pre></td></tr></table></figure><p>Getppid返回调用者所在进程的父进程的进程ID。</p><h3 id="type-Signal"><a href="#type-Signal" class="headerlink" title="type Signal"></a>type <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#61">Signal</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Signal interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">    Signal() // 用来区分其他实现了Stringer接口的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signal代表一个操作系统信号。一般其底层实现是依赖于操作系统的：在Unix中，它是syscall.Signal类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    Interrupt Signal = syscall.SIGINT</span><br><span class="line">    Kill      Signal = syscall.SIGKILL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>仅有的肯定会被所有操作系统提供的信号，Interrupt（中断信号）和Kill（强制退出信号）。</p><h3 id="func-Hostname-1"><a href="#func-Hostname-1" class="headerlink" title="func Hostname"></a>func <a href="https://github.com/golang/go/blob/master/src/os/doc.go?name=release#92">Hostname</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Hostname() (name string, err error)</span><br></pre></td></tr></table></figure><p>Hostname返回内核提供的主机名。</p><h3 id="func-Getpagesize-1"><a href="#func-Getpagesize-1" class="headerlink" title="func Getpagesize"></a>func <a href="https://github.com/golang/go/blob/master/src/os/types.go?name=release#13">Getpagesize</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpagesize() int</span><br></pre></td></tr></table></figure><p>Getpagesize返回底层的系统内存页的尺寸。</p><h3 id="func-Environ-1"><a href="#func-Environ-1" class="headerlink" title="func Environ"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#101">Environ</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Environ() []string</span><br></pre></td></tr></table></figure><p>Environ返回表示环境变量的格式为”key&#x3D;value”的字符串的切片拷贝。</p><h3 id="func-Getenv-1"><a href="#func-Getenv-1" class="headerlink" title="func Getenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#79">Getenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getenv(key string) string</span><br></pre></td></tr></table></figure><p>Getenv检索并返回名为key的环境变量的值。如果不存在该环境变量会返回空字符串。</p><h3 id="func-Setenv-1"><a href="#func-Setenv-1" class="headerlink" title="func Setenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#86">Setenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Setenv(key, value string) error</span><br></pre></td></tr></table></figure><p>Setenv设置名为key的环境变量。如果出错会返回该错误。</p><h3 id="func-Clearenv-1"><a href="#func-Clearenv-1" class="headerlink" title="func Clearenv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#95">Clearenv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Clearenv()</span><br></pre></td></tr></table></figure><p>Clearenv删除所有环境变量。</p><h3 id="func-Exit-1"><a href="#func-Exit-1" class="headerlink" title="func Exit"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#36">Exit</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Exit(code int)</span><br></pre></td></tr></table></figure><p>Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行。</p><h3 id="func-Expand-1"><a href="#func-Expand-1" class="headerlink" title="func Expand"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#13">Expand</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Expand(s string, mapping func(string) string) string</span><br></pre></td></tr></table></figure><p>Expand函数替换s中的${var}或$var为mapping(var)。例如，os.ExpandEnv(s)等价于os.Expand(s, os.Getenv)。</p><h3 id="func-ExpandEnv-1"><a href="#func-ExpandEnv-1" class="headerlink" title="func ExpandEnv"></a>func <a href="https://github.com/golang/go/blob/master/src/os/env.go?name=release#32">ExpandEnv</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func ExpandEnv(s string) string</span><br></pre></td></tr></table></figure><p>ExpandEnv函数替换s中的${var}或$var为名为var 的环境变量的值。引用未定义环境变量会被替换为空字符串。</p><h3 id="func-Getuid-1"><a href="#func-Getuid-1" class="headerlink" title="func Getuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#15">Getuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getuid() int</span><br></pre></td></tr></table></figure><p>Getuid返回调用者的用户ID。</p><h3 id="func-Geteuid-1"><a href="#func-Geteuid-1" class="headerlink" title="func Geteuid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#18">Geteuid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Geteuid() int</span><br></pre></td></tr></table></figure><p>Geteuid返回调用者的有效用户ID。</p><h3 id="func-Getgid-1"><a href="#func-Getgid-1" class="headerlink" title="func Getgid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#21">Getgid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgid() int</span><br></pre></td></tr></table></figure><p>Getgid返回调用者的组ID。</p><h3 id="func-Getegid-1"><a href="#func-Getegid-1" class="headerlink" title="func Getegid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#24">Getegid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getegid() int</span><br></pre></td></tr></table></figure><p>Getegid返回调用者的有效组ID。</p><h3 id="func-Getgroups-1"><a href="#func-Getgroups-1" class="headerlink" title="func Getgroups"></a>func <a href="https://github.com/golang/go/blob/master/src/os/proc.go?name=release#27">Getgroups</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getgroups() ([]int, error)</span><br></pre></td></tr></table></figure><p>Getgroups返回调用者所属的所有用户组的组ID。</p><h3 id="func-Getpid-1"><a href="#func-Getpid-1" class="headerlink" title="func Getpid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#67">Getpid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getpid() int</span><br></pre></td></tr></table></figure><p>Getpid返回调用者所在进程的进程ID。</p><h3 id="func-Getppid-1"><a href="#func-Getppid-1" class="headerlink" title="func Getppid"></a>func <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#70">Getppid</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Getppid() int</span><br></pre></td></tr></table></figure><p>Getppid返回调用者所在进程的父进程的进程ID。</p><h3 id="type-Signal-1"><a href="#type-Signal-1" class="headerlink" title="type Signal"></a>type <a href="https://github.com/golang/go/blob/master/src/os/exec.go?name=release#61">Signal</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Signal interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">    Signal() // 用来区分其他实现了Stringer接口的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signal代表一个操作系统信号。一般其底层实现是依赖于操作系统的：在Unix中，它是syscall.Signal类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    Interrupt Signal = syscall.SIGINT</span><br><span class="line">    Kill      Signal = syscall.SIGKILL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>仅有的肯定会被所有操作系统提供的信号，Interrupt（中断信号）和Kill（强制退出信号）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础语法面试题</title>
      <link href="/2023/07/30/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/07/30/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Go有异常类型吗"><a href="#Go有异常类型吗" class="headerlink" title="Go有异常类型吗"></a>Go有异常类型吗</h1><p>Go没有异常类型，只有错误类型(Error)，通常使用返回值来表示异常状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么是协程Goroutine"><a href="#什么是协程Goroutine" class="headerlink" title="什么是协程Goroutine"></a>什么是协程Goroutine</h1><p>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p><h1 id="如何高效地拼接字符串"><a href="#如何高效地拼接字符串" class="headerlink" title="如何高效地拼接字符串"></a>如何高效地拼接字符串</h1><p>在Go中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应该使用string.Builder，最小化内存拷贝次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    str.WriteString(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h1 id="什么是rune类型"><a href="#什么是rune类型" class="headerlink" title="什么是rune类型"></a>什么是rune类型</h1><p>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。</p><h1 id="如何判断map中是否包含某个key"><a href="#如何判断map中是否包含某个key" class="headerlink" title="如何判断map中是否包含某个key"></a>如何判断map中是否包含某个key</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> val, ok := dict[<span class="string">&quot;foo&quot;</span>]; ok &#123;</span><br><span class="line">    <span class="comment">//do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dict[“foo”] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key “foo”，val 将被赋予 “foo” 对应的值。</p><h1 id="defer的执行顺序"><a href="#defer的执行顺序" class="headerlink" title="defer的执行顺序"></a>defer的执行顺序</h1><ul><li>多个defer语句，遵从后进先出(Last in First Out, LIFO)的原则，最后声明的defer语句，最先得到执行。</li><li>defer在return语句执行后执行，但在函数退出之前，defer可以修改返回值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;defer1&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;defer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;return&quot;</span>, test())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// defer2</span></span><br><span class="line"><span class="comment">// defer1</span></span><br><span class="line"><span class="comment">// return 0</span></span><br></pre></td></tr></table></figure><h1 id="如何交换两个变量的值"><a href="#如何交换两个变量的值" class="headerlink" title="如何交换两个变量的值"></a>如何交换两个变量的值</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b := <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span></span><br><span class="line">a, b = b, a</span><br><span class="line">fmt.Println(a, b) <span class="comment">// B A</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux打包和压缩</title>
      <link href="/2023/07/29/Linux%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/"/>
      <url>/2023/07/29/Linux%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="tar命令做打包操作"><a href="#tar命令做打包操作" class="headerlink" title="tar命令做打包操作"></a>tar命令做打包操作</h1><p>该命令的基本格式为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 源文件或目录</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-c</td><td>将多个文件或目录进行打包。</td></tr><tr><td>-A</td><td>追加 tar 文件到归档文件。</td></tr><tr><td>-f 包名</td><td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td></tr><tr><td>-v</td><td>显示打包文件过程；</td></tr></tbody></table><h1 id="tar命令做解打包操作"><a href="#tar命令做解打包操作" class="headerlink" title="tar命令做解打包操作"></a>tar命令做解打包操作</h1><p>该命令的基本格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 压缩包</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-x</td><td>对 tar 包做解打包操作。</td></tr><tr><td>-f</td><td>指定要解压的 tar 包的包名。</td></tr><tr><td>-t</td><td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td></tr><tr><td>-C 目录</td><td>指定解打包位置。</td></tr><tr><td>-v</td><td>显示解打包的具体过程。</td></tr></tbody></table><p>其实解打包和打包相比，只是把打包选项 “-cvf” 更换为 “-xvf”。我们来试试： </p><h1 id="zip压缩文件或目录"><a href="#zip压缩文件或目录" class="headerlink" title="zip压缩文件或目录"></a>zip压缩文件或目录</h1><p>zip命令的基本格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#zip [选项] 压缩包名 源文件或源目录列表</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td></tr><tr><td>-m</td><td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td></tr><tr><td>-v</td><td>显示详细的压缩过程信息。</td></tr><tr><td>-q</td><td>在压缩的时候不显示命令的执行过程。</td></tr><tr><td>-压缩级别</td><td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td></tr><tr><td>-u</td><td>更新压缩文件，即往压缩文件中添加新文件。</td></tr></tbody></table><p>使用 zip 命令压缩目录，需要使用“-r”选项，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment">#建立测试目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># zip -r dir1.zip dir1</span></span><br><span class="line">adding: dir1/(stored 0%)</span><br><span class="line"><span class="comment">#压缩目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -dl dir1.zip</span></span><br><span class="line">-rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip</span><br><span class="line"><span class="comment">#压缩文件生成</span></span><br></pre></td></tr></table></figure><h1 id="unzip解压文件"><a href="#unzip解压文件" class="headerlink" title="unzip解压文件"></a>unzip解压文件</h1><p>unzip 命令可以查看和解压缩 zip 文件。该命令的基本格式如下：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d 目录名</td><td>将压缩文件解压到指定目录下。</td></tr><tr><td>-n</td><td>解压时并不覆盖已经存在的文件。</td></tr><tr><td>-o</td><td>解压时覆盖已经存在的文件，并且无需用户确认。</td></tr><tr><td>-v</td><td>查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td></tr><tr><td>-t</td><td>测试压缩文件有无损坏，但并不解压。</td></tr><tr><td>-x 文件列表</td><td>解压文件，但不包含文件列表中指定的文件。</td></tr></tbody></table><p>使用 -d 选项手动指定解压缩位置，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># unzip -d /tmp/ ana.zip</span></span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line"><span class="comment">#把压缩包解压到指定位置</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统</title>
      <link href="/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="Linux文件目录结构"><a href="#Linux文件目录结构" class="headerlink" title="Linux文件目录结构"></a>Linux文件目录结构</h1><p><img src="/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p><ul><li><strong>&#x2F;bin</strong></li></ul><p>bin是Binaries的缩写，这个目录存放着最经常使用的命令。</p><ul><li><strong>&#x2F;boot</strong></li></ul><p>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><ul><li><strong>&#x2F;dev</strong></li></ul><p>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p><ul><li><strong>&#x2F;etc</strong></li></ul><p>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><ul><li><strong>&#x2F;home</strong></li></ul><p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p><ul><li><strong>&#x2F;lib</strong></li></ul><p>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><ul><li><strong>&#x2F;lost+found</strong></li></ul><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><ul><li><strong>&#x2F;media</strong></li></ul><p>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p><ul><li><strong>&#x2F;mnt</strong></li></ul><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p><ul><li><strong>&#x2F;opt</strong></li></ul><p>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p><ul><li><strong>&#x2F;proc</strong></li></ul><p>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件。</p><ul><li><strong>&#x2F;root</strong></li></ul><p>该目录为系统管理员，也称作超级权限者的用户主目录。</p><ul><li><strong>&#x2F;sbin</strong></li></ul><p>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p><ul><li><strong>&#x2F;var</strong></li></ul><p>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p><ul><li><strong>&#x2F;usr</strong></li></ul><p> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p><ul><li><strong>&#x2F;srv</strong></li></ul><p>该目录存放一些服务启动之后需要提取的数据。</p><ul><li><strong>&#x2F;temp</strong></li></ul><p>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p><h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><p><strong>在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</strong></p><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p><p>举个例子，我们想通过命令行访问某个 U 盘中的数据，图 1 所示为 U 盘文件目录结构和 Linux 系统中的文件目录结构。</p><p><img src="/2-1Z321130921V9-1690619380227-6.gif" alt="U 盘和 Linux 系统文件目录结构"></p><p>图 1 中可以看到，目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。</p><p>接下来，我们在根目录下新建一个目录 &#x2F;sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，挂载效果如图 2 所示。</p><p><img src="/2023/07/29/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2-1Z321130I44B.gif" alt="文件系统挂载"></p><p>可以看到，U 盘文件系统已经成为 Linux 文件系统目录的一部分，此时访问 &#x2F;sdb-u&#x2F; 就等同于访问 U 盘。</p><p>前面讲过，根目录下的 &#x2F;dev&#x2F; 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件（比如 sdb1），就位于 &#x2F;dev&#x2F; 目录下（&#x2F;dev&#x2F;sdb1），但无法通过 &#x2F;dev&#x2F;sdb1&#x2F; 直接访问 U 盘数据，访问此目录只会提供给你此设备的一些基本信息（比如容量）。</p><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>umount 命令用于卸载已经挂载的硬件设备，该命令的基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# umount 设备文件名或挂载点</span><br></pre></td></tr></table></figure><p>注意，卸载命令后面既可以加设备文件名，也可以加挂载点，不过只能二选一，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# umount /mnt/usb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载U盘</span></span><br><span class="line">[root@localhost ~]# umount /mnt/cdrom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载光盘</span></span><br><span class="line">[root@localhost ~]# umount /dev/sr0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令加设备文件名同样是可以卸载的</span></span><br></pre></td></tr></table></figure><h1 id="修复文件系统"><a href="#修复文件系统" class="headerlink" title="修复文件系统"></a>修复文件系统</h1><p>fsck 命令用于检查文件系统并尝试修复出现的错误。该命令的基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fsck [选项] 分区设备文件名</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>自动修复文件系统，没有任何提示信息。</td></tr><tr><td>-r</td><td>采取互动的修复模式，在修改文件前会进行询问，让用户得以确认并决定处理方式。</td></tr><tr><td>-A（大写）</td><td>按照 &#x2F;etc&#x2F;fstab 配置文件的内容，检查文件内罗列的全部文件系统。</td></tr><tr><td>-t 文件系统类型</td><td>指定要检查的文件系统类型。</td></tr><tr><td>-C（大写）</td><td>显示检查分区的进度条。</td></tr><tr><td>-f</td><td>强制检测，一般 fsck 命令如果没有发现分区有问题，则是不会检测的。如果强制检测，那么不管是否发现问题，都会检测。</td></tr><tr><td>-y</td><td>自动修复，和 -a 作用一致，不过有些文件系统只支持 -y。</td></tr></tbody></table><p>需要注意的是，在使用 fsck 命令修改某文件系统时，这个文件系统对应的磁盘分区一定要处于卸载状态，磁盘分区在挂载状态下进行修复是非常不安全的，数据可能会遭到破坏，也有可能会损坏磁盘。</p><p>这里，给大家举个例子，如果想要修复某个分区，则只需执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#fsck -r /dev/sdb1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">采用互动的修复模式</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能合约</title>
      <link href="/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
      <url>/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约模型"><a href="#智能合约模型" class="headerlink" title="智能合约模型"></a>智能合约模型</h1><p>本质上是一个运行在区块链上的分布式应用。</p><h2 id="区块链：分布式账本"><a href="#区块链：分布式账本" class="headerlink" title="区块链：分布式账本"></a>区块链：分布式账本</h2><p>区块(Block)</p><p>Previous Hash, Data, Hash</p><p>账户(Account)</p><p>Address, Balance</p><p><img src="/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%A8%A1%E5%9E%8B.png" alt="区块链模型"></p><h2 id="以太坊账户模型"><a href="#以太坊账户模型" class="headerlink" title="以太坊账户模型"></a>以太坊账户模型</h2><p><strong>EOA</strong></p><p>拥有非对称密钥对的用户实体。</p><p><strong>COA</strong></p><p>合约字节码（Code Hash）</p><p>持久化存储（Storage Root）</p><p><img src="/2023/07/27/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B.png" alt="以太坊账户模型"></p><h2 id="交易的基本格式"><a href="#交易的基本格式" class="headerlink" title="交易的基本格式"></a>交易的基本格式</h2><p><strong>Hash</strong></p><p>交易标识</p><p><strong>From</strong></p><p>发送交易的账户，需要用私钥为这笔交易签名</p><p><strong>to</strong></p><p>目的账户</p><p><strong>Value</strong></p><p>以太币数量</p><p><strong>Calldata</strong></p><p>字节流格式的输入</p><p><strong>Gas</strong></p><p>支付给矿工的手续费</p><p><strong>GasPrice</strong></p><p>Gas的单位价格，以Ether标识</p><p><strong>Logs</strong></p><p>被触发的事件</p><h1 id="执行-amp-调试智能合约"><a href="#执行-amp-调试智能合约" class="headerlink" title="执行&amp;调试智能合约"></a>执行&amp;调试智能合约</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶</title>
      <link href="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/07/27/Redis%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB-Redis-Database"><a href="#RDB-Redis-Database" class="headerlink" title="RDB(Redis Database)"></a>RDB(Redis Database)</h2><blockquote><p>触发机制</p></blockquote><ol><li>save规则满足的情况下,会自动触发rdb规则</li><li>执行flushall命令,也会触发rdb规则</li><li>退出redis,也会产生rdb文件</li></ol><blockquote><p>恢复rdb文件</p></blockquote><ol><li>将rdb文件存放在redis的启动目录</li><li>查看需要存在的位置</li></ol><p><img src="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/v2-1057d3d1a5e4d84745156b65867a6f55_720w.webp" alt="img"></p><h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h2><p>以日志的形式记录每个写操作,将Redis执行过的所有指令记录下来(读操作不记录),只许追加文件而不可以改写文件,Redis启动之初会读取该文件重新构建数据.</p><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p><strong>Redis发布订阅（pub&#x2F;sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接受消息。</strong></p><p><img src="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/v2-29130c54042bd99251f5dd80a7d801cf_b.jpg" alt="img"></p><p><strong>订阅端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE dingdada  <span class="comment">#订阅名字为 dingdada 的频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;dingdada&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#等待推送的信息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span>  <span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;dingdada&quot;</span>  <span class="comment">#来自哪个频道的消息</span></span><br><span class="line">3) <span class="string">&quot;hello world\xef\xbc\x81&quot;</span>  <span class="comment"># 消息的具体内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;dingdada&quot;</span></span><br><span class="line">3) <span class="string">&quot;my name is dyj\x81&quot;</span></span><br></pre></td></tr></table></figure><p><strong>发送端</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH dingdada <span class="string">&quot;hello world！&quot;</span>  <span class="comment">#发送消息到dingdada 频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH dingdada <span class="string">&quot;my name is dyj&quot;</span>  <span class="comment">#发送消息到dingdada 频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主从复制是指将一台Redis服务器的数据,复制到其他的Redis服务器,前者称为master,后者称为slave.数据的复制是单向的,只能从主节点到从节点.Master以写为主,Slave以读为主.</p><p><img src="/image-20230819225131566.png" alt="image-20230819225131566"></p><p>主从复制,读写分离.实战中80%的业务都是读操作,利用仆从服务器减缓服务器的压力</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li>数据冗余:实现了数据的热备份,是持久化之外的一种数据冗余方式</li><li>故障恢复:当主节点出现问题时,可以由从节点提供服务,实现快速的故障恢复,实际上是一种服务的冗余</li><li>负载均衡:在主从复制的基础上,配合读写分离,可以由主节点提供写服务,由从节点提供读服务,分担服务器负载</li><li>高可用基石:主从复制是哨兵和集群能够实施的基础,因此说主从复制是Redis高可用的基础</li></ol><h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><strong>默认情况下,每台Redis服务器都是主节点</strong></p><p> 配置从机:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF 127.0.0.1 6380 <span class="comment"># SLAVEOF host port</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6380</span><br><span class="line">master_link_status:down</span><br><span class="line">master_last_io_seconds_ago:-1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:0</span><br><span class="line">slave_repl_offset:0</span><br><span class="line">master_link_down_since_seconds:-1</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:0ba4b5624f5e254be973621bb67263125a86df74</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>哨兵模式是一种特殊的模式,首先Redis提供了哨兵的命令,哨兵是一个独立的进程,作为进程,它会独立运行.其原理是哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例.</p><p> <img src="/2023/07/27/Redis%E8%BF%9B%E9%98%B6/image-20230820140455722.png" alt="image-20230820140455722"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>配置哨兵配置文件sentinel.conf</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># senrinel monitor name host port 1</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><ol start="2"><li>启动哨兵</li></ol><h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><p><strong>缓存雪崩</strong>：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</p></blockquote><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote><p><strong>缓存击穿</strong>：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</p></blockquote><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote><p><strong>缓存穿透</strong>：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-内存管理</title>
      <link href="/2023/07/26/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/07/26/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Go 的内存是自动管理的，我们可以随意定义变量直接使用，不需要考虑变量背后的内存申请和释放的问题。本文意在搞清楚 Go 在方面帮我们做了什么，使我们不用关心那些复杂内存的问题，还依旧能写出较为高效的程序。</p><h1 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h1><p>程序动态申请内存空间，是要使用系统调用的，比如 Linux 系统上是调用 mmap 方法实现的。但对于大型系统服务来说，直接调用 mmap 申请内存，会有一定的代价。比如：</p><ul><li>内核态与用户态之间的切换浪费系统资源</li><li>频繁申请小块内存空间容易造成内存碎片</li><li>为了保证内存访问具有良好的局部性，开发者需要投入大量的精力去做优化，这是一个很重的负担。</li></ul><p>解决方案：<strong>对象池</strong>（缓存）。</p><p>假设系统需要频繁动态申请内存来存放一个数据结构，比如 [10]int 。那么我们完全可以在程序启动之初，一次性申请几百甚至上千个 [10]int 。这样完美的解决了上面遇到的问题：</p><ol><li>不需要频繁申请内存了，而是从对象池里拿，程序不会频繁进入内核态。</li><li>因为一次性申请一个连续的大空间，对象池会被重复利用，不会出现碎片。</li><li>程序频繁访问的就是对象池背后的同一块内存空间，局部性良好。</li></ol><h1 id="Golang内存管理"><a href="#Golang内存管理" class="headerlink" title="Golang内存管理"></a>Golang内存管理</h1><p>Golang 的内存管理本质上就是一个内存池，只不过内部做了很多的优化。比如自动伸缩内存池大小，合理的切割内存块等等。</p><h2 id="内存池mheap"><a href="#内存池mheap" class="headerlink" title="内存池mheap"></a>内存池mheap</h2><p>Golang的程序在启动时，会一次性从操作系统申请一大块内存作为内存池。这块内存空间会放在一个叫mheap的struct中管理，mheap负责将这一块内存切割成不同的区域，并将其中一部分的内存切割成合适的大小。</p><p>关于mheap的几个重要概念：</p><p><strong>page</strong>：内存页，一块8K大小的内存空间。</p><p><strong>span</strong>: 一个或者多个连续的page。</p><p><strong>sizeclass</strong>：空间规格，标记span中的page应该如何使用。</p><p><strong>object</strong>：对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object 。假设 object 的大小是 16B ， span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去。</p><p>示意图：</p><p>内部的整体内存布局如下图所示：</p><ul><li>mheap.spans: 存储page和span信息，比如一个span的起始地址，page数目。</li><li>mheap.bitmap: 存储着各个span中对象的标记信息，比如对象是否可回收。</li><li>mheap.arena_start: 将要分配给应用程序使用的空间。</li></ul><h2 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h2><p><strong>用途相同</strong>的span会以链表的形式组织在一起。这里的用途用sizeclass来表示。</p><p>比如当分配一块大小为 n 的内存时，系统计算 n 应该使用哪种 sizeclass ，然后根据 sizeclass 的值去找到一个可用的 span 来用作分配。其中 sizeclass 一共有 67 种(Go1.5)，如图所示：</p><p>找到合适的 span 后，会从中取一个 object 返回给上层使用。这些 span 被放在一个叫做 mcentral 的结构中管理。</p><p>mheap 将从 OS 那里申请过来的内存初始化成一个大 span (sizeclass&#x3D;0)。然后根据需要从这个大 span 中切出小 span ，放在 mcentral 中来管理。大 span 由 mheap.freelarge 和 mheap.busylarge 等管理。如果 mcentral 中的 span 不够用了，会从 mheap.freelarge 上再切一块，如果 mheap.freelarge 空间不够，会再次从 OS 那里申请内存重复上述步骤。下面是 mheap 和 mcentral 的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">GO</span><br><span class="line">type mheap struct &#123;</span><br><span class="line"></span><br><span class="line">// other fields</span><br><span class="line"></span><br><span class="line">   lock    mutex</span><br><span class="line"></span><br><span class="line">   free    [_MaxMHeapList]mspan // free lists of given length， 1M 以下</span><br><span class="line"></span><br><span class="line">   freelarge mspan         // free lists length &gt;= _MaxMHeapList, &gt;= 1M</span><br><span class="line"></span><br><span class="line">   busy    [_MaxMHeapList]mspan // busy lists of large objects of given length</span><br><span class="line"></span><br><span class="line">   busylarge mspan         // busy lists of large objects length &gt;= _MaxMHeapList</span><br><span class="line"></span><br><span class="line">   central [_NumSizeClasses]struct &#123;// _NumSizeClasses = 67</span><br><span class="line"></span><br><span class="line">     mcentral mcentral</span><br><span class="line"></span><br><span class="line">// other fields</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// other fields</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Central list of free objects of a given size.</span><br><span class="line"></span><br><span class="line">type mcentral struct &#123;</span><br><span class="line"></span><br><span class="line">   lock    mutex // 分配时需要加锁</span><br><span class="line"></span><br><span class="line">   sizeclass int32 // 哪种 sizeclass</span><br><span class="line"></span><br><span class="line">   nonempty  mspan // 还有可用的空间的 span 链表</span><br><span class="line"></span><br><span class="line">   empty   mspan // 没有可用的空间的 span 列表</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h2><p>mcental中有一个lock字段，在高并发场景下必要时用锁来避免冲突。</p><p>但是锁是低效的，在高并发的服务中，它会使内存申请成为整个系统的瓶颈；所以在mcentral的前面又加了一层mchache。</p><p>每一个 mcache 和每一个处理器(P) 是一一对应的，也就是说每一个 P 都有一个 mcache 成员。 Goroutine 申请内存时，首先从其所在的 P 的 mcache 中分配，如果 mcache 没有可用 span ，再从 mcentral 中获取，并填充到 mcache 中。</p><p>从 mcache 上分配内存空间是不需要加锁的，因为在同一时间里，一个 P 只有一个线程在其上面运行，不可能出现竞争。没有了锁的限制，大大加速了内存分配。</p><h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><h2 id="Tiny对象"><a href="#Tiny对象" class="headerlink" title="Tiny对象"></a>Tiny对象</h2><p>面提到的 sizeclass&#x3D;1 的 span，用来给 &lt;&#x3D; 8B 的对象使用，所以像 int32 , byte , bool 以及小字符串等常用的微小对象，都会使用 sizeclass&#x3D;1 的 span，但分配给他们 8B 的空间，大部分是用不上的。并且这些类型使用频率非常高，就会导致出现大量的内部碎片。</p><p>所以 Go 尽量不使用 sizeclass&#x3D;1 的 span， 而是将 &lt; 16B 的对象为统一视为 tiny 对象(tinysize)。配时，从 sizeclass&#x3D;2 的 span 中获取一个 16B 的 object 用以分配。如果存储的对象小于 16B ，这个空间会被暂时保存起来 (mcache.tiny 字段)，下次分配时会复用这个空间，直到这个 object 用完为止。</p><h2 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h2><p>如上面所述，最大的 sizeclass 最大只能存放 32K 的对象。如果一次性申请超过 32K 的内存，系统会直接绕过 mcache 和 mcentral，直接从 mheap 上获取，mheap 中有一个 freelarge 字段管理着超大 span。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2023/07/24/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/24/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h1><p>NOSQL &#x3D; Not Only SQL</p><p>非关系型数据库,为了面对高并发社区.</p><h1 id="Redis的基本数据类型"><a href="#Redis的基本数据类型" class="headerlink" title="Redis的基本数据类型"></a>Redis的基本数据类型</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>判断一个键是否存在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXISTS</span> key</span><br></pre></td></tr></table></figure><p>删除键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key [key...]</span><br></pre></td></tr></table></figure><p>获得键值的数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类型是其他4种数据类型的基础，其他数据类型和字符串类 型的差别从某种角度来说只是组织字符串的形式不同。例如，列表类 型是以列表的形式组织字符串，而集合类型是以集合的形式组织字符串。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol><li>赋值与查询</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> KEY <span class="keyword">VALUE</span></span><br><span class="line"><span class="keyword">GET</span> KEY</span><br></pre></td></tr></table></figure><ol start="2"><li>递增数字</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR NUM</span><br></pre></td></tr></table></figure><p>当要操作的键不存在时会默认键值为0，所以第一次递增后的结果 是1。当键值不是整数时Redis会提示错误。</p><ol start="3"><li>增加&#x2F;减少指定的整数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCRBY KEY INCREMENT</span><br><span class="line">DECRBY KEY DECREMENT</span><br></pre></td></tr></table></figure><ol start="4"><li>增加指定浮点数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure><ol start="5"><li>向尾部追加值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value,即相当于SET key value。返回值是追加字符串的总长度。</p><ol start="6"><li>获取字符串长度</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p>STRLEN命令返回键值的长度，如果键不存在则返回0。</p><p>字符串类型可以存储二进制数据，所以它可以存储任 何编码的字符串。例子中Redis接收到的是使用UTF-8编码的中文，由 于“你”和“好”两个字的UTF-8编码的长度都是3, 因此STRLEN key的返回值为6。</p><ol start="7"><li>同时获取多个键值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key...]</span><br><span class="line">MSET key <span class="keyword">value</span>[key value...]</span><br></pre></td></tr></table></figure><p>MGET&#x2F;MSET 与GET&#x2F;SET 相似，不过MGET&#x2F;MSET 可以同时获 得&#x2F;设置多个键的键值。</p><ol start="8"><li>位操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key <span class="keyword">offset</span></span><br><span class="line">SETBIT key <span class="keyword">offset</span> <span class="keyword">value</span></span><br><span class="line">BITCOUNT key [<span class="keyword">start</span>][<span class="keyword">end</span>]</span><br><span class="line">BITOP operation destkey key [key...]</span><br></pre></td></tr></table></figure><p>一个字节由8个二进制位组成，Redis提供了4个命令可以直接对二 进制位进行操作。为了演示，我们首先将foo键赋值为bar：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> foo bar</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>bar的3个字母“b”“a”和“r”对应的ASCII码分别为98、97和114，转 换成二进制后分别为1100010、1100001和1110010，所以foo键中的二 进制位结构如图所示：</p><p><img src="/2023/07/24/Redis%E5%9F%BA%E7%A1%80/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="二进制存储结构"></p><p>GETBIT命令可以获得一个字符串类型键指定位置的二进制位的 值（0或1），索引从0开始。如果需要获取的二进制位的索引超出了键值的二进制位的实际长 度则默认位值是0。</p><p>SETBIT 命令可以设置字符串类型键指定位置的二进制位的值， 返回值是该位置的旧值。</p><p>BITCOUNT命令可以获得字符串类型键中值是1的二进制位个 数。</p><p>BITOP命令可以对多个字符串类型键进行位运算，并将结果存储 在destkey参数指定的键中。BITOP命令支持的运算操作有AND、OR、 XOR和NOT。如我们可以对bar和aar进行OR运算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> foo1 bar</span><br><span class="line">OK</span><br><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">SET</span> foo2 aar</span><br><span class="line">OK</span><br><span class="line">redis<span class="operator">&gt;</span> BITOP <span class="keyword">OR</span> res foo1 foo2</span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line">redis<span class="operator">&gt;</span> <span class="keyword">GET</span> res</span><br><span class="line">&quot;car&quot;</span><br></pre></td></tr></table></figure><h2 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h2><p>散列类型（hash）的键值也是一种字典结构，其存储了字段 （field）和字段值的映射，但字段值只能是字符串，不支持其他数据类 型，换句话说，散列类型不能嵌套其他的数据类型。一个散列类型键 可以包含至多232−1个字段。</p><p>散列类型适合存储对象：使用对象类别和 ID 构成键名，使用字段 表示对象的属性，而字段值则存储属性值。例如要存储ID为2的汽车对 象，可以分别使用名为color、name和price的3个字段来存储该辆汽车的 颜色、名称和价格。存储结构如图所示：</p><p><img src="/2023/07/24/Redis%E5%9F%BA%E7%A1%80/%E6%95%A3%E5%88%97%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E6%B1%BD%E8%BD%A6%E5%AF%B9%E8%B1%A1.png" alt="散列类型存储汽车对象"></p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ol><li>取值与赋值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field <span class="keyword">value</span></span><br><span class="line">HGET key field</span><br><span class="line">HMSET key field <span class="keyword">value</span> [field <span class="keyword">value</span> …]</span><br><span class="line">HMGET key field [field …]</span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p>HSET命令用来给字段赋值，而HGET命令用来获得字段的值。</p><p>当需要同时设置多个字段的值时，可以使用HMSET命令。相应地，HMGET命令可以同时获得多个字段的值。</p><p>如果想获取键中所有字段和字段值却不知道键中有哪些字段时应该使用HGETALL命令。</p><ol start="2"><li>判断字段是否存在</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p>HEXISTS命令用来判断一个字段是否存在。如果存在则返回1，否 则返回0（如果键不存在也会返回0）。</p><ol start="3"><li>当字段不存在时赋值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>HSETNX命令与HSET命令类似，区别在于如果字段已经存在，HSETNX命令将不进行任何操作。HSETNX命令是原子操作，不用担心竞态条件。</p><ol start="4"><li>增加数字</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure><ol start="5"><li>删除字段</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure><p>HDEL命令可以删除一个或多个字段，返回值是被删除的字段个数。</p><h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ol><li>向列表两端增加元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...]</span><br><span class="line">RPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...]</span><br></pre></td></tr></table></figure><p>LPUSH命令用来向列表左边增加元素，返回值表示增加元素后列表的长度。向列表右边增加元素的话则使用RPUSH命令，其用法和LPUSH命令一样。</p><ol start="2"><li>从列表两端弹出元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure><ol start="3"><li>获取列表中的元素个数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p>LLEN 命令的功能类似SQL语句 SELECT COUNT(*) FROM table_name，但是 LLEN的时间复杂度为O(1)，使用时Redis会直接读 取现成的值，而不需要像部分关系数据库（如使用InnoDB存储引擎的 MySQL表）那样需要遍历一遍数据表来统计条目数量。</p><ol start="4"><li>获取列表片段</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key <span class="keyword">start</span> top</span><br></pre></td></tr></table></figure><p>LRANGE命令是列表类型最常用的命令之一，它能够获得列表中 的某一片段。LRANGE命令将返回索引从 start到 stop之间的所有元素 （包含两端的元素）。与大多数人的直觉相同，Redis的列表起始索引为0。</p><ol start="5"><li>删除列表中指定的值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count <span class="keyword">value</span></span><br></pre></td></tr></table></figure><p>LREM命令会删除列表中前count个值为value的元素，返回值是实 际删除的元素个数。根据count值的不同，LREM命令的执行方式会略 有差异。</p><p>（1）当 count &gt; 0时 LREM 命令会从列表左边开始删除前 count 个 值为 value的元素。 </p><p>（2）当 count &lt; 0时 LREM 命令会从列表右边开始删除前|count|个 值为 value 的元素。 </p><p>（3）当 count &#x3D; 0是 LREM命令会删除所有值为 value的元素。</p><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素 是否存在等，由于集合类型在Redis内部是使用值为空的散列表（hash table）实现的，所以这些操作的时间复杂度都是O(1)。多个集合类型键之间可以进行并集、交集和差集运算。</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ol><li>增加&#x2F;删除元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br><span class="line">SREM key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>SADD 命令用来向集合中增加一个或多个元素，如果键不存在则 会自动创建。SREM命令用来从集合中删除一个或多个元素，并返回删除成功的个数。</p><ol start="2"><li>获取集合中所有元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><ol start="3"><li>判断元素是否在集合中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure><p>当值存在时 SISMEMBER命令返回1，当值不存在或键不存在时返回 0。</p><ol start="4"><li>集合间运算</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key „]</span><br><span class="line">SINTER key [key „]</span><br><span class="line">SUNION key [key „]</span><br></pre></td></tr></table></figure><p>SDIFF进行差集运算，SINTER进行交集运算，SUNION进行并集运算。</p><h2 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h2><p>在集合类型的基础上有序集合类型为集合中的每个元素都关联了 一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在 等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元 素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每 个元素都是不同的，但是它们的分数却可以相同。</p><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ol><li>增加元素</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score <span class="keyword">member</span> [score <span class="keyword">member</span> ...]</span><br></pre></td></tr></table></figure><p>ZADD 命令用来向有序集合中加入一个元素和该元素的分数，如 果该元素已经存在则会用新的分数替换原有的分数。ZADD命令的返 回值是新加入到集合中的元素个数（不包含之前已经存在的元素）。</p><ol start="2"><li>获取元素的分数</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key <span class="keyword">member</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取排名在某个范围内的元素列表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line">ZREVRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br></pre></td></tr></table></figure><h1 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h1><h2 id="Geospatial地理位置"><a href="#Geospatial地理位置" class="headerlink" title="Geospatial地理位置"></a>Geospatial地理位置</h2><h3 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># geoadd 添加地理位置</span><br><span class="line"># 参数 key 值</span><br><span class="line"><span class="operator">&gt;</span> geoadd china:city <span class="number">39.90</span> <span class="number">116.40</span> beijing</span><br></pre></td></tr></table></figure><h3 id="geoget"><a href="#geoget" class="headerlink" title="geoget"></a>geoget</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># geoget 获取指定城市的经度纬度</span><br></pre></td></tr></table></figure><h3 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># geodist 获取两城市之间的距离</span><br></pre></td></tr></table></figure><h3 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># georadius 以某点为中心查找元素</span><br></pre></td></tr></table></figure><h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><blockquote><p>简介</p></blockquote><p>Redis Hyperloglog 基数统计的算法</p><h3 id="PFadd"><a href="#PFadd" class="headerlink" title="PFadd"></a>PFadd</h3><h3 id="PFcount"><a href="#PFcount" class="headerlink" title="PFcount"></a>PFcount</h3><h3 id="PFmerge"><a href="#PFmerge" class="headerlink" title="PFmerge"></a>PFmerge</h3><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><blockquote><p>位存储</p></blockquote><p>位图,都是操作二进制位来记录,只有0和1两种状态</p><h3 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h3><h3 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h3><h3 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis单条命令保存原子性,但是事务不保证原子性.</p><blockquote><p>本质</p><p>一组命令的集合</p></blockquote><p>一个Redis事务中的所有命令都会被序列化,在事务的执行过程中,会按照顺序执行.<strong>Redis事务没有隔离级别的概念</strong></p><p> <strong>Redis的事务流程</strong></p><ul><li>开启事务 multi</li><li>命令入队</li><li>执行事务</li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="编译型异常"><a href="#编译型异常" class="headerlink" title="编译型异常"></a>编译型异常</h3><p>代码有问题,命令有错误,事务中所有命令都不会被执行</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>其他命令可以正常执行,错误命令抛出异常</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><ul><li>悲观锁 任何情况下都加锁</li><li>乐观锁 任何情况下都不加锁,更新数据的时候去判断一下在此期间是否有人修改过数据</li></ul><p>WATCH命令可以用作实现乐观锁</p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http包</title>
      <link href="/2023/07/21/http%E5%8C%85/"/>
      <url>/2023/07/21/http%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Go 语言中的 http 包提供了创建 http 服务或者访问 http 服务所需要的能力，不需要额外的依赖。在这篇文章中，我们会介绍这些功能的使用，以及看一下 http 包的设计思路。</p><span id="more"></span><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>http标准库的各个组成部分:</p><p>发送GET,HEAD,POST,POSTFORM请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">&quot;http://example.com/form&quot;</span>, url.Values&#123;<span class="string">&quot;key&quot;</span>:&#123;<span class="string">&quot;Value&quot;</span>&#125;, <span class="string">&quot;id&quot;</span>:&#123;<span class="string">&quot;123&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>客户端必须在结束时关闭响应体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle err</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := io.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可以配置客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">    CheckRedirect: redirectPolicyFunc,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := client.Get(<span class="string">&quot;http://example.com&quot;</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://example.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">req.Header.Add(<span class="string">&quot;If-None-Match&quot;</span>, <span class="string">`W/&quot;wyzzy&quot;`</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>为了控制代理，TLS配置，等配置，可以创建一个Transport:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tr := &amp;http.Transport &#123;</span><br><span class="line">    MaxIdleConns:<span class="number">10</span>,</span><br><span class="line">    IdleConnTimeout:<span class="number">30</span> * time.Second,</span><br><span class="line">    DisableCompression:<span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line">resp, err := client.Get(<span class="string">&quot;http://example.com&quot;</span>)</span><br></pre></td></tr></table></figure><p>ListenAndServe函数使用给定的地址和处理函数开启一个HTTP服务器。handler通常是nil，意味着使用DefaultServeMux。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/foo&quot;</span>, fooHandler)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/bar&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, %q&quot;</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure><p>使用定制的服务器来控制服务器的行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := &amp;http.Server &#123;</span><br><span class="line">    Addr:<span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">    Handler:myHandler,</span><br><span class="line">    ReadTimeout:<span class="number">10</span> * time.Second,</span><br><span class="line">    WriteTimeout:<span class="number">10</span> * time.Second,</span><br><span class="line">    MaxHeaderBytes:<span class="number">1</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">log.Fatal(s.ListenAndServe())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统课程设计</title>
      <link href="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>文章中的代码我都放在了github上，<a href="https://github.com/napleon-liu/XD-SE-OSE-2023spring">有需要的可以自取</a> 。记得点个star。</p><span id="more"></span><h1 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h1><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><p>编写shell脚本，该脚本接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “自己学号的后3位    MYFILE”。</p><p>这个比较简单，稍微了解一下shell编程和常用命令就能写出来，不多赘述。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># read_write.sh</span></span><br><span class="line">filename=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">flag=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$flag</span>&quot;</span> = 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 读取文件内容</span></span><br><span class="line">  content=$(<span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;文件内容：<span class="variable">$content</span>&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$flag</span>&quot;</span> = 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 获取学号后3位</span></span><br><span class="line">  student_id=<span class="string">&quot;21069100223&quot;</span></span><br><span class="line">  last_three_digits=<span class="string">&quot;<span class="variable">$&#123;student_id: -3&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 写入文件</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$last_three_digits</span>    MYFILE&quot;</span> &gt; <span class="string">&quot;<span class="variable">$filename</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;已成功写入文件：<span class="variable">$filename</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;无效的标志位!请使用0(读)或1(写)作为第二个参数。&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>保存文件，在Terminal中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -x read_write.sh # 给予可执行权限</span><br><span class="line">./read_write_file.sh &quot;test.txt&quot; 1</span><br></pre></td></tr></table></figure><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80shell%E4%BB%A3%E7%A0%81%E6%88%AA%E5%9B%BE.jpg"></p><h2 id="系统调用编程"><a href="#系统调用编程" class="headerlink" title="系统调用编程"></a>系统调用编程</h2><p>使用系统调用open read write,完成一个C语言程序：该程序接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “学号 MYFILE”，其中学号填为自己的学号。改造上面的程序，使用semaphore，并利用该程序生成2个进程，这两个进程写同一个文件，要求：a.互斥写，即只有一个进程写完后，才能让另一个进程写; b. 一个进程写入内容：“自己学号的后3位PROC1   MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2   MYFILE2”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 1024</span></span><br><span class="line"><span class="type">sem_t</span> semaphore;</span><br><span class="line"><span class="type">int</span> fd; <span class="comment">// 文件描述符</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semaphore);</span><br><span class="line">    <span class="comment">// printf(&quot;223PROC1   MYFILE1\n&quot;);</span></span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC1   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">print2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semaphore);</span><br><span class="line">    <span class="comment">// printf(&quot;223PROC2   MYFILE2\n&quot;);</span></span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC2   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @brief 接受两个参数，第一个参数是读写的文件名，第二个参数是标志位，0代表读，1代表写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 参数检测</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: &lt;filename&gt; &lt;flag&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_WRONLY | O_APPEND)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fail to open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[MAX_SIZE];</span><br><span class="line">        read(fd, buf, MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写信息 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_init(&amp;semaphore, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化信号量</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            print2(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print1(<span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="comment">// 父进程</span></span><br><span class="line"></span><br><span class="line">        sem_destroy(&amp;semaphore); <span class="comment">// 销毁信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: 0:read, 1:write.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译文件的命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc read_write.c -o read_write -pthread</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg"></p><h2 id="内核编程"><a href="#内核编程" class="headerlink" title="内核编程"></a>内核编程</h2><p>添加一个系统调用, 该系统调用接受两个参数：参数1：以整型数表示的自己学号的后3位；参数2：flag，取值为0或1，若为0，该系统调用的返回值为参数1的个位。若为1。该系统调用的返回值为参数1的十位。</p><p>我用的版本是Ubuntu 20.04。源是阿里源。</p><p>本文参考<a href="https://moefactory.com/3041.moe">https://moefactory.com/3041.moe</a></p><!--more--><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><h2 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h2><p>官网地址： <a href="https://www.kernel.org/">https://www.kernel.org/</a> 。本文写作时最新的稳定版为6.2.11。</p><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc make libncurses5-dev openssl libssl-dev build-essential pkg-config libc6-dev bison flex libelf-dev</span><br></pre></td></tr></table></figure><p>系统调用<code>os_exp</code>，添加在<code>kernel/sys.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(os_exp, <span class="type">long</span> <span class="type">long</span>, id) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mod = (id % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1000000</span> : <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">return</span> id % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>include/linux/syscalls.h</code>中添加系统调用的函数声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_os_exp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> id)</span>;</span><br></pre></td></tr></table></figure><p>最后在系统调用表中添加我们自定义的系统调用。<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中，在335号系统调用后添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">335</span>commonos_exp__x64_sys_os_exp</span><br></pre></td></tr></table></figure><p><code>&lt;系统调用编号&gt; common &lt;系统调用名称&gt; &lt;系统调用的函数名称&gt;</code>，这四列之间请使用制表符分隔。注意系统调用的函数名称是有格式要求的，格式为 <code>__x64_sys_&lt;函数名&gt;</code>，而这里的函数名就是之前我们自己拟定的 <code>os_exp</code>。</p><h2 id="配置内核代码"><a href="#配置内核代码" class="headerlink" title="配置内核代码"></a>配置内核代码</h2><p>在下载下来的内核目录下，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -v /boot/config-$(uname -r) .config</span><br></pre></td></tr></table></figure><p>目的是为了使我们编译的内核的配置与当前环境的配置一致。</p><p>修改.config文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vim .config</span></span><br><span class="line"><span class="comment">// / CONFIG_SYSTEM_TRUSTED_KEYS = &quot;&quot;</span></span><br><span class="line"><span class="comment">// / CONFIG_SYSTEM_REVOCATION_KEYS = &quot;&quot;</span></span><br><span class="line"><span class="comment">// 结果如下图所示</span></span><br></pre></td></tr></table></figure><img src="C:\Users\79893\blog\source\images\os_expe\.config配置文件.jpg" alt="config配置文件" style="zoom:67%;" /><h2 id="编译安装内核"><a href="#编译安装内核" class="headerlink" title="编译安装内核"></a>编译安装内核</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -j4</span><br></pre></td></tr></table></figure><p>分配线程的数目取决于虚拟机的CPU核数以及每个核的线程数，比如我的虚拟机是双核双线程的，因此选择4线程编译。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装内核模块命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure><p>安装内核：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>重启系统并查看新内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="测试系统调用"><a href="#测试系统调用" class="headerlink" title="测试系统调用"></a>测试系统调用</h2><h2 id="驱动编程"><a href="#驱动编程" class="headerlink" title="驱动编程"></a>驱动编程</h2><p>完善1.7节设备驱动例子中的字符设备程序，使之满足以下功能：</p><p>  i.安装设备后从设备中读出字符串为自己学号的后3位；</p><p> ii.  设备支持每次写入字符不超过1024个，超过部分被丢弃，并且能够保存最近一次修改前的rwbuf里的内容。</p><p> iii. 设备支持系统调用ioctl(int d, int req,…),共支持设置三种模式：a. 清除设备中写入的字符串; b. 从设备中读时，读出的是最近一次修改前的内容。 c. 从设备中读时，读出的是最新内容</p><p> iv. 设备关闭前不能被多次打开；</p><p> v. 自己编写测试程序，验证以上功能</p><p>此处参考了小梦学长的 <a href="https://moefactory.com/3041.moe">博客</a>。为了实现读最新内容和读最近一次修改前的内容两种模式，我设置了两个缓冲区。一个存储最新的信息，另一个在更新信息时保存new_buf的信息，以实现保存最近一次修改前的内容。具体细节参见代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rwbuf.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于 ioctl 命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_CLEAR 0x909090</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDOLD 0x909091</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDNEW 0x909092</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;rwbuf&quot;</span></span></span><br><span class="line"><span class="comment">// 锁机制，保证只能有一个打开的设备。0 为未打开，1 为已打开</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inuse = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 缓冲区最大长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RWBUF_MAX_SIZE 1024</span></span><br><span class="line"><span class="comment">// 模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mode = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 缓冲区，初始值需要是学号以便能在设备安装后立刻读出</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> rwbuf_old[RWBUF_MAX_SIZE] = <span class="string">&quot;223&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> old_cnt = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> rwbuf_new[RWBUF_MAX_SIZE] = <span class="string">&quot;223&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> new_cnt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (inuse == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inuse = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// increase the use count in struct module</span></span><br><span class="line">        try_module_get(THIS_MODULE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    inuse = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// decrease the use count in struct module</span></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将内容写入到设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放待写入内容的缓冲区</span></span><br><span class="line"><span class="comment"> * @return 正数表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(rwbuf_old, rwbuf_new);</span><br><span class="line">        old_cnt = new_cnt;</span><br><span class="line">        new_cnt = count &gt; RWBUF_MAX_SIZE ? RWBUF_MAX_SIZE : count;</span><br><span class="line">        copy_from_user(rwbuf_new, buf, new_cnt);</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write successful. After writing, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> new_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write failed. Length of string to be written = %lu\n&quot;</span>, count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从设备中读取内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放读取内容的缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">1</span>) &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_new, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_old, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ioctl 操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param arg 要执行的操作</span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">rwbuf_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] [RW_CLEAR:%x],[cmd:%x]\n&quot;</span>, RW_CLEAR, cmd);</span><br><span class="line">    <span class="keyword">if</span> (cmd == RW_CLEAR) <span class="comment">// 清空缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        new_cnt = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl successful. After doing ioctl, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDNEW) &#123;</span><br><span class="line">        mode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDOLD) &#123;</span><br><span class="line">        mode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 无效命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl failed. new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rwbuf_fops</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        open : rwbuf_open,</span><br><span class="line">        release : rwbuf_release,</span><br><span class="line">        read : rwbuf_read,</span><br><span class="line">        write : rwbuf_write,</span><br><span class="line">        unlocked_ioctl : rwbuf_ioctl</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rwbuf_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Initializing device...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 60: 主设备号，与创建 /dev/rwbuf 时使用的对应</span></span><br><span class="line">    <span class="comment">// DEVICE_NAME: 上面定义的设备名称</span></span><br><span class="line">    <span class="comment">// &amp;rwbuf_fops: VFS 相关</span></span><br><span class="line">    ret = register_chrdev(<span class="number">60</span>, DEVICE_NAME, &amp;rwbuf_fops);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rwbuf_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev(<span class="number">60</span>, DEVICE_NAME);</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Uninstall successful\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rwbuf_init);</span><br><span class="line">module_exit(rwbuf_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>设备的Makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"><span class="comment"># 指定编译器</span></span><br><span class="line">CC := gcc</span><br><span class="line"><span class="comment"># 内核源代码目录</span></span><br><span class="line">KERNEL_DIR := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="comment"># 模块名称</span></span><br><span class="line">MODULE_NAME := rwbuf</span><br><span class="line"><span class="comment"># 模块源文件</span></span><br><span class="line">MODULE_SRC := rwbuf.c</span><br><span class="line"><span class="comment"># 构建目标</span></span><br><span class="line">obj-m := <span class="variable">$(MODULE_NAME)</span>.o</span><br><span class="line"><span class="comment"># 构建规则</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="comment"># 清理规则</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure><p>测试前需要安装设备，在terminal中依次键入以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mknod</span> /dev/rwbuf c 60 0 <span class="comment"># 创建虚拟字符设备</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /dev/rwbuf <span class="comment"># 修改设备权限</span></span><br><span class="line">sudo insmod rwbuf.ko <span class="comment"># 安装设备驱动</span></span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;/dev/rwbuf&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_CLEAR 0x909090</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDOLD 0x909091</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDNEW 0x909092</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    fd = open(DEVICE_NAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open device error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRead student id...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">3</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read old_buf. Then write aaaaa into buf.\n&quot;</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;aaaaa&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    ioctl(fd, RW_RDOLD);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">3</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Old Buffer:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd, RW_RDNEW);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">5</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;New Buffer:%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Write 1100 &#x27;a&#x27;...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(fd, <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>, <span class="number">1100</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nRead from device...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">1024</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[<span class="number">1023</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nClear device...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, RW_CLEAR) == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device closed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并执行设备驱动，结果如下图。</p><p>测试结果：</p><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/base%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%9C.jpg"></p><p>最后记得卸载设备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod rwbuf</span><br></pre></td></tr></table></figure><h1 id="中级题目"><a href="#中级题目" class="headerlink" title="中级题目"></a>中级题目</h1><h2 id="Shell编程-1"><a href="#Shell编程-1" class="headerlink" title="Shell编程"></a>Shell编程</h2><p>编写一个脚本，能够生成完成基础题目（即：“编写shell脚本，该脚本接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “自己学号的后3位     MYFILE”。“）的脚本，并且自动执行该生成的脚本（执行功能：写入文件）。</p><p>写一个脚本，将基础题目的脚本作为内容写进文件里，然后自动执行生成的文件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># Set the filename and flag variables</span><br><span class="line">filename=<span class="string">&quot;$1&quot;</span></span><br><span class="line">flag=<span class="string">&quot;$2&quot;</span></span><br><span class="line"></span><br><span class="line"># Generate the script content</span><br><span class="line">script_content=$(cat &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">#!/bin/bash</span><br><span class="line">filename=<span class="string">&quot;$1&quot;</span></span><br><span class="line">flag=<span class="string">&quot;$2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$flag&quot;</span> = <span class="string">&quot;0&quot;</span> ]; then</span><br><span class="line">  # Read file content</span><br><span class="line">  content=$(cat <span class="string">&quot;$filename&quot;</span>)</span><br><span class="line">  echo <span class="string">&quot;文件内容：$content&quot;</span></span><br><span class="line">elif [ <span class="string">&quot;$flag&quot;</span> = <span class="string">&quot;1&quot;</span> ]; then</span><br><span class="line">  # Get the last three digits of the student ID</span><br><span class="line">  student_id=<span class="string">&quot;21069100223&quot;</span></span><br><span class="line">  last_three_digits=<span class="string">&quot;$&#123;student_id: -3&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">  # Write to the file</span><br><span class="line">  echo <span class="string">&quot;$last_three_digits    MYFILE&quot;</span> &gt; <span class="string">&quot;$filename&quot;</span></span><br><span class="line">  echo <span class="string">&quot;已成功写入文件：$filename&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  echo <span class="string">&quot;无效的标志位!请使用0(读)或1(写)作为第二个参数。&quot;</span></span><br><span class="line">fi</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Write the script content to a file</span><br><span class="line">script_filename=<span class="string">&quot;rw.sh&quot;</span></span><br><span class="line">echo <span class="string">&quot;$script_content&quot;</span> &gt; <span class="string">&quot;$script_filename&quot;</span></span><br><span class="line">echo <span class="string">&quot;Generated script: $script_filename&quot;</span></span><br><span class="line"></span><br><span class="line"># Make the generated script executable</span><br><span class="line">chmod +x <span class="string">&quot;$script_filename&quot;</span></span><br><span class="line"></span><br><span class="line"># Execute the generated script with the provided arguments</span><br><span class="line">./<span class="string">&quot;$script_filename&quot;</span> <span class="string">&quot;$filename&quot;</span> <span class="string">&quot;$flag&quot;</span></span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/medium_shell%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg" alt="medium_shell测试结果"></p><h2 id="系统调用编程-1"><a href="#系统调用编程-1" class="headerlink" title="系统调用编程"></a>系统调用编程</h2><p>对于基础题目系统调用编程中的第2题（即：使用semaphore，并利用该程序生成2个进程（注意：非线程），这两个进程写同一个文件，要求：a.互斥写，即只有一个进程写完后，才能让另一个进程写; b. 一个进程写入内容：“自己学号的后3位PROC1 MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2   MYFILE2”），将该程序的semaphore替换成使用strict alternation算法的忙等待互斥锁完成。</p><p>严格轮换法参考课本。我申请了一块共享内存作为lock，对于父子进程均可见。注意，write具有原子性，我身边有很多人使用一个全局变量作为lock，但是write时直接将一句话写进文件里，这样结果看起来是对的，实际上并没有实现互斥。因为fork()出的子进程是父进程的一个副本，二者的地址空间不同，所以lock不是共享的，实现父子进程之间的通信的方法有很多，可以参考我的另外一篇 <a href="https://www.napleon.cn/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">博客</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read_write.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> fd; <span class="comment">// 文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* shm_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (shm_addr[<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC1   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shm_addr[<span class="number">0</span>] = <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (shm_addr[<span class="number">0</span>] == <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* content = <span class="string">&quot;223PROC2   MYFILE1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++) &#123;</span><br><span class="line">        write(fd, content + i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shm_addr[<span class="number">0</span>] = <span class="number">1</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span>* mode = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="comment">// char* filename = &quot;myfile.txt&quot;;</span></span><br><span class="line">    <span class="comment">// char* mode = &quot;1&quot;;</span></span><br><span class="line"></span><br><span class="line">    key = ftok(<span class="string">&quot;./&quot;</span>, <span class="number">2023</span>);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmid = shmget(key, MAX_SIZE, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm_addr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 连接共享内存</span></span><br><span class="line">    shm_addr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename, O_RDONLY)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fail to open %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(mode, <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buf[MAX_SIZE];</span><br><span class="line">        read(fd, buf, MAX_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写信息 </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            print2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            print1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: 0:read, 1:write.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc read_write.c -o read_write -lpthread</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/medium%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg"></p><h2 id="内核编程-1"><a href="#内核编程-1" class="headerlink" title="内核编程"></a>内核编程</h2><ol><li><p>对于基础题目中的内核编程题（即： 添加一个系统调用, 该系统调用接受两个参数：参数1：以整型数表示的自己学号的后3位；参数2：flag，取值为0或1，若为0，该系统调用的返回值为参数1的个位。若为1。该系统调用的返回值为参数1的十位），进行修改，修改如下：</p><ol><li>声明一个内核全局变量gOSE, 该系统首先将参数1的值赋给gOSE，并且，对于参数2：flag，取值为0或1，若为0，将gOSE的值按位取反，后赋值给gOSE，然后返回gOSE的值；若为1，则将gOSE的值与0Xffffffff异或，后赋值给gOSE，然后返回gOSE的值；</li><li>加入内核互斥锁，使得两个进程在调用该系统调用时，能够做到互斥访问gOSE。</li></ol></li><li><p>对于中级题目中系统调用编程的第1题，给出strict alternation算法中turn变量的虚地址，并且给出该变量的物理地址。</p></li></ol><h2 id="驱动编程-1"><a href="#驱动编程-1" class="headerlink" title="驱动编程"></a>驱动编程</h2><p>对基础题目中的驱动编程进行修改增加mmap接口，使其能够通过mmap读写rwbuf中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于 ioctl 命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_CLEAR 0x909090</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDOLD 0x909091</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RW_RDNEW 0x909092</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;rwbuf&quot;</span></span></span><br><span class="line"><span class="comment">// 锁机制，保证只能有一个打开的设备。0 为未打开，1 为已打开</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inuse = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 缓冲区最大长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RWBUF_MAX_SIZE 1024</span></span><br><span class="line"><span class="comment">// 模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mode = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 缓冲区，初始值需要是学号以便能在设备安装后立刻读出</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* rwbuf_old;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> old_cnt = <span class="number">3</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* rwbuf_new;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> new_cnt = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (inuse == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inuse = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// increase the use count in struct module</span></span><br><span class="line">        try_module_get(THIS_MODULE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return 0 表示成功 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    inuse = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// decrease the use count in struct module</span></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将内容写入到设备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放待写入内容的缓冲区</span></span><br><span class="line"><span class="comment"> * @return 正数表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// rwbuf_old = rwbuf_new;</span></span><br><span class="line">        <span class="built_in">strcpy</span>(rwbuf_old, rwbuf_new);</span><br><span class="line">        old_cnt = new_cnt;</span><br><span class="line">        new_cnt = count &gt; RWBUF_MAX_SIZE ? RWBUF_MAX_SIZE : count;</span><br><span class="line">        copy_from_user(rwbuf_new, buf, new_cnt);</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write successful. After writing, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> new_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Write failed. Length of string to be written = %lu\n&quot;</span>, count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从设备中读取内容</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param buf 存放读取内容的缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rwbuf_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">1</span>) &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_new, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copy_to_user(buf, rwbuf_old, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printk(&quot;[rwbuf] Read successful. After reading, new_cnt = %d\n&quot;, new_cnt);</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ioctl 操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param arg 要执行的操作</span></span><br><span class="line"><span class="comment"> * @return 0 表示成功，-1 表示错误 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">rwbuf_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] [RW_CLEAR:%x],[cmd:%x]\n&quot;</span>, RW_CLEAR, cmd);</span><br><span class="line">    <span class="keyword">if</span> (cmd == RW_CLEAR) <span class="comment">// 清空缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        new_cnt = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl successful. After doing ioctl, new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDNEW) &#123;</span><br><span class="line">        mode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == RW_RDOLD) &#123;</span><br><span class="line">        mode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 无效命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Do ioctl failed. new_cnt = %d\n&quot;</span>, new_cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rwbuf_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pfn_start = (virt_to_phys(rwbuf_new) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> virt_start = (<span class="type">unsigned</span> <span class="type">long</span>)rwbuf_new + offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line">    <span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, </span><br><span class="line">        size,</span><br><span class="line">        vma-&gt;vm_page_prot</span><br><span class="line">    ))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">rwbuf_fops</span> =</span></span><br><span class="line">    &#123;</span><br><span class="line">        open : rwbuf_open,</span><br><span class="line">        release : rwbuf_release,</span><br><span class="line">        read : rwbuf_read,</span><br><span class="line">        write : rwbuf_write,</span><br><span class="line">        unlocked_ioctl : rwbuf_ioctl,</span><br><span class="line">        mmap : rwbuf_mmap,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rwbuf_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    rwbuf_new = kzalloc(RWBUF_MAX_SIZE, GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strcpy</span>(rwbuf_new, <span class="string">&quot;223\0&quot;</span>);</span><br><span class="line">    rwbuf_old = kzalloc(RWBUF_MAX_SIZE, GFP_KERNEL);</span><br><span class="line">    <span class="built_in">strcpy</span>(rwbuf_old, <span class="string">&quot;223\0&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Initializing device...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 60: 主设备号，与创建 /dev/rwbuf 时使用的对应</span></span><br><span class="line">    <span class="comment">// DEVICE_NAME: 上面定义的设备名称</span></span><br><span class="line">    <span class="comment">// &amp;rwbuf_fops: VFS 相关</span></span><br><span class="line">    ret = register_chrdev(<span class="number">60</span>, DEVICE_NAME, &amp;rwbuf_fops);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(<span class="string">&quot;[rwbuf] Initialize failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rwbuf_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_chrdev(<span class="number">60</span>, DEVICE_NAME);</span><br><span class="line">    printk(<span class="string">&quot;[rwbuf] Uninstall successful\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(rwbuf_init);</span><br><span class="line">module_exit(rwbuf_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/rwbuf&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *mapped_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开设备文件</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    fd = open(DEVICE_PATH, O_RDWR);</span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open device&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 mmap 映射</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    mapped_addr = mmap(<span class="number">0</span>, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// mapped_addr[1023] = &#x27;\0&#x27;;</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (mapped_addr == MAP_FAILED) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to mmap&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 从映射的内存读取数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Device Data: %s\n&quot;</span>, mapped_addr);</span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="comment">// 修改映射的内存中的数据</span></span><br><span class="line">    <span class="comment">// mapped_addr[0] = &#x27;A&#x27;;</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    <span class="keyword">if</span> (munmap(mapped_addr, MAP_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to unmap&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;hello\n&quot;);</span></span><br><span class="line">    <span class="comment">// 关闭设备文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/medium%E9%A9%B1%E5%8A%A8%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%9C.jpg" alt="medium驱动编程结果"></p><h1 id="高级题目"><a href="#高级题目" class="headerlink" title="高级题目"></a>高级题目</h1><h2 id="制作启动盘-选做"><a href="#制作启动盘-选做" class="headerlink" title="制作启动盘(选做)"></a>制作启动盘(选做)</h2><ol><li><p>使用麒麟桌面操作系统内核（只能使用麒麟桌面操作系统内核），在不重新编译内核的情况下，制作USB启动盘，使得计算机从USB盘上启动，加载initial ramdisk，并能够自动运行一个shell脚本，该shell 脚本在中端上输出自己学号的后·3位。</p></li><li><p>对上题的USB启动盘进行修改（注意，无论何种修改，只能使用麒麟桌面操作系统内核），并不能重新编译内核），能够将USB启动盘作为根目录进行挂载，并且从USB盘上启动后，能够自动运行一个shell脚本，该shell 脚本在将自己学号的后·3位写入USB启动盘上的一个文件中。</p></li></ol><h2 id="系统调用编程-必做"><a href="#系统调用编程-必做" class="headerlink" title="系统调用编程(必做)"></a>系统调用编程(必做)</h2><p>编写一个程序，并利用该程序生成2个进程（注意，非线程），这两个进程写同一个文件，要求：</p><p>a.互斥写，即只有一个进程写完后，才能让另一个进程写;  该互斥实现使用忙等待锁完成互斥。该忙等待锁在x86平台上必须使用xchg和cmp汇编语句完成，如果在arm平台上，必须使用ldrex和strex 和cmp完成，并且，对于锁变量lock，lock为1时表示锁被释放，lock为0时表示上锁。</p><p>b. 一个进程写入内容：“自己学号的后3位PROC1 MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2 MYFILE2”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSZ 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_BUSY 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_FREE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span>* lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_acquire</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *lock)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = LOCK_BUSY;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;xchg %0, %1&quot;</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;=r&quot;</span>(tmp)   <span class="comment">//输出部分</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;m&quot;</span>(*lock), <span class="string">&quot;0&quot;</span>(tmp)    <span class="comment">//输入部分</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp == LOCK_BUSY) &#123;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;pause&quot;</span>:::<span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">        tmp = *lock;</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;xchg %0, %1&quot;</span></span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;=r&quot;</span>(tmp)</span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;m&quot;</span>(*lock), <span class="string">&quot;0&quot;</span>(tmp)</span></span><br><span class="line"><span class="params">                     : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_release</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> *lock)</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %1, %0&quot;</span></span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;+m&quot;</span>(*lock) : <span class="string">&quot;r&quot;</span>(LOCK_FREE)</span></span><br><span class="line"><span class="params">                 : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_proc</span><span class="params">(<span class="type">char</span>* fname, <span class="type">char</span>* msg)</span>&#123;</span><br><span class="line">    lock_acquire(lock);</span><br><span class="line">    <span class="type">int</span> fd = open(fname, O_CREAT|O_WRONLY|O_APPEND, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write(fd, msg, strlen(msg));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(msg); i++) &#123;</span><br><span class="line">        write(fd, msg+i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    lock_release(lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> shmid;</span><br><span class="line"><span class="type">key_t</span> key;</span><br><span class="line"></span><br><span class="line">key = ftok(<span class="string">&quot;./&quot;</span>, <span class="number">2015</span>);</span><br><span class="line"><span class="keyword">if</span> (key == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shmid = shmget(key, BUFSZ, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (shmid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    lock = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 连接共享内存</span></span><br><span class="line">    *lock = LOCK_FREE;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">char</span> fname[] = <span class="string">&quot;./test.txt&quot;</span>;</span><br><span class="line">    <span class="type">char</span> msg1[<span class="number">128</span>], msg2[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(msg1, <span class="string">&quot;223PROC1 MYFILE1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(msg2, <span class="string">&quot;223PROC2 MYFILE2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pid) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//子进程写文件1</span></span><br><span class="line">        write_proc(fname, msg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程写文件2</span></span><br><span class="line">        write_proc(fname, msg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="驱动编程-选做"><a href="#驱动编程-选做" class="headerlink" title="驱动编程(选做)"></a>驱动编程(选做)</h2><ol><li>安装Qemu虚机，注：在线资料中“已安装Qemu的虚机”中解压后是一个vmware虚机，这里称其为VW虚机。VW虚机里面已经安装好Qemu，并且也安装了一个Qemu 虚机，这里称其为QVM，QVM自身并不携带gcc，仅作为示例。VWroot密码是1，QVM的root密码是0；同学可在QVM基础上补完gcc等编程环境，或重新装一个完整的QVM。</li><li>对于给出edu设备（它是Qemu虚拟化出的一个设备）的驱动，请对其进行改进，使其能够完成DMA数据传输；并且编写相关的用户态下测试程序进行证明。</li></ol><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20230823150236256.png" alt="image-20230823150236256"></p><p>老师将已安装的虚拟机分卷压缩上传在了课程资料中，将其下载至同一文件夹下。</p><p><img src="/image-20230823150410505.png" alt="image-20230823150410505"></p><p>使用7zip，打开下载路径，选中其中一个分卷压缩文件，点击左上方“文件”选项点击合并文件。</p><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20230823150521859.png" alt="image-20230823150521859"></p><p>7zip会自动检测出所有分卷压缩文件，选择导出路径导出合并压缩文件。</p><p>使用VMstation创建新的虚拟机时依次点击</p><ol><li>自定义</li><li>默认</li><li>稍后安装操作系统</li><li>Linux-&gt;Ubuntu</li><li>自定义虚拟机名称与路径</li><li>自定义处理器数量</li><li>自定义内存大小</li><li>默认网络类型</li><li>默认IO类型</li><li>默认磁盘类型</li><li>使用现有虚拟磁盘</li><li>选择使用现有的虚拟磁盘。</li><li>保持现有格式</li></ol><p><img src="/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20230823151052274.png" alt="image-20230823151052274"></p><p>选择TestEnvQemu.vmdk文件。</p><p><img src="/image-20230823151201071.png" alt="image-20230823151201071"></p><p>至此，学校提供的测试环境搭建完毕。</p><h3 id="编写edu设备"><a href="#编写edu设备" class="headerlink" title="编写edu设备"></a>编写edu设备</h3><p>打开虚拟机后，首先下载一个Markdown阅读器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@testenvqemu:/home/testenvqemu<span class="comment"># snap install typora</span></span><br></pre></td></tr></table></figure><h2 id="内核编程-选做"><a href="#内核编程-选做" class="headerlink" title="内核编程(选做)"></a>内核编程(选做)</h2><p>添加系统调用，根据传入的标志位，通过轮询方式、或DMA方式读取上述edu设备驱动程序的结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下进程间通信</title>
      <link href="/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>进程的地址空间是相互独立的，因此进程之间交互数据必须需要专门的通信机制。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux下的主要IPC手段：</p><ul><li>管道pipe。数据只能单方面流通， 只能在父子进程间进行。</li><li>有名管道named pipe。半双工通信方式，可用于非父子进程通信。</li><li>信号量semophore 进程间或不同进程间的同步手段。</li><li>消息队列message queue。消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息量少，管道只能承载无格式字节流以及缓冲区大小受限的缺点。</li><li>信号signal</li><li>共享内存shared memory。 映射一段能被其他进程访问的内存。共享内存能被一个进程创建但是被多个进程访问。</li><li>套接字socket。 可用于不同机器间的通信。</li></ul><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道是一个特殊的文件，这个文件只存在与内存中。创建管道时，系统为管道分配一个页面作为数据缓冲区，进行管道通信的两个进程通过读写这个缓冲区来实现通信。</p><h2 id="dup与dup2"><a href="#dup与dup2" class="headerlink" title="dup与dup2"></a>dup与dup2</h2><p>在子进程调用exec函数执行另外一个程序时，可以将子进程的文件描述符重定向到标准输入，新执行的程序能够从标准输入获取数据，实际上是从父进程获取输入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回文件描述符，为当前可用文件描述符的最小数值。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 利用参数newfd指定欲返回的文件描述符。如果newfd指定的文件描述符已经打开，先将其关闭，然后将oldfd指定的文件描述符赋值给该参数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><h1 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h1><p>有名管道(named pipe或FIFO)。FIFO不同与管道之处在于它提供了一个路径名与之关联，以FIFO的形式存储与文件系统中。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>可以用shell创建或者在程序中用系统函数创建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">path: 有名管道的路径名</span></span><br><span class="line"><span class="comment">mod: 模式</span></span><br><span class="line"><span class="comment">dev: 设备值</span></span><br><span class="line"><span class="comment">return: 成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mod, <span class="type">dev_t</span> dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写方式"><a href="#读写方式" class="headerlink" title="读写方式"></a>读写方式</h2><p>有名管道是一个硬盘上的文件，使用前需要先open()将其打开。</p><p><strong>有名管道是存在与硬盘上的文件，而管道是存在与内存中的特殊文件</strong></p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>消息队列是存放在内核中的一个消息链表，每个消息队列用消息队列标识符标识。与管道不同的是消息队列存放在内核中，只有在内核重启或者显式的删除一个消息队列时，该消息队列才会被真正的删除。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="消息缓冲结构"><a href="#消息缓冲结构" class="headerlink" title="消息缓冲结构"></a>消息缓冲结构</h3><p>向消息队列发送消息时，必须组成合理的数据 结构。Linux系统定义了一个模板数据结构msgbuf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/msg.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="msqid-ds内核数据结构"><a href="#msqid-ds内核数据结构" class="headerlink" title="msqid_ds内核数据结构"></a>msqid_ds内核数据结构</h3><p>Linux中，每个消息队列都维护着一个结构体msqid_ds。该结构体保存着当前消息队列的状态信息。该结构体定义在linux&#x2F;msg.h中，具体定义如下：</p><h3 id="ipc-perm内核数据结构"><a href="#ipc-perm内核数据结构" class="headerlink" title="ipc_perm内核数据结构"></a>ipc_perm内核数据结构</h3><p>ipc_perm保存着消息队列的一些重要信息，比如消息队列关联的键值，消息队列的用户ID、组ID。</p><h2 id="创建与读写"><a href="#创建与读写" class="headerlink" title="创建与读写"></a>创建与读写</h2><h3 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h3><p>消息队列是随着内核的存在而存在的，每个消息队列在系统范围内对应唯一的键值。通过ftok函数获取该键值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">ket_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写消息队列"><a href="#读写消息队列" class="headerlink" title="读写消息队列"></a>读写消息队列</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> mapflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> <span class="type">int</span> msgtyp, itn msgflg)</span>;</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量大于等于0时表示可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数目。</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">sem_perm</span>;</span><span class="comment">// 对信号进行操作的许可权</span></span><br><span class="line">    <span class="type">__kernel_time_t</span>sem_otime;<span class="comment">// 对信号进行操作的最后时间</span></span><br><span class="line">    <span class="type">__kernel_time_t</span>em_ctime;<span class="comment">// 对信号进行修改的最后时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span>*<span class="title">sembase</span>;</span><span class="comment">// 指向第一个信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span><span class="title">sem_pending</span>;</span><span class="comment">// 等待处理的挂起操作</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span><span class="comment">// 撤销的请求</span></span><br><span class="line">    ushortsem_nsems;<span class="comment">// 数组中的信号数目</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><p>共享内存是分配一块能被其他进程访问的内存。每个内存块在内核中维护这一个内部结构shmid_ds(和消息队列，信号量)一样，该结构定义在头文件linux&#x2F;shm.h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">shm_perm</span>;</span></span><br><span class="line">    <span class="type">int</span>shm_segsz;</span><br><span class="line">    ******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存区的创建"><a href="#共享内存区的创建" class="headerlink" title="共享内存区的创建"></a>共享内存区的创建</h2><p>shmget来创建一个共享内存区。原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">key: ftok得到的键值</span></span><br><span class="line"><span class="comment">size: 以字节为单位指定内存的大小</span></span><br><span class="line"><span class="comment">shmflg: 操作标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><h2 id="共享内存区的操作"><a href="#共享内存区的操作" class="headerlink" title="共享内存区的操作"></a>共享内存区的操作</h2><p>在使用共享内存区之前，必须通过shmat将其附加到进程的地址空间。进程就与共享内存建立了连接。shmat调用成功后会返回一个指向共享内存区的指针，使用该指针即可访问共享内存区，如果失败返回-1.代码原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shimid: shmget的返回值</span></span><br><span class="line"><span class="comment">shmaddr: 共享内存的附加点，一般设为空，由MMU自动管理</span></span><br><span class="line"><span class="comment">shmflg: 存取权限标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p>当进程结束使用共享内存区，要通过函数shmdt断开与共享内存区的连接。该函数声明在sys&#x2F;shm.h中代码原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure><p>Linux对共享内存区的控制是通过调用函数shmctl来完成的，该函数定义在头文件sys&#x2F;shm.h中，原型代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shimid: 共享内存区的标识符</span></span><br><span class="line"><span class="comment">buf:指向shmid_ds结构体的指针</span></span><br><span class="line"><span class="comment">cmd：操作标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shimid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈wsl</title>
      <link href="/2023/05/03/%E6%B5%85%E8%B0%88wsl/"/>
      <url>/2023/05/03/%E6%B5%85%E8%B0%88wsl/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍了WSL的工作原理。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Windows Subsystem for Linux（WSL）是一个用于在本地运行linux二进制可执行文件（ELF格式）的<strong>兼容层</strong>。</p><p>在软件工程领域，兼容层是一个允许面向旧或异质系统的二进制文件运行在特定主机系统上的接口。这意味着将面向异质系统的系统调用转换为面向主机系统。有些库会面向异质系统，这通常是为主机系统提供运行异质二进制文件的能力。而硬件兼容层工具允许硬件仿真。</p><p>与虚拟机相比，wsl没有虚拟硬件的过程，而是直接在windows上虚拟一个linux内核，模拟linux系统调用，以运行linux执行文件。</p><p>可以简单的将它理解为可以运行linux可执行文件的、类似于powershell的shell，具有<strong>互操作性</strong>（在linux中执行windows命令，在windows中执行linux命令）。</p><h1 id="虚拟机技术的原理"><a href="#虚拟机技术的原理" class="headerlink" title="虚拟机技术的原理"></a>虚拟机技术的原理</h1><p><img src="/2023/05/03/%E6%B5%85%E8%B0%88wsl/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="img"></p><h2 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h2><p>Hypervisor（虚拟机管理器）是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor）。</p><h1 id="WSL原理"><a href="#WSL原理" class="headerlink" title="WSL原理"></a>WSL原理</h1><h2 id="wsl组件"><a href="#wsl组件" class="headerlink" title="wsl组件"></a>wsl组件</h2><p><img src="/2023/05/03/%E6%B5%85%E8%B0%88wsl/wsl%E7%BB%84%E6%88%90.png" alt="wsl组成"></p><p>wsl实现的组件涉及到了用户和内核模式。在Windows NT内核模式中，LXCore，LXSS这两个驱动提供了linux内核调用的实现，即将linux调用转化为对应的windows NT内核调用；还提供了两种文件系统：VolFs（挂载在&#x2F;目录上，支持linux文件系统所有特性）和DriverFs（挂载在&#x2F;mnt&#x2F;c，&#x2F;mnt&#x2F;d等等windows分区，主要为了支持系统间的互操作性）；驱动还会模拟内核的行为，对linux进程进行调度。</p><p>在用户模式下，windows提供了一种特殊的进程类型：Pico进程，来支持linux进程的运行。windows会 “放松” 对该类型进程的控制，主要交由linux虚拟内核调用和管理，即隔离性（因此需要系统的支持，低版本的系统不能使用wls的功能）。pico会将ELF二进制可执行文件装入到自己的地址空间，然后执行在linux虚拟内核提供的兼容层上。一个pico对应一个linux进程，并且pico进程也是windows的一种特殊进程，因此你可以在任务管理器上看到linux进程。</p><p>无论exe还是elf格式的二进制文件，原理上都可以在同架构的cpu上执行，只是结构不同操作系统不能解析罢了。而Pico能够解析ELF格式的二进制文件，只需要linux虚拟内核能够提供正确的系统调用，就能够运行大部分linux命令。</p><p>LXSS管理服务主要用于协调windows和linux进程之间的关系，和给于Bash.exe（并不是shell，只是我们访问wsl的入口）调用linux命令的接口。所有的运行的linux进程都会被加入到叫Linux实例（应该有LXSS记录的）中，只有第一次请求访问linux进程时才会创建Linux实例，才会创建init进程；当window关机时，会自动关闭linux实例，即关闭linux所有进程。</p><p>也就是wsl不会随windows系统自启而自启，同时没有使用发行版的init进程，导致wsl中没有服务的存在。</p><h3 id="COM简介"><a href="#COM简介" class="headerlink" title="COM简介"></a>COM简介</h3><p>Microsoft 组件对象模型 (COM) 定义了一个二进制互操作性标准，用于创建在运行时交互的可重用软件库。 无需将它们编译到应用程序中即可使用 COM 库。 COM 是许多 Microsoft 产品和技术的基础，例如Windows 媒体播放器和Windows服务器。</p><h3 id="Pico-Process"><a href="#Pico-Process" class="headerlink" title="Pico Process"></a>Pico Process</h3><p>As part of Project Drawbridge, the Windows kernel introduced the concept of Pico processes and Pico drivers. Pico processes are OS processes without the trappings of OS services associated with subystems like a Win32 Process Environment Block (PEB). Furthermore, for a Pico process, system calls and user mode exceptions are dispatched to a paired driver.</p><p>Pico processes and drivers provide the foundation for the Windows Subsystem for Linux, which runs native unmodified Linux binaries by loading executable ELF binaries into a Pico process’s address space and executes them atop a Linux-compatible layer of syscalls.</p><h3 id="System-Call"><a href="#System-Call" class="headerlink" title="System Call"></a>System Call</h3><p>WSL executes unmodified Linux ELF64 binaries by virtualizing a Linux kernel interface on top of the Windows NT kernel. </p><p>On native Linux, when a syscall is made from a user mode executable it is handled by the Linux kernel. On WSL, when a syscall is made from the same executable the Windows NT kernel forwards the request to lxcore.sys. Where possible, lxcore.sys translates the Linux syscall to the equivalent Windows NT call which in turn does the heavy lifting. Where there is no reasonable mapping the Windows kernel mode driver must service the request directly.</p><h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><p>File system support in WSL was designed to meet two goals.</p><ol><li>Provide an environment that supports the full fidelity of Linux file systems</li><li>Allow interoperability with drives and files in Windows</li></ol><p>The Windows Subsystem for Linux provides virtual file system support similar to the real Linux kernel. Two file systems are used to provide access to files on the users system: VolFs and DriveFs.</p><h3 id="VolFs"><a href="#VolFs" class="headerlink" title="VolFs"></a>VolFs</h3><p>VolFs is a file system that provides full support for Linux file system features, including:</p><ul><li>Linux permissions that can be modified through operations such as chmod and chroot</li><li>Symbolic links to other files</li><li>File names with characters that are not normally legal in Windows file names</li><li>Case sensitivity</li></ul><p>Directories containing the Linux system, application files (&#x2F;etc, &#x2F;bin, &#x2F;usr, etc.), and users Linux home folder, all use VolFs.</p><p>Interoperability between Windows applications and files in VolFs is not supported</p><h2 id="wsl运行过程"><a href="#wsl运行过程" class="headerlink" title="wsl运行过程"></a>wsl运行过程</h2><p><img src="/2023/05/03/%E6%B5%85%E8%B0%88wsl/wsl%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="wsl运行过程"></p><p>一个正常完整的Linux系统的启动过程为：引导程序载入内核，内核初始化后载入init进程。init开启各项服务。</p><p>wsl并不是一个真正的系统，它是一个可以执行Linux ELF的程序。wsl的内核是虚拟内核，具有一定的隔离性。</p><p>wsl的工作流程为：windows自启结束并加载了LxCore&#x2F;LXSS两个驱动后，准备工作结束。当用户执行bash.exe时，创建linux实例，执行init<strong>服务进程</strong>。然后创建bash shell和另一个init进程，在本次会话结束时（关闭Bash.exe窗口）这两个进程结束。之后再通过Bash.exe连接wsl，都只会创建bash和右边的init进程。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>上述讲到了，wsl只有两种windows设计的文件系统：VolFs和DriverFs。其中VolFs文件系统主要是为了支持linux文件系统的全部特性，如linux的文件权限、符号链接、不同于windows的文件名、文件名大小写敏感等等。</p><p>而DriveFs主要是为了挂载windows的分区，并且实现互操作性而存在。实际上就是NTFS文件系统的包装，能够让NTFS在linux中使用，即使也提供了大部分linux文件系统特性，但是限制很多，如：</p><ul><li>文件目录权限全为777，实际上就算是root用户，在windows分区中也只有打开Base.exe命令拥有者的权限。说明普通用户使用root权限也不能修改c盘中大部分文件。</li><li>最好不要在windows下创建文件名只有大小写不同的文件，尽管NTFS支持了。</li><li>支持linux符号链接，为windows可执行文件创建符号链接时，注意添加后缀.exe。不要与windows的快捷方式混淆，它们目的一致，但结构不一致，不能在linux中使用。</li></ul><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul><li>并非所有系统调用都被实现。</li><li>WSL不能使用所有的硬件资源。例如，在wsl下不能访问GPU，重复性的计算只能通过CPU完成。</li><li>磁盘IO比原生Linux效率低。后果是，wsl下的编译会很慢。</li></ul><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="wsl1"><a href="#wsl1" class="headerlink" title="wsl1"></a>wsl1</h2><p>WSL 1的设计没有硬件模拟&#x2F;虚拟化（与coLinux等其他项目不同），WSL直接使用主机文件系统（通过VolFS和DrvFS）和硬件的某些部分，例如网络（Web服务器，用于例如，可以通过主机上配置的相同接口和IP地址进行访问，并且对使用需要管理权限的端口或已经被其他应用程序占用的端口共享相同的限制），这保证了互操作性。</p><p>即使从shell运行sudo，某些位置（例如系统文件夹）和配置的访问&#x2F;修改也受到限制。必须启动具有提升权限的实例才能获得“真正的sudo”并允许此类访问。</p><h2 id="wsl2"><a href="#wsl2" class="headerlink" title="wsl2"></a>wsl2</h2><h3 id="Hyper-V"><a href="#Hyper-V" class="headerlink" title="Hyper-V"></a>Hyper-V</h3><p>Microsoft的本地虚拟机管理系统。</p><p>基于Hyper-V的更高层次的虚拟化。</p><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Virtual_Private_Network_overview.svg/330px-Virtual_Private_Network_overview.svg.png" alt="img"></p><p><img src="https://picx.zhimg.com/v2-ceb0b790077a7a895faba61a1e5f3c95_720w.jpg?source=172ae18b" alt="VPN原理与简单应用"></p><p>VPN是通过使用专用线路或在现有网络上使用隧道协议创建一个虚拟的点对点连接而形成的。可从公共 <a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">Internet</a> 获得的 VPN可以提供<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91">广域网</a> (WAN) 的一些好处。 从用户的角度来看，可以远程访问专用网络中可用的资源。</p><p>正常网络通信时，所有网络请求都是通过我们的物理网卡直接发送出去。而VPN是客户端使用相应的VPN协议先与VPN服务器进行通信，成功连接后就在操作系统内建立一个虚拟网卡，一般来说默认PC上所有网络通信都从这虚拟网卡上进出，经过VPN服务器中转之后再到达目的地。</p><p>VPN有多种协议：OPENVPN、PPTP、L2TP&#x2F;IPSec、SSLVPN、IKEv2 VPN，Cisco VPN等。其中的PPTP和L2TP是明文传输协议。只负责传输，不负责加密。分别利用了MPPE和IPSec进行加密。</p><table><thead><tr><th align="left"></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png" alt="PPTP"></a></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/5.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/5.png" alt="L2TP/IPSec"></a></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/6.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/6.png" alt="PENVPN"></a></th></tr></thead><tbody><tr><td align="left">背景</td><td align="left">PPTP 是一个基于 PPP 的很基本的协议。PPTP 是微软 Windows 平台第一个支持的 VPN 协议。PPTP 标准并没有实际描述加密和授权特性，并且依赖于 PPP 协议的隧道来实现安全功能。</td><td align="left">L2TP 是一个在 IETF <a href="https://tools.ietf.org/html/rfc3193">RFC 3193</a> 中被正式标准化的高级协议。推荐在需要安全加密的地方用来替代 PPTP。</td><td align="left">OpenVPN 是一个高级的开源 VPN 解决方案，由 “OpenVPN technologies” 支持，并且已经成为开源网络领域里的事实标准。OpenVPN 使用成熟的 SSL&#x2F;TLS 加密协议。</td></tr><tr><td align="left">数据加密</td><td align="left">PPP 负载是使用微软点对点协议（Microsoft’s Point-to-Point Encryption protocol，<a href="https://en.wikipedia.org/wiki/Microsoft_Point-to-Point_Encryption">MPPE</a>）加密。MPPE 实现了 RSA <a href="https://en.wikipedia.org/wiki/RC4">RC4</a> 加密算法，并使用最长 128 位密钥。</td><td align="left">L2TP 负载使用标准的 IPSec 协议加密。在 <a href="https://tools.ietf.org/html/rfc4835">RFC 4835</a> 中指定了使用 3DES 或 AES 加密算法作为保密方式。</td><td align="left">OpenVPN 使用 <a href="https://en.wikipedia.org/wiki/OpenSSL">OpenSSL</a> 库来提供加密。OpenSSL 支持好几种不同的加密算法，如：3DES，AES，RC5 等。</td></tr><tr><td align="left">安装&#x2F;配置</td><td align="left">Windows 所有版本和大多数其他操作系统包括移动平台都内建了对 PPTP 的支持。PPTP 只需要一个用户名和密码，以及一个服务器地址，所以安装和配置相当简单。</td><td align="left">从 2000&#x2F;XP 起的所有 Windows 平台和 Mac OS X 10.3+ 都内建了 L2TP&#x2F;IPSec 的支持。大多数现代的移动平台比如 iPhone 和 Android 也有内建的客户端。</td><td align="left">OpenVPN 不包含在任何操作系统中，需要安装客户端软件，但安装也是相当简单，基本上 5 分钟可以完成。</td></tr><tr><td align="left">速度</td><td align="left">由于使用 128 位密钥，加密开销相比 OpenVPN 使用 256位密钥要小，所以速度感觉稍快一点，但这个差异微不足道。</td><td align="left">L2TP&#x2F;IPSec 将数据封装两次，所以相比其他竞争者效率稍低，速度也慢一些。</td><td align="left">当使用默认的 UDP 模式，OpenVPN 的表现是最佳的。</td></tr><tr><td align="left">端口</td><td align="left">PPTP 使用 TCP 1723 端口和 GRE（协议 47）。通过限制 GRE 协议，PPTP 可以轻易地被封锁。</td><td align="left">L2TP&#x2F;IPSec 使用 UDP 500 端口用来初始化密钥交换，使用协议 50 用来传输 IPSec 加密的数据（ ESP ），使用 UDP 1701 端口用来初始化 L2TP 的配置，还使用 UDP 4500 端口来穿过 NAT。L2TP&#x2F;IPSec 相比 OpenVPN 容易封锁，因为它依赖于固定的协议和端口。</td><td align="left">OpenVPN 可以很容易的配置为使用任何端口运行，也可以使用 UDP 或 TCP 协议。为了顺利穿越限制性的防火墙，可以将 OpenVPN 配置成使用 TCP 443 端口，因为这样就无法和标准的 HTTPS 无法区分，从而极难被封锁。</td></tr><tr><td align="left">稳定性&#x2F;兼容性</td><td align="left">PPTP 不如 OpenVPN 可靠，也不能像 OpenVPN 那样在不稳定网络中快速恢复。另外还有部分同 GRE 协议和一些路由器的兼容性问题。</td><td align="left">L2TP&#x2F;IPSec 比 OpenVPN 更复杂，为了使在 NAT 路由器下的设备可靠地使用，配置可以会更加困难。但是，只要服务器和客户端都支持 NAT 穿越，那么就没什么问题了。</td><td align="left">无论是无线网络、蜂窝网络，还是丢包和拥塞经常发生的不可靠网络，OpenVPN 都非常稳定、快速。对于那些相当不可以的连接，OpenVPN 有一个 TCP 模式可以使用，但是要牺牲一点速度，因为将 TCP 封装在 TCP 时效率不高。</td></tr><tr><td align="left">安全弱点</td><td align="left">微软实现的 PPTP 有一个严重的安全问题（<a href="https://www.schneier.com/paper-pptpv2.html">serious security vulnerabilities</a>）。对于词典攻击来说 MSCHAP-v2 是很脆弱的，并且 RC4 算法也会遭到“<a href="https://en.wikipedia.org/wiki/Bit-flipping_attack">位翻转攻击（ bit-flipping attack ）</a>”。如果保密是重要的，微软也强烈建议升级到 IPSec。</td><td align="left">IPSec 没有明显的漏洞，当和安全加密算法如 AES 一起使用时，被认为是很安全的。</td><td align="left">OpenVPN 也没有明显漏洞，当和安全加密算法如 AES 一起使用时，也被认为是相当安全的。</td></tr><tr><td align="left">客户端的兼容性</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android、DD-WRT</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android</td><td align="left">Windows、Mac OS X、Linux</td></tr><tr><td align="left">结论</td><td align="left">由于主要的安全漏洞，除了兼容性以外没有好的理由选择使用 PPTP。如果你的设备既不支持 L2TP&#x2F;IPSec 又不支持 OpenVPN，那么 PPTP 是一个合理的选择。如果关心快速安装和简易配置，那么 L2TP&#x2F;IPSec 值得考虑。</td><td align="left">L2TP&#x2F;IPSec 是优秀的，但相比 OpenVPN 的高效和杰出的稳定性要落后一点。如果你使用运行 iOS 或 Android 的移动设备，那么这就是最佳的选择，因为 OpenVPN 目前还不支持这些平台。另外，如果需要快速安装，L2TP&#x2F;IPSec 也是一个较佳的选择。</td><td align="left">对于所有的 Windows, Mac OS X 以及 Linux 桌面用户来说，OpenVPN 是最好的选择。OpenVPN 速度快，并且安全可信。但劣势是缺乏对移动设备的支持，另外还需要安装第三方客户端。</td></tr></tbody></table><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p><strong>代理</strong>（英语：Proxy）也称<strong>网络代理</strong>，是一种特殊的网络服务，允许一个<a href="https://zh.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF">终端</a>（一般为<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>）通过这个服务与另一个终端（一般为<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>）进行非直接的连接。一些<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3">网关</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，在一定程度上能够阻止<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB">网络攻击</a>。</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p><strong>安全外壳协议</strong>（Secure Shell Protocol，简称<strong>SSH</strong>）是一种加密的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">网络传输协议</a>，可在不安全的网络中为网络服务提供安全的传输环境[<a href="https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4251-1">1]</a>。SSH通过在网络中创建<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%89%E5%85%A8%E9%9A%A7%E9%81%93&action=edit&redlink=1">安全隧道</a>来实现SSH客户端与服务器之间的连接[<a href="https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4252-2">2]</a>。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">命令行界面</a>和远程执行命令。SSH使用频率最高的场合是<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F">类Unix系统</a>，但是<a href="https://zh.wikipedia.org/wiki/Windows">Windows</a>操作系统也能有限度地使用SSH。</p>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GORM学习笔记</title>
      <link href="/2023/04/24/GORM%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/04/24/GORM%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>GORM的特性：</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>模型是标准的struct</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID           <span class="type">uint</span></span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Email        *<span class="type">string</span></span><br><span class="line">  Age          <span class="type">uint8</span></span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  MemberNumber sql.NullString</span><br><span class="line">  ActivatedAt  sql.NullTime</span><br><span class="line">  CreatedAt    time.Time</span><br><span class="line">  UpdatedAt    time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>设置字段的权限位只读、只写、只创建、只更新或者被忽略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&quot;`</span>  <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:all&quot;`</span>        <span class="comment">// 通过 struct 读写、迁移会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:migration&quot;`</span>  <span class="comment">// 通过 struct 迁移会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h2><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 db 列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td align="left">serializer</td><td align="left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td align="left">size</td><td align="left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">将列定义为主键</td></tr><tr><td align="left">unique</td><td align="left">将列定义为唯一键</td></tr><tr><td align="left">default</td><td align="left">定义列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">scale</td><td align="left">指定列大小</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">autoIncrementIncrement</td><td align="left">自动步长，控制连续记录之间的间隔</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌入字段的列名前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td align="left">-</td><td align="left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td align="left">comment</td><td align="left">迁移时为字段添加注释</td></tr></tbody></table><h1 id="连接到数据库"><a href="#连接到数据库" class="headerlink" title="连接到数据库"></a>连接到数据库</h1><p>GORM官方支持的数据库类型有：MySQL, PostgreSQL, SQLite, SQL Server 和 TiDB</p><h2 id="连接到MySQL"><a href="#连接到MySQL" class="headerlink" title="连接到MySQL"></a>连接到MySQL</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dsn := <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL驱动程序提供了一些高级配置可以在初始化时使用，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">  DSN: <span class="string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <span class="comment">// DSN data source name</span></span><br><span class="line">  DefaultStringSize: <span class="number">256</span>, <span class="comment">// string 类型字段的默认长度</span></span><br><span class="line">  DisableDatetimePrecision: <span class="literal">true</span>, <span class="comment">// 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持</span></span><br><span class="line">  DontSupportRenameIndex: <span class="literal">true</span>, <span class="comment">// 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引</span></span><br><span class="line">  DontSupportRenameColumn: <span class="literal">true</span>, <span class="comment">// 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列</span></span><br><span class="line">  SkipInitializeWithVersion: <span class="literal">false</span>, <span class="comment">// 根据当前 MySQL 版本自动配置</span></span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建一条记录"><a href="#创建一条记录" class="headerlink" title="创建一条记录"></a>创建一条记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name:<span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line">result := db.Create(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="用所选字段创建记录"><a href="#用所选字段创建记录" class="headerlink" title="用所选字段创建记录"></a>用所选字段创建记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure><p>创建一条记录，忽略未指出的字段。</p><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定插入数量</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu_1&quot;</span>&#125;, ...., &#123;Name: <span class="string">&quot;jinzhu_10000&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch size 100</span></span><br><span class="line">db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="创建Hooks"><a href="#创建Hooks" class="headerlink" title="创建Hooks"></a>创建Hooks</h3><p>GORM提供的hooks有<code>BeforeSave</code>, <code>BeforeCreate</code>,<code>AfterSave</code>,<code>AfterCreate</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    u.UUID = uuid.New()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;invalid role&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询单个对象"><a href="#查询单个对象" class="headerlink" title="查询单个对象"></a>查询单个对象</h3><p>GORM提供了<code>First</code>, <code>Take</code>, <code>Last</code> 方法从数据库中检索对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询主键值第一的记录</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询一条记录</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询主键值倒数第一的记录</span></span><br><span class="line">db.Last(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="根据主键查询"><a href="#根据主键查询" class="headerlink" title="根据主键查询"></a>根据主键查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="字符串条件"><a href="#字符串条件" class="headerlink" title="字符串条件"></a>字符串条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取匹配的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;user)</span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-协程</title>
      <link href="/2023/04/24/go-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2023/04/24/go-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>协程是一种用户态的轻量级线程，又称微线程，协程的调度完全由用户控制。<strong>与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。</strong></p><span id="more"></span><h1 id="1-1-Goroutine"><a href="#1-1-Goroutine" class="headerlink" title="1.1 Goroutine"></a>1.1 Goroutine</h1><p>创建Goroutine的成本很小，它就是一段代码，一个函数入口。以及在堆上为其分配的一个堆栈（初始大小为4K，会随着程序的执行自动增长删除）。因此它非常廉价，Go应用程序可以并发运行数千个Goroutines。</p><ol><li>与线程相比，Goroutines非常便宜。它们只是堆栈大小的几个kb，堆栈可以根据应用程序的需要增长和收缩，而在线程的情况下，堆栈大小必须指定并且是固定的</li><li>Goroutines被多路复用到较少的OS线程。在一个程序中可能只有一个线程与数千个Goroutines。如果线程中的任何Goroutine都表示等待用户输入，则会创建另一个OS线程，剩下的Goroutines被转移到新的OS线程。所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的API。</li><li>当使用Goroutines访问共享内存时，通过设计的通道可以防止竞态条件发生。通道可以被认为是Goroutines通信的管道。</li></ol><h1 id="1-2-主goroutine"><a href="#1-2-主goroutine" class="headerlink" title="1.2 主goroutine"></a>1.2 主goroutine</h1><p>封装main函数的goroutine称为主goroutine。</p><p>主goroutine的任务：</p><ol><li>创建一个<code>defer</code>语句，用于在主goroutine退出时做必要的善后工作。</li><li>启动垃圾回收的gotoutine。</li><li>执行main包中的init函数</li><li>执行main函数。</li></ol><h1 id="1-3-goroutine与线程"><a href="#1-3-goroutine与线程" class="headerlink" title="1.3 goroutine与线程"></a>1.3 goroutine与线程</h1><h2 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h2><p>线程都具有一个固定大小的栈内存(2MB)，作为对比，一个goroutine在生命周期开始时只有一个很小的栈，典型情况为2KB。goroutine的栈不是固定大小的，它可以按需增大或者缩小，goroutine栈最大可达1GB。</p><h2 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h2><p>OS线程由内核调度器函数来调度，过程为：保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。这个过程较为缓慢。</p><p>Go有自己的调度器，采用<code>m:n</code>调度技术(复用&#x2F;调度m个goroutine到n个os线程)。Go调度器和内核调度器的工作类似，但Go调度器只需关心单个Go程序的goroutine调度问题。</p><p>os线程调度器由硬件时钟定期触发，Go调度器并非如此。它不需要切换到内核环境，所以调用一个goroutine比调度一个线程的成本低很多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-垃圾回收</title>
      <link href="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的垃圾回收机制"><a href="#常见的垃圾回收机制" class="headerlink" title="常见的垃圾回收机制"></a>常见的垃圾回收机制</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。</p><p>缺点：</p><ul><li>降低性能</li><li>循环引用</li></ul><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>该方法分为两步：</p><ol><li>标记从根节点开始迭代遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；</li><li>清除操作。对没有被标记的内存进行清除操作。</li></ol><p>缺点：</p><ul><li>启动垃圾回收时会暂停当前所用代码的执行。</li></ul><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>分代收集的基本思想是，将堆划分成两个或者多个称为代的空间。新创建的对象存放在称为新生代中，随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中，因此，新生代垃圾回收和老年代垃圾回收两种方式共存，分别对其空间中的对象进行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。</p><h1 id="Go的GC"><a href="#Go的GC" class="headerlink" title="Go的GC"></a>Go的GC</h1><p>go的垃圾回收机制是标记-清除算法。</p><ul><li>标记阶段。获取这些对象的状态信息。</li><li>清扫阶段。回收状态为unreachable的对象。</li></ul><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><ul><li>白色对象：潜在的垃圾，其内存可能被垃圾收集器回收；</li><li>黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象：活跃的对象，存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。</li></ul><p><img src="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%9C%BA%E5%88%B6.png"></p><p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p><p><img src="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%88%9D%E5%A7%8B%E6%B5%81%E7%A8%8B.png"></p><p>三色标记法的工作流程可以归纳成以下几个步骤：</p><ol><li>从灰色对象的集合中选择一个灰色对象将其标记成黑色。</li><li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li><li>重复上述两个步骤直到对象图中不存在灰色对象。</li></ol><p>当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：</p><p><img src="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E7%BB%93%E6%9E%9C.png"></p><p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p><p><img src="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%B9%B6%E5%8F%91%E9%94%99%E8%AF%AF%E6%A1%88%E4%BE%8B.png"></p><h2 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h2><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。</li></ul><p><img src="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E4%B8%8D%E5%8F%98%E5%BD%A2.png"></p><p>上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p><p>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p><p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色。</p><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p><h1 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h1><p>运行时通过runtime.gcTrigger.test方法决定是否要触发垃圾回收，当满足垃圾收集的基本条件时–允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同的方式触发不同的检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !meestats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">        <span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">        <span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">        <span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">        <span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">    <span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">        <span class="keyword">return</span> <span class="type">int32</span>(t.n - owrk.cycles) &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、gcTriggerHeap ：堆内存的分配达到达控制器计算的触发堆大小；<br>2、gcTriggerTime ：如果一定时间内没有触发，就会触发新的循环，该出发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟；<br>3、gcTriggerCycle：如果当前没有开启垃圾收集，则触发新的循环；<br>4、runtime.gcpercent 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集。</p><p>用于开启垃圾收集的方法 runtime.gcStart 会接收一个 runtime.gcTrigger 类型的结构，所有出现 runtime.gcTrigger 结构体的位置都是触发垃圾收集的代码：</p><ul><li>runtime.sysmon 和 runtime.forcegchelper ：后台运行定时检查和垃圾收集；</li><li>runtime.GC ：用户程序手动触发垃圾收集；</li><li>runtime.mallocgc ：申请内存时根据堆大小触发垃圾收集。</li></ul><p><img src="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL学习笔记</title>
      <link href="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。</p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p><h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">张老师</td></tr><tr><td align="left">2</td><td align="left">王老师</td></tr><tr><td align="left">3</td><td align="left">李老师</td></tr><tr><td align="left">4</td><td align="left">赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">一班</td></tr><tr><td align="left">2</td><td align="left">二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th align="left">id</th><th align="left">teacher_id</th><th align="left">class_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">2</td></tr><tr><td align="left">3</td><td align="left">2</td><td align="left">1</td></tr><tr><td align="left">4</td><td align="left">2</td><td align="left">2</td></tr><tr><td align="left">5</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left">6</td><td align="left">4</td><td align="left">2</td></tr></tbody></table><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">class_id</th><th align="left">name</th><th align="left">gender</th><th align="left">score</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">小明</td><td align="left">M</td><td align="left">90</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">小红</td><td align="left">F</td><td align="left">95</td></tr><tr><td align="left">3</td><td align="left">1</td><td align="left">小军</td><td align="left">M</td><td align="left">88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>要指定条件“分数在80分或以上的学生”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><p>条件查询的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;TABLENAME&gt; WHERE &lt;CONDITION&gt;</span><br><span class="line"># 多条件</span><br><span class="line"># 与条件： AND</span><br><span class="line"># 或条件： OR</span><br></pre></td></tr></table></figure><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>如果我们想查询某几列的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, name FROM students;</span><br><span class="line"># 返回某几列的数据</span><br><span class="line">SELECT C1, C2, C3</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序使用关键词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ORDER BY</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC;</span><br><span class="line"># 默认为升序</span><br></pre></td></tr></table></figure><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每页的最大数量 LIMIT PAGESIZE</span><br><span class="line"># 查询第n页的数据OFFSET PAGESIZE * (n-1)</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>SQL提供了一些函数用于统计数据，这些函数被称谓聚合函数。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SUM</td><td align="left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td align="left">AVG</td><td align="left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td align="left">MAX</td><td align="left">计算某一列的最大值</td></tr><tr><td align="left">MIN</td><td align="left">计算某一列的最小值</td></tr><tr><td align="left">COUNT</td><td align="left">统计记录数目</td></tr></tbody></table><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p><code>INSERT</code>语句的基本语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br><span class="line"># 例如</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br><span class="line"></span><br><span class="line"># 一次性添加多条数据</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line">  (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81);</span><br></pre></td></tr></table></figure><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>更新数据库中的记录，使用<code>UPDATE</code> 语句。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</span><br><span class="line">UPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><code>DELETE</code>语句的基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;TABLENAME&gt; WHERE...;</span><br><span class="line"></span><br><span class="line"># 例</span><br><span class="line">-- 删除id=1的记录</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">begin;# 开始事务</span><br><span class="line">commit; # 提交事务</span><br><span class="line">rollback; # 回滚</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from runoob_transaction_test;</span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; begin;  # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(5);</span><br><span class="line">Query OK, 1 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(6);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; commit; # 提交事务</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  select * from runoob_transaction_test;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; begin;    # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  insert into runoob_transaction_test values(7);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; rollback;   # 回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>事务是不可分割的最小操作单元，要么全部成功，要么全部失败</strong></p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><strong>事务完成时，必须使全部数据保持一致状态。</strong></p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</strong></p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p><strong>事务一旦提交或者回滚，它对数据库中数据的改变就是永久的</strong></p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>赃读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务隔离级别</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION</span><br><span class="line"></span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MYSQL体系结构"><a href="#MYSQL体系结构" class="headerlink" title="MYSQL体系结构"></a>MYSQL体系结构</h2><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801143250778.png" alt="image-20230801143250778"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 存储引擎是存储数据，建立索引，更新查询数据的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。 </p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>是MySQL的默认存储引擎。</p><p>特点：</p><ol><li>DML操作遵循ACID模型，支持事务。</li><li>行级锁，提高并发访问性能。</li><li>支持外键FOREIGN KEY约束，保证数据完整性与正确性。</li></ol><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MYSQL早期默认存储引擎。</p><p>特点：</p><ol><li>不支持事务。</li><li>不支持外键</li><li>访问速度快</li></ol><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>存储在内存中。</p><p>特点：</p><ol><li>访问快</li><li>不可持久化存储</li></ol><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801144732943.png" alt="image-20230801144732943"></p><h1 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h1><p> 高效获取数据的数据结构</p><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801150248347.png" alt="image-20230801150248347"></p><p>无索引进行全表扫描，有索引使用平衡二叉树进行查找。</p><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801150351654.png" alt="image-20230801150351654"></p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801150515948.png" alt="image-20230801150515948"></p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801151114273.png" alt="image-20230801151114273"></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230801151311818.png" alt="image-20230801151311818"></p><ol><li>所有数据都会出现在叶子结点</li><li>叶子结点形成一个链表</li></ol><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>采用一定的hash算法，将键值算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 </p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对表中主键创建的索引</td><td>唯一</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>列值不能重复</td><td>可以多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td></td><td>可以多个</td><td></td></tr><tr><td>全文索引</td><td>文本中的关键词，而不是比较索引中的值</td><td>可以多个</td><td>FULLTEXT</td></tr></tbody></table><h3 id="聚集索引和和二级索引"><a href="#聚集索引和和二级索引" class="headerlink" title="聚集索引和和二级索引"></a>聚集索引和和二级索引</h3><p><img src="/image-20230801152859817.png" alt="image-20230801152859817"></p><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是一张虚拟存在的表。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] VIEW AS SELECT语句 [WITH [ CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create or replace viem stu_v_1 as select id,name from student where id &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create view stu_v_1</span><br></pre></td></tr></table></figure><h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈mmap</title>
      <link href="/2023/04/09/%E6%B5%85%E8%B0%88mmap/"/>
      <url>/2023/04/09/%E6%B5%85%E8%B0%88mmap/</url>
      
        <content type="html"><![CDATA[<p>mmap能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。普通文件在被映射到进程地址空间后，进程可以像访问普通内存一样访问文件，不必通过read()、write()等系统调用来访问文件。</p><span id="more"></span><h4 id="mmap接口描述"><a href="#mmap接口描述" class="headerlink" title="mmap接口描述"></a>mmap接口描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// addr: 内存空间上的起始地址，一般为NULL，内核自动分配</span></span><br><span class="line"><span class="comment">// length: 字节数</span></span><br><span class="line"><span class="comment">// prot: 共享内存的访问权限</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PROT_READ</span></span><br><span class="line"><span class="comment">PROT_WRITE</span></span><br><span class="line"><span class="comment">PROT_EXEC</span></span><br><span class="line"><span class="comment">PROT_NONE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// flags:</span></span><br><span class="line"><span class="comment">// fd: 文件描述符</span></span><br><span class="line"><span class="comment">// offset: 偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值: 文件映射到进程空间的地址。</span></span><br></pre></td></tr></table></figure><h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><p>匿名映射没有对应的文件。fork()得到的子进程会拷贝父进程映射后的空间，同时也继承了mmap()的返回地址，从而实现进程间的通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名映射的例子</span></span><br><span class="line">ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">switch</span>(pid) &#123;</span><br><span class="line">    <span class="keyword">case</span> pid &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> pid = <span class="number">0</span>:</span><br><span class="line">        lock(ptr);</span><br><span class="line">        critical_section();</span><br><span class="line">        unlock(ptr);</span><br><span class="line">    <span class="keyword">case</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        lock(ptr);</span><br><span class="line">        critical_section();</span><br><span class="line">        unlock(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:并发</title>
      <link href="/2023/04/07/go-%E5%B9%B6%E5%8F%91/"/>
      <url>/2023/04/07/go-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该代码的运行结果不唯一，因为是两个goroutine在执行</span></span><br></pre></td></tr></table></figure><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>通道是用来传递数据的数据结构</p><p>通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于制定通道的方向，如果未指定方向，则为双向通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v<span class="comment">// 把v发送到ch</span></span><br><span class="line">v := &lt;-ch<span class="comment">// 从ch接收数据</span></span><br><span class="line"><span class="comment">// 并把值赋给v</span></span><br><span class="line"><span class="comment">// 声明一个通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p><strong>默认情况下，通道是不带缓冲区的。</strong></p><h2 id="带缓冲区的通道"><a href="#带缓冲区的通道" class="headerlink" title="带缓冲区的通道"></a>带缓冲区的通道</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><p>Go通过range关键字来实现遍历读取到的数据，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;- ch</span><br></pre></td></tr></table></figure><h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2><p>如果通道接收不到数据后ok就为false，这时通道就可以使用close函数来关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:方法与接口</title>
      <link href="/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="7-1-接口的定义"><a href="#7-1-接口的定义" class="headerlink" title="7.1 接口的定义"></a>7.1 接口的定义</h1><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。</p><p>Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab *itab;</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="7-2-接口使用实例"><a href="#7-2-接口使用实例" class="headerlink" title="7.2 接口使用实例"></a>7.2 接口使用实例</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;<span class="comment">// 定义了一个接口Phone, 有方法call()</span></span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;<span class="comment">// 接口Phone的一个实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;<span class="comment">// 接口Phone的一个实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone<span class="comment">// 利用接口实现多态</span></span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:数据</title>
      <link href="/2023/04/05/go-%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/05/go-%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-字符串string"><a href="#5-1-字符串string" class="headerlink" title="5.1 字符串string"></a>5.1 字符串string</h1><p><strong>字符串是不可变字符序列</strong></p><p><strong>默认值为空串，而不是空指针。</strong></p><p><strong>遍历</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&#x27;Hello, world&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// byte</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rune</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;%d ,[%c]\n&quot;</span>, i, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="5-2-数组"><a href="#5-2-数组" class="headerlink" title="5.2 数组"></a>5.2 数组</h1><h2 id="5-2-1-数组的初始化"><a href="#5-2-1-数组的初始化" class="headerlink" title="5.2.1 数组的初始化"></a>5.2.1 数组的初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">4</span>]<span class="type">int</span><span class="comment">// 元素自动初始成0</span></span><br><span class="line">    b := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">5</span>&#125;<span class="comment">// 剩余元素自动初始化成0</span></span><br><span class="line">    c := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">3</span>:<span class="number">10</span>&#125;;<span class="comment">// 指定索引位置</span></span><br><span class="line">    d := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">// 编译器确定数组长度</span></span><br><span class="line">    <span class="comment">// 在定义多维数组时， 仅第一维允许使用...</span></span><br><span class="line">    b := [...][<span class="number">2</span>]<span class="type">int</span> &#123;</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>&#125;, </span><br><span class="line">        &#123;<span class="number">30</span> ,<span class="number">40</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-2-指针"><a href="#5-2-2-指针" class="headerlink" title="5.2.2 指针"></a>5.2.2 指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">10</span> ,<span class="number">20</span></span><br><span class="line">    a := [...]*<span class="type">int</span>&#123;&amp;x, &amp;y&#125;<span class="comment">//指针数组</span></span><br><span class="line">    p = &amp;a<span class="comment">//数组指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-3-复制"><a href="#5-2-3-复制" class="headerlink" title="5.2.3 复制"></a>5.2.3 复制</h2><p><strong>与C数组变量隐式作为指针使用不同， Go数组是值类型，赋值和传参工作都会复制整个数组数据</strong></p><h1 id="5-3-切片"><a href="#5-3-切片" class="headerlink" title="5.3 切片"></a>5.3 切片</h1><p><strong>slice本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="keyword">type</span> slice strcut &#123;</span><br><span class="line">    arrary unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span><span class="comment">//限定可读的写元素数量</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span><span class="comment">// 切片所引用数组片段的真实长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切片本身是一个只读对象， 其工作机制类似数组指针的一种包装</strong></p><h2 id="5-3-1-创建切片对象"><a href="#5-3-1-创建切片对象" class="headerlink" title="5.3.1 创建切片对象"></a>5.3.1 创建切片对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)<span class="comment">//指定len, cap, 底层数组初始化成零值 </span></span><br><span class="line">    s2 := <span class="built_in">make</span>([<span class="type">int</span>], <span class="number">3</span>)<span class="comment">// 省略cap, 和len相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片是包装过的数组对象，用来代替数组减少值传递带来的开销</p><h1 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: <span class="number">1</span>, </span><br><span class="line">        <span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断key是否存在</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := m[<span class="string">&quot;d&quot;</span>]; ok &#123;</span><br><span class="line">        <span class="built_in">println</span>(v)</span><br><span class="line">    &#125;<span class="comment">// 访问不存在的键值， 默认返回零值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
