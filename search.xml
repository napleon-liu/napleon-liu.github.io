<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go-测试</title>
      <link href="/2023/05/16/go-%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/05/16/go-%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h1><p>编写测试和函数很类似， 其中有一些规则：</p><ul><li>程序需要在一个名为xxx_test.go 的文件中编写</li><li>测试函数的命名必须以单词Test开始</li><li>测试函数只接受一个参数t *testing.T</li></ul><h1 id="测试hello-go"><a href="#测试hello-go" class="headerlink" title="测试hello.go"></a>测试hello.go</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, world&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHello</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    got := Hello()</span><br><span class="line">    want := <span class="string">&quot;Hello, world&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解释这个测试之前，让我们先在终端运行 <code>go test</code>，它应该通过测试了！为了再次验证，可以尝试改变 <code>want</code> 字符串来破坏测试的结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下进程间通信</title>
      <link href="/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>进程的地址空间是相互独立的，因此进程之间交互数据必须需要专门的通信机制。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux下的主要IPC手段：</p><ul><li>管道pipe。数据只能单方面流通， 只能在父子进程间进行。</li><li>有名管道named pipe。半双工通信方式，可用于非父子进程通信。</li><li>信号量semophore 进程间或不同进程间的同步手段。</li><li>消息队列message queue。消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息量少，管道只能承载无格式字节流以及缓冲区大小受限的缺点。</li><li>信号signal</li><li>共享内存shared memory。 映射一段能被其他进程访问的内存。共享内存能被一个进程创建但是被多个进程访问。</li><li>套接字socket。 可用于不同机器间的通信。</li></ul><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道是一个特殊的文件，这个文件只存在与内存中。创建管道时，系统为管道分配一个页面作为数据缓冲区，进行管道通信的两个进程通过读写这个缓冲区来实现通信。</p><h2 id="dup与dup2"><a href="#dup与dup2" class="headerlink" title="dup与dup2"></a>dup与dup2</h2><p>在子进程调用exec函数执行另外一个程序时，可以将子进程的文件描述符重定向到标准输入，新执行的程序能够从标准输入获取数据，实际上是从父进程获取输入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回文件描述符，为当前可用文件描述符的最小数值。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 利用参数newfd指定欲返回的文件描述符。如果newfd指定的文件描述符已经打开，先将其关闭，然后将oldfd指定的文件描述符赋值给该参数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><h1 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h1><p>有名管道(named pipe或FIFO)。FIFO不同与管道之处在于它提供了一个路径名与之关联，以FIFO的形式存储与文件系统中。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p>可以用shell创建或者在程序中用系统函数创建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">path: 有名管道的路径名</span></span><br><span class="line"><span class="comment">mod: 模式</span></span><br><span class="line"><span class="comment">dev: 设备值</span></span><br><span class="line"><span class="comment">return: 成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mod, <span class="type">dev_t</span> dev)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写方式"><a href="#读写方式" class="headerlink" title="读写方式"></a>读写方式</h2><p>有名管道是一个硬盘上的文件，使用前需要先open()将其打开。</p><p><strong>有名管道是存在与硬盘上的文件，而管道是存在与内存中的特殊文件</strong></p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>消息队列是存放在内核中的一个消息链表，每个消息队列用消息队列标识符标识。与管道不同的是消息队列存放在内核中，只有在内核重启或者显式的删除一个消息队列时，该消息队列才会被真正的删除。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="消息缓冲结构"><a href="#消息缓冲结构" class="headerlink" title="消息缓冲结构"></a>消息缓冲结构</h3><p>向消息队列发送消息时，必须组成合理的数据 结构。Linux系统定义了一个模板数据结构msgbuf：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/msg.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="comment">// 消息内容</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="msqid-ds内核数据结构"><a href="#msqid-ds内核数据结构" class="headerlink" title="msqid_ds内核数据结构"></a>msqid_ds内核数据结构</h3><p>Linux中，每个消息队列都维护着一个结构体msqid_ds。该结构体保存着当前消息队列的状态信息。该结构体定义在linux&#x2F;msg.h中，具体定义如下：</p><h3 id="ipc-perm内核数据结构"><a href="#ipc-perm内核数据结构" class="headerlink" title="ipc_perm内核数据结构"></a>ipc_perm内核数据结构</h3><p>ipc_perm保存着消息队列的一些重要信息，比如消息队列关联的键值，消息队列的用户ID、组ID。</p><h2 id="创建与读写"><a href="#创建与读写" class="headerlink" title="创建与读写"></a>创建与读写</h2><h3 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h3><p>消息队列是随着内核的存在而存在的，每个消息队列在系统范围内对应唯一的键值。通过ftok函数获取该键值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">ket_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><h2 id="读写消息队列"><a href="#读写消息队列" class="headerlink" title="读写消息队列"></a>读写消息队列</h2><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> mapflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> <span class="type">int</span> msgtyp, itn msgflg)</span>;</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量大于等于0时表示可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数目。</p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">sem_perm</span>;</span><span class="comment">// 对信号进行操作的许可权</span></span><br><span class="line">    <span class="type">__kernel_time_t</span>sem_otime;<span class="comment">// 对信号进行操作的最后时间</span></span><br><span class="line">    <span class="type">__kernel_time_t</span>em_ctime;<span class="comment">// 对信号进行修改的最后时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span>*<span class="title">sembase</span>;</span><span class="comment">// 指向第一个信号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span><span class="title">sem_pending</span>;</span><span class="comment">// 等待处理的挂起操作</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span><span class="comment">// 撤销的请求</span></span><br><span class="line">    ushortsem_nsems;<span class="comment">// 数组中的信号数目</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><p>共享内存是分配一块能被其他进程访问的内存。每个内存块在内核中维护这一个内部结构shmid_ds(和消息队列，信号量)一样，该结构定义在头文件linux&#x2F;shm.h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span><span class="title">shm_perm</span>;</span></span><br><span class="line">    <span class="type">int</span>shm_segsz;</span><br><span class="line">    ******</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存区的创建"><a href="#共享内存区的创建" class="headerlink" title="共享内存区的创建"></a>共享内存区的创建</h2><p>shmget来创建一个共享内存区。原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">key: ftok得到的键值</span></span><br><span class="line"><span class="comment">size: 以字节为单位指定内存的大小</span></span><br><span class="line"><span class="comment">shmflg: 操作标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><h2 id="共享内存区的操作"><a href="#共享内存区的操作" class="headerlink" title="共享内存区的操作"></a>共享内存区的操作</h2><p>在使用共享内存区之前，必须通过shmat将其附加到进程的地址空间。进程就与共享内存建立了连接。shmat调用成功后会返回一个指向共享内存区的指针，使用该指针即可访问共享内存区，如果失败返回-1.代码原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shimid: shmget的返回值</span></span><br><span class="line"><span class="comment">shmaddr: 共享内存的附加点，一般设为空，由MMU自动管理</span></span><br><span class="line"><span class="comment">shmflg: 存取权限标志</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p>当进程结束使用共享内存区，要通过函数shmdt断开与共享内存区的连接。该函数声明在sys&#x2F;shm.h中代码原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure><p>Linux对共享内存区的控制是通过调用函数shmctl来完成的，该函数定义在头文件sys&#x2F;shm.h中，原型代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shimid: 共享内存区的标识符</span></span><br><span class="line"><span class="comment">buf:指向shmid_ds结构体的指针</span></span><br><span class="line"><span class="comment">cmd：操作标志位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shimid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>beego框架</title>
      <link href="/2023/05/07/beego%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/05/07/beego%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微内核与宏内核</title>
      <link href="/2023/05/06/%E5%BE%AE%E5%86%85%E6%A0%B8%E4%B8%8E%E5%AE%8F%E5%86%85%E6%A0%B8/"/>
      <url>/2023/05/06/%E5%BE%AE%E5%86%85%E6%A0%B8%E4%B8%8E%E5%AE%8F%E5%86%85%E6%A0%B8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈wsl</title>
      <link href="/2023/05/03/%E6%B5%85%E8%B0%88wsl/"/>
      <url>/2023/05/03/%E6%B5%85%E8%B0%88wsl/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍了WSL的工作原理。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Windows Subsystem for Linux（WSL）是一个用于在本地运行linux二进制可执行文件（ELF格式）的<strong>兼容层</strong>。</p><p>在软件工程领域，兼容层是一个允许面向旧或异质系统的二进制文件运行在特定主机系统上的接口。这意味着将面向异质系统的系统调用转换为面向主机系统。有些库会面向异质系统，这通常是为主机系统提供运行异质二进制文件的能力。而硬件兼容层工具允许硬件仿真。</p><p>与虚拟机相比，wsl没有虚拟硬件的过程，而是直接在windows上虚拟一个linux内核，模拟linux系统调用，以运行linux执行文件。</p><p>可以简单的将它理解为可以运行linux可执行文件的、类似于powershell的shell，具有<strong>互操作性</strong>（在linux中执行windows命令，在windows中执行linux命令）。</p><h1 id="虚拟机技术的原理"><a href="#虚拟机技术的原理" class="headerlink" title="虚拟机技术的原理"></a>虚拟机技术的原理</h1><p><img src="https://images2015.cnblogs.com/blog/544748/201605/544748-20160505132711466-1952982786.png" alt="img"></p><h2 id="Hypervisor"><a href="#Hypervisor" class="headerlink" title="Hypervisor"></a>Hypervisor</h2><p>Hypervisor（虚拟机管理器）是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor）。</p><h1 id="WSL原理"><a href="#WSL原理" class="headerlink" title="WSL原理"></a>WSL原理</h1><h2 id="wsl组件"><a href="#wsl组件" class="headerlink" title="wsl组件"></a>wsl组件</h2><p><img src="https://img-blog.csdnimg.cn/20190318232438143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pkYmRo,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>wsl实现的组件涉及到了用户和内核模式。在Windows NT内核模式中，LXCore，LXSS这两个驱动提供了linux内核调用的实现，即将linux调用转化为对应的windows NT内核调用；还提供了两种文件系统：VolFs（挂载在&#x2F;目录上，支持linux文件系统所有特性）和DriverFs（挂载在&#x2F;mnt&#x2F;c，&#x2F;mnt&#x2F;d等等windows分区，主要为了支持系统间的互操作性）；驱动还会模拟内核的行为，对linux进程进行调度。</p><p>在用户模式下，windows提供了一种特殊的进程类型：Pico进程，来支持linux进程的运行。windows会 “放松” 对该类型进程的控制，主要交由linux虚拟内核调用和管理，即隔离性（因此需要系统的支持，低版本的系统不能使用wls的功能）。pico会将ELF二进制可执行文件装入到自己的地址空间，然后执行在linux虚拟内核提供的兼容层上。一个pico对应一个linux进程，并且pico进程也是windows的一种特殊进程，因此你可以在任务管理器上看到linux进程。</p><p>无论exe还是elf格式的二进制文件，原理上都可以在同架构的cpu上执行，只是结构不同操作系统不能解析罢了。而Pico能够解析ELF格式的二进制文件，只需要linux虚拟内核能够提供正确的系统调用，就能够运行大部分linux命令。</p><p>LXSS管理服务主要用于协调windows和linux进程之间的关系，和给于Bash.exe（并不是shell，只是我们访问wsl的入口）调用linux命令的接口。所有的运行的linux进程都会被加入到叫Linux实例（应该有LXSS记录的）中，只有第一次请求访问linux进程时才会创建Linux实例，才会创建init进程；当window关机时，会自动关闭linux实例，即关闭linux所有进程。</p><p>也就是wsl不会随windows系统自启而自启，同时没有使用发行版的init进程，导致wsl中没有服务的存在。</p><h3 id="COM简介"><a href="#COM简介" class="headerlink" title="COM简介"></a>COM简介</h3><p>Microsoft 组件对象模型 (COM) 定义了一个二进制互操作性标准，用于创建在运行时交互的可重用软件库。 无需将它们编译到应用程序中即可使用 COM 库。 COM 是许多 Microsoft 产品和技术的基础，例如Windows 媒体播放器和Windows服务器。</p><h3 id="Pico-Process"><a href="#Pico-Process" class="headerlink" title="Pico Process"></a>Pico Process</h3><p>As part of Project Drawbridge, the Windows kernel introduced the concept of Pico processes and Pico drivers. Pico processes are OS processes without the trappings of OS services associated with subystems like a Win32 Process Environment Block (PEB). Furthermore, for a Pico process, system calls and user mode exceptions are dispatched to a paired driver.</p><p>Pico processes and drivers provide the foundation for the Windows Subsystem for Linux, which runs native unmodified Linux binaries by loading executable ELF binaries into a Pico process’s address space and executes them atop a Linux-compatible layer of syscalls.</p><h3 id="System-Call"><a href="#System-Call" class="headerlink" title="System Call"></a>System Call</h3><p>WSL executes unmodified Linux ELF64 binaries by virtualizing a Linux kernel interface on top of the Windows NT kernel. </p><p>On native Linux, when a syscall is made from a user mode executable it is handled by the Linux kernel. On WSL, when a syscall is made from the same executable the Windows NT kernel forwards the request to lxcore.sys. Where possible, lxcore.sys translates the Linux syscall to the equivalent Windows NT call which in turn does the heavy lifting. Where there is no reasonable mapping the Windows kernel mode driver must service the request directly.</p><h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><p>File system support in WSL was designed to meet two goals.</p><ol><li>Provide an environment that supports the full fidelity of Linux file systems</li><li>Allow interoperability with drives and files in Windows</li></ol><p>The Windows Subsystem for Linux provides virtual file system support similar to the real Linux kernel. Two file systems are used to provide access to files on the users system: VolFs and DriveFs.</p><h3 id="VolFs"><a href="#VolFs" class="headerlink" title="VolFs"></a>VolFs</h3><p>VolFs is a file system that provides full support for Linux file system features, including:</p><ul><li>Linux permissions that can be modified through operations such as chmod and chroot</li><li>Symbolic links to other files</li><li>File names with characters that are not normally legal in Windows file names</li><li>Case sensitivity</li></ul><p>Directories containing the Linux system, application files (&#x2F;etc, &#x2F;bin, &#x2F;usr, etc.), and users Linux home folder, all use VolFs.</p><p>Interoperability between Windows applications and files in VolFs is not supported</p><h2 id="wsl运行过程"><a href="#wsl运行过程" class="headerlink" title="wsl运行过程"></a>wsl运行过程</h2><p><img src="https://img-blog.csdnimg.cn/20190319003214476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pkYmRo,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>一个正常完整的Linux系统的启动过程为：引导程序载入内核，内核初始化后载入init进程。init开启各项服务。</p><p>wsl并不是一个真正的系统，它是一个可以执行Linux ELF的程序。wsl的内核是虚拟内核，具有一定的隔离性。</p><p>wsl的工作流程为：windows自启结束并加载了LxCore&#x2F;LXSS两个驱动后，准备工作结束。当用户执行bash.exe时，创建linux实例，执行init<strong>服务进程</strong>。然后创建bash shell和另一个init进程，在本次会话结束时（关闭Bash.exe窗口）这两个进程结束。之后再通过Bash.exe连接wsl，都只会创建bash和右边的init进程。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>上述讲到了，wsl只有两种windows设计的文件系统：VolFs和DriverFs。其中VolFs文件系统主要是为了支持linux文件系统的全部特性，如linux的文件权限、符号链接、不同于windows的文件名、文件名大小写敏感等等。</p><p>而DriveFs主要是为了挂载windows的分区，并且实现互操作性而存在。实际上就是NTFS文件系统的包装，能够让NTFS在linux中使用，即使也提供了大部分linux文件系统特性，但是限制很多，如：</p><ul><li>文件目录权限全为777，实际上就算是root用户，在windows分区中也只有打开Base.exe命令拥有者的权限。说明普通用户使用root权限也不能修改c盘中大部分文件。</li><li>最好不要在windows下创建文件名只有大小写不同的文件，尽管NTFS支持了。</li><li>支持linux符号链接，为windows可执行文件创建符号链接时，注意添加后缀.exe。不要与windows的快捷方式混淆，它们目的一致，但结构不一致，不能在linux中使用。</li></ul><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul><li>并非所有系统调用都被实现。</li><li>WSL不能使用所有的硬件资源。例如，在wsl下不能访问GPU，重复性的计算只能通过CPU完成。</li><li>磁盘IO比原生Linux效率低。后果是，wsl下的编译会很慢。</li></ul><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="wsl1"><a href="#wsl1" class="headerlink" title="wsl1"></a>wsl1</h2><p>WSL 1的设计没有硬件模拟&#x2F;虚拟化（与coLinux等其他项目不同），WSL直接使用主机文件系统（通过VolFS和DrvFS）和硬件的某些部分，例如网络（Web服务器，用于例如，可以通过主机上配置的相同接口和IP地址进行访问，并且对使用需要管理权限的端口或已经被其他应用程序占用的端口共享相同的限制），这保证了互操作性。</p><p>即使从shell运行sudo，某些位置（例如系统文件夹）和配置的访问&#x2F;修改也受到限制。必须启动具有提升权限的实例才能获得“真正的sudo”并允许此类访问。</p><h2 id="wsl2"><a href="#wsl2" class="headerlink" title="wsl2"></a>wsl2</h2><h3 id="Hyper-V"><a href="#Hyper-V" class="headerlink" title="Hyper-V"></a>Hyper-V</h3><p>Microsoft的本地虚拟机管理系统。</p><p>基于Hyper-V的更高层次的虚拟化。</p><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Virtual_Private_Network_overview.svg/330px-Virtual_Private_Network_overview.svg.png" alt="img"></p><p><img src="https://picx.zhimg.com/v2-ceb0b790077a7a895faba61a1e5f3c95_720w.jpg?source=172ae18b" alt="VPN原理与简单应用"></p><p>VPN是通过使用专用线路或在现有网络上使用隧道协议创建一个虚拟的点对点连接而形成的。可从公共 <a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">Internet</a> 获得的 VPN可以提供<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%9F%9F%E7%BD%91">广域网</a> (WAN) 的一些好处。 从用户的角度来看，可以远程访问专用网络中可用的资源。</p><p>正常网络通信时，所有网络请求都是通过我们的物理网卡直接发送出去。而VPN是客户端使用相应的VPN协议先与VPN服务器进行通信，成功连接后就在操作系统内建立一个虚拟网卡，一般来说默认PC上所有网络通信都从这虚拟网卡上进出，经过VPN服务器中转之后再到达目的地。</p><p>VPN有多种协议：OPENVPN、PPTP、L2TP&#x2F;IPSec、SSLVPN、IKEv2 VPN，Cisco VPN等。其中的PPTP和L2TP是明文传输协议。只负责传输，不负责加密。分别利用了MPPE和IPSec进行加密。</p><table><thead><tr><th align="left"></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png" alt="PPTP"></a></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/5.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/5.png" alt="L2TP/IPSec"></a></th><th align="left"><a href="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/6.png"><img src="https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/6.png" alt="PENVPN"></a></th></tr></thead><tbody><tr><td align="left">背景</td><td align="left">PPTP 是一个基于 PPP 的很基本的协议。PPTP 是微软 Windows 平台第一个支持的 VPN 协议。PPTP 标准并没有实际描述加密和授权特性，并且依赖于 PPP 协议的隧道来实现安全功能。</td><td align="left">L2TP 是一个在 IETF <a href="https://tools.ietf.org/html/rfc3193">RFC 3193</a> 中被正式标准化的高级协议。推荐在需要安全加密的地方用来替代 PPTP。</td><td align="left">OpenVPN 是一个高级的开源 VPN 解决方案，由 “OpenVPN technologies” 支持，并且已经成为开源网络领域里的事实标准。OpenVPN 使用成熟的 SSL&#x2F;TLS 加密协议。</td></tr><tr><td align="left">数据加密</td><td align="left">PPP 负载是使用微软点对点协议（Microsoft’s Point-to-Point Encryption protocol，<a href="https://en.wikipedia.org/wiki/Microsoft_Point-to-Point_Encryption">MPPE</a>）加密。MPPE 实现了 RSA <a href="https://en.wikipedia.org/wiki/RC4">RC4</a> 加密算法，并使用最长 128 位密钥。</td><td align="left">L2TP 负载使用标准的 IPSec 协议加密。在 <a href="https://tools.ietf.org/html/rfc4835">RFC 4835</a> 中指定了使用 3DES 或 AES 加密算法作为保密方式。</td><td align="left">OpenVPN 使用 <a href="https://en.wikipedia.org/wiki/OpenSSL">OpenSSL</a> 库来提供加密。OpenSSL 支持好几种不同的加密算法，如：3DES，AES，RC5 等。</td></tr><tr><td align="left">安装&#x2F;配置</td><td align="left">Windows 所有版本和大多数其他操作系统包括移动平台都内建了对 PPTP 的支持。PPTP 只需要一个用户名和密码，以及一个服务器地址，所以安装和配置相当简单。</td><td align="left">从 2000&#x2F;XP 起的所有 Windows 平台和 Mac OS X 10.3+ 都内建了 L2TP&#x2F;IPSec 的支持。大多数现代的移动平台比如 iPhone 和 Android 也有内建的客户端。</td><td align="left">OpenVPN 不包含在任何操作系统中，需要安装客户端软件，但安装也是相当简单，基本上 5 分钟可以完成。</td></tr><tr><td align="left">速度</td><td align="left">由于使用 128 位密钥，加密开销相比 OpenVPN 使用 256位密钥要小，所以速度感觉稍快一点，但这个差异微不足道。</td><td align="left">L2TP&#x2F;IPSec 将数据封装两次，所以相比其他竞争者效率稍低，速度也慢一些。</td><td align="left">当使用默认的 UDP 模式，OpenVPN 的表现是最佳的。</td></tr><tr><td align="left">端口</td><td align="left">PPTP 使用 TCP 1723 端口和 GRE（协议 47）。通过限制 GRE 协议，PPTP 可以轻易地被封锁。</td><td align="left">L2TP&#x2F;IPSec 使用 UDP 500 端口用来初始化密钥交换，使用协议 50 用来传输 IPSec 加密的数据（ ESP ），使用 UDP 1701 端口用来初始化 L2TP 的配置，还使用 UDP 4500 端口来穿过 NAT。L2TP&#x2F;IPSec 相比 OpenVPN 容易封锁，因为它依赖于固定的协议和端口。</td><td align="left">OpenVPN 可以很容易的配置为使用任何端口运行，也可以使用 UDP 或 TCP 协议。为了顺利穿越限制性的防火墙，可以将 OpenVPN 配置成使用 TCP 443 端口，因为这样就无法和标准的 HTTPS 无法区分，从而极难被封锁。</td></tr><tr><td align="left">稳定性&#x2F;兼容性</td><td align="left">PPTP 不如 OpenVPN 可靠，也不能像 OpenVPN 那样在不稳定网络中快速恢复。另外还有部分同 GRE 协议和一些路由器的兼容性问题。</td><td align="left">L2TP&#x2F;IPSec 比 OpenVPN 更复杂，为了使在 NAT 路由器下的设备可靠地使用，配置可以会更加困难。但是，只要服务器和客户端都支持 NAT 穿越，那么就没什么问题了。</td><td align="left">无论是无线网络、蜂窝网络，还是丢包和拥塞经常发生的不可靠网络，OpenVPN 都非常稳定、快速。对于那些相当不可以的连接，OpenVPN 有一个 TCP 模式可以使用，但是要牺牲一点速度，因为将 TCP 封装在 TCP 时效率不高。</td></tr><tr><td align="left">安全弱点</td><td align="left">微软实现的 PPTP 有一个严重的安全问题（<a href="https://www.schneier.com/paper-pptpv2.html">serious security vulnerabilities</a>）。对于词典攻击来说 MSCHAP-v2 是很脆弱的，并且 RC4 算法也会遭到“<a href="https://en.wikipedia.org/wiki/Bit-flipping_attack">位翻转攻击（ bit-flipping attack ）</a>”。如果保密是重要的，微软也强烈建议升级到 IPSec。</td><td align="left">IPSec 没有明显的漏洞，当和安全加密算法如 AES 一起使用时，被认为是很安全的。</td><td align="left">OpenVPN 也没有明显漏洞，当和安全加密算法如 AES 一起使用时，也被认为是相当安全的。</td></tr><tr><td align="left">客户端的兼容性</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android、DD-WRT</td><td align="left">Windows、Mac OS X、Linux、Apple iOS、Android</td><td align="left">Windows、Mac OS X、Linux</td></tr><tr><td align="left">结论</td><td align="left">由于主要的安全漏洞，除了兼容性以外没有好的理由选择使用 PPTP。如果你的设备既不支持 L2TP&#x2F;IPSec 又不支持 OpenVPN，那么 PPTP 是一个合理的选择。如果关心快速安装和简易配置，那么 L2TP&#x2F;IPSec 值得考虑。</td><td align="left">L2TP&#x2F;IPSec 是优秀的，但相比 OpenVPN 的高效和杰出的稳定性要落后一点。如果你使用运行 iOS 或 Android 的移动设备，那么这就是最佳的选择，因为 OpenVPN 目前还不支持这些平台。另外，如果需要快速安装，L2TP&#x2F;IPSec 也是一个较佳的选择。</td><td align="left">对于所有的 Windows, Mac OS X 以及 Linux 桌面用户来说，OpenVPN 是最好的选择。OpenVPN 速度快，并且安全可信。但劣势是缺乏对移动设备的支持，另外还需要安装第三方客户端。</td></tr></tbody></table><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p><strong>代理</strong>（英语：Proxy）也称<strong>网络代理</strong>，是一种特殊的网络服务，允许一个<a href="https://zh.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF">终端</a>（一般为<a href="https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>）通过这个服务与另一个终端（一般为<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>）进行非直接的连接。一些<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3">网关</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，在一定程度上能够阻止<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB">网络攻击</a>。</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p><strong>安全外壳协议</strong>（Secure Shell Protocol，简称<strong>SSH</strong>）是一种加密的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">网络传输协议</a>，可在不安全的网络中为网络服务提供安全的传输环境[<a href="https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4251-1">1]</a>。SSH通过在网络中创建<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AE%89%E5%85%A8%E9%9A%A7%E9%81%93&action=edit&redlink=1">安全隧道</a>来实现SSH客户端与服务器之间的连接[<a href="https://zh.wikipedia.org/wiki/Secure_Shell#cite_note-rfc4252-2">2]</a>。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">命令行界面</a>和远程执行命令。SSH使用频率最高的场合是<a href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F">类Unix系统</a>，但是<a href="https://zh.wikipedia.org/wiki/Windows">Windows</a>操作系统也能有限度地使用SSH。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GORM学习笔记</title>
      <link href="/2023/04/24/GORM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/24/GORM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>GORM的特性：</p><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>模型是标准的struct</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID           <span class="type">uint</span></span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Email        *<span class="type">string</span></span><br><span class="line">  Age          <span class="type">uint8</span></span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  MemberNumber sql.NullString</span><br><span class="line">  ActivatedAt  sql.NullTime</span><br><span class="line">  CreatedAt    time.Time</span><br><span class="line">  UpdatedAt    time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>设置字段的权限位只读、只写、只创建、只更新或者被忽略</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:create&quot;`</span> <span class="comment">// 允许读和创建</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:update&quot;`</span> <span class="comment">// 允许读和更新</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-&quot;`</span>        <span class="comment">// 允许读和写（创建和更新）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;&lt;-:false&quot;`</span>  <span class="comment">// 允许读，禁止写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;&quot;`</span>        <span class="comment">// 只读（除非有自定义配置，否则禁止写）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;;&lt;-:create&quot;`</span> <span class="comment">// 允许读和写</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&gt;:false;&lt;-:create&quot;`</span> <span class="comment">// 仅创建（禁止从 db 读）</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-&quot;`</span>  <span class="comment">// 通过 struct 读写会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:all&quot;`</span>        <span class="comment">// 通过 struct 读写、迁移会忽略该字段</span></span><br><span class="line">  Name <span class="type">string</span> <span class="string">`gorm:&quot;-:migration&quot;`</span>  <span class="comment">// 通过 struct 迁移会忽略该字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h2><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 db 列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td align="left">serializer</td><td align="left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td align="left">size</td><td align="left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">将列定义为主键</td></tr><tr><td align="left">unique</td><td align="left">将列定义为唯一键</td></tr><tr><td align="left">default</td><td align="left">定义列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">scale</td><td align="left">指定列大小</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">autoIncrementIncrement</td><td align="left">自动步长，控制连续记录之间的间隔</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌入字段的列名前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td align="left">-</td><td align="left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td align="left">comment</td><td align="left">迁移时为字段添加注释</td></tr></tbody></table><h1 id="连接到数据库"><a href="#连接到数据库" class="headerlink" title="连接到数据库"></a>连接到数据库</h1><p>GORM官方支持的数据库类型有：MySQL, PostgreSQL, SQLite, SQL Server 和 TiDB</p><h2 id="连接到MySQL"><a href="#连接到MySQL" class="headerlink" title="连接到MySQL"></a>连接到MySQL</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dsn := <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL驱动程序提供了一些高级配置可以在初始化时使用，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">  DSN: <span class="string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <span class="comment">// DSN data source name</span></span><br><span class="line">  DefaultStringSize: <span class="number">256</span>, <span class="comment">// string 类型字段的默认长度</span></span><br><span class="line">  DisableDatetimePrecision: <span class="literal">true</span>, <span class="comment">// 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持</span></span><br><span class="line">  DontSupportRenameIndex: <span class="literal">true</span>, <span class="comment">// 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引</span></span><br><span class="line">  DontSupportRenameColumn: <span class="literal">true</span>, <span class="comment">// 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列</span></span><br><span class="line">  SkipInitializeWithVersion: <span class="literal">false</span>, <span class="comment">// 根据当前 MySQL 版本自动配置</span></span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建一条记录"><a href="#创建一条记录" class="headerlink" title="创建一条记录"></a>创建一条记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name:<span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line">result := db.Create(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="用所选字段创建记录"><a href="#用所选字段创建记录" class="headerlink" title="用所选字段创建记录"></a>用所选字段创建记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)</span></span><br></pre></td></tr></table></figure><p>创建一条记录，忽略未指出的字段。</p><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">  user.ID <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定插入数量</span></span><br><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu_1&quot;</span>&#125;, ...., &#123;Name: <span class="string">&quot;jinzhu_10000&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// batch size 100</span></span><br><span class="line">db.CreateInBatches(users, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="创建Hooks"><a href="#创建Hooks" class="headerlink" title="创建Hooks"></a>创建Hooks</h3><p>GORM提供的hooks有<code>BeforeSave</code>, <code>BeforeCreate</code>,<code>AfterSave</code>,<code>AfterCreate</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    u.UUID = uuid.New()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;invalid role&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询单个对象"><a href="#查询单个对象" class="headerlink" title="查询单个对象"></a>查询单个对象</h3><p>GORM提供了<code>First</code>, <code>Take</code>, <code>Last</code> 方法从数据库中检索对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询主键值第一的记录</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询一条记录</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询主键值倒数第一的记录</span></span><br><span class="line">db.Last(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="根据主键查询"><a href="#根据主键查询" class="headerlink" title="根据主键查询"></a>根据主键查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="字符串条件"><a href="#字符串条件" class="headerlink" title="字符串条件"></a>字符串条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取匹配的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;user)</span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-协程</title>
      <link href="/2023/04/24/go-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2023/04/24/go-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>协程是一种用户态的轻量级线程，又称微线程，协程的调度完全由用户控制。<strong>与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。</strong></p><span id="more"></span><h1 id="1-1-Goroutine"><a href="#1-1-Goroutine" class="headerlink" title="1.1 Goroutine"></a>1.1 Goroutine</h1><p>创建Goroutine的成本很小，它就是一段代码，一个函数入口。以及在堆上为其分配的一个堆栈（初始大小为4K，会随着程序的执行自动增长删除）。因此它非常廉价，Go应用程序可以并发运行数千个Goroutines。</p><ol><li>与线程相比，Goroutines非常便宜。它们只是堆栈大小的几个kb，堆栈可以根据应用程序的需要增长和收缩，而在线程的情况下，堆栈大小必须指定并且是固定的</li><li>Goroutines被多路复用到较少的OS线程。在一个程序中可能只有一个线程与数千个Goroutines。如果线程中的任何Goroutine都表示等待用户输入，则会创建另一个OS线程，剩下的Goroutines被转移到新的OS线程。所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的API。</li><li>当使用Goroutines访问共享内存时，通过设计的通道可以防止竞态条件发生。通道可以被认为是Goroutines通信的管道。</li></ol><h1 id="1-2-主goroutine"><a href="#1-2-主goroutine" class="headerlink" title="1.2 主goroutine"></a>1.2 主goroutine</h1><p>封装main函数的goroutine称为主goroutine。</p><p>主goroutine的任务：</p><ol><li>创建一个<code>defer</code>语句，用于在主goroutine退出时做必要的善后工作。</li><li>启动垃圾回收的gotoutine。</li><li>执行main包中的init函数</li><li>执行main函数。</li></ol><h1 id="1-3-goroutine与线程"><a href="#1-3-goroutine与线程" class="headerlink" title="1.3 goroutine与线程"></a>1.3 goroutine与线程</h1><h2 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h2><p>线程都具有一个固定大小的栈内存(2MB)，作为对比，一个goroutine在生命周期开始时只有一个很小的栈，典型情况为2KB。goroutine的栈不是固定大小的，它可以按需增大或者缩小，goroutine栈最大可达1GB。</p><h2 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h2><p>OS线程由内核调度器函数来调度，过程为：保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。这个过程较为缓慢。</p><p>Go有自己的调度器，采用<code>m:n</code>调度技术(复用&#x2F;调度m个goroutine到n个os线程)。Go调度器和内核调度器的工作类似，但Go调度器只需关心单个Go程序的goroutine调度问题。</p><p>os线程调度器由硬件时钟定期触发，Go调度器并非如此。它不需要切换到内核环境，所以调用一个goroutine比调度一个线程的成本低很多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-垃圾回收</title>
      <link href="/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的垃圾回收机制"><a href="#常见的垃圾回收机制" class="headerlink" title="常见的垃圾回收机制"></a>常见的垃圾回收机制</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。</p><p>缺点：</p><ul><li>降低性能</li><li>循环引用</li></ul><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>该方法分为两步：</p><ol><li>标记从根节点开始迭代遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；</li><li>清除操作。对没有被标记的内存进行清除操作。</li></ol><p>缺点：</p><ul><li>启动垃圾回收时会暂停当前所用代码的执行。</li></ul><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>分代收集的基本思想是，将堆划分成两个或者多个称为代的空间。新创建的对象存放在称为新生代中，随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中，因此，新生代垃圾回收和老年代垃圾回收两种方式共存，分别对其空间中的对象进行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。</p><h1 id="Go的垃圾回收器"><a href="#Go的垃圾回收器" class="headerlink" title="Go的垃圾回收器"></a>Go的垃圾回收器</h1><p>go的垃圾回收机制是标记-清除算法。</p><ul><li>标记阶段。获取这些对象的状态信息。</li><li>清扫阶段。回收状态为unreachable的对象。</li></ul><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># init --&gt; all while</span><br><span class="line">---------  stop the world  ------------</span><br><span class="line">go(scan)</span><br><span class="line">go(scan)</span><br><span class="line">go(scan)</span><br><span class="line">mark reachable object grey</span><br><span class="line">---------  start the world  ------------</span><br><span class="line">mark grey object refe grey</span><br><span class="line">当一个对象所有引用的对象都置为灰色并加入队列后，这个对象才能置为黑色并取出。循环往复，最后队列为空时，整个图剩下的白色内存空间即不可到达的对象，即没有被引用的对象； 第三轮再次stop the world，将第二轮过程中新增对象申请的内存进行标记（灰色），这里使用了writebarrier（写屏障）去记录这些内存的身份</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os实验踩坑实录</title>
      <link href="/2023/04/20/os%E5%AE%9E%E9%AA%8C%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/"/>
      <url>/2023/04/20/os%E5%AE%9E%E9%AA%8C%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>我用的版本是Ubuntu 20.04。源是阿里源。</p><p>本文参考<a href="https://moefactory.com/3041.moe">https://moefactory.com/3041.moe</a></p><span id="more"></span><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><h2 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h2><p>官网地址： <a href="https://www.kernel.org/">https://www.kernel.org/</a> 。本文写作时最新的稳定版为6.2.11。</p><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc make libncurses5-dev openssl libssl-dev build-essential pkg-config libc6-dev bison flex libelf-dev</span><br></pre></td></tr></table></figure><p>系统调用<code>os_exp</code>，添加在<code>kernel/sys.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(os_exp, <span class="type">long</span> <span class="type">long</span>, id) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mod = (id % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1000000</span> : <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">return</span> id % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>include/linux/syscalls.h</code>中添加系统调用的函数声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_os_exp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> id)</span>;</span><br></pre></td></tr></table></figure><p>最后在系统调用表中添加我们自定义的系统调用。<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中，在335号系统调用后添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">335</span>commonos_exp__x64_sys_os_exp</span><br></pre></td></tr></table></figure><p><code>&lt;系统调用编号&gt; common &lt;系统调用名称&gt; &lt;系统调用的函数名称&gt;</code>，这四列之间请使用制表符分隔。注意系统调用的函数名称是有格式要求的，格式为 <code>__x64_sys_&lt;函数名&gt;</code>，而这里的函数名就是之前我们自己拟定的 <code>os_exp</code>。</p><h2 id="配置内核代码"><a href="#配置内核代码" class="headerlink" title="配置内核代码"></a>配置内核代码</h2><p>在下载下来的内核目录下，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -v /boot/config-$(uname -r) .config</span><br></pre></td></tr></table></figure><p>目的是为了使我们编译的内核的配置与当前环境的配置一致。</p><p>修改.config文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vim .config</span></span><br><span class="line"><span class="comment">// / CONFIG_SYSTEM_TRUSTED_KEYS = &quot;&quot;</span></span><br><span class="line"><span class="comment">// / CONFIG_SYSTEM_REVOCATION_KEYS = &quot;&quot;</span></span><br><span class="line"><span class="comment">// 结果如下图所示</span></span><br></pre></td></tr></table></figure><img src="C:\Users\79893\blog\source\images\os_expe\.config配置文件.jpg" alt="config配置文件" style="zoom:67%;" /><h2 id="编译安装内核"><a href="#编译安装内核" class="headerlink" title="编译安装内核"></a>编译安装内核</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make -j4</span><br></pre></td></tr></table></figure><p>分配线程的数目取决于虚拟机的CPU核数以及每个核的线程数，比如我的虚拟机是双核双线程的，因此选择4线程编译。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装内核模块命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure><p>安装内核：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>重启系统并查看新内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="测试系统调用"><a href="#测试系统调用" class="headerlink" title="测试系统调用"></a>测试系统调用</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy学习笔记</title>
      <link href="/2023/04/15/NumPy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/15/NumPy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ndarray对象"><a href="#Ndarray对象" class="headerlink" title="Ndarray对象"></a>Ndarray对象</h1>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2023/04/14/Redis%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/14/Redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL学习笔记</title>
      <link href="/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。</p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p><h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><p><code>teachers</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">张老师</td></tr><tr><td align="left">2</td><td align="left">王老师</td></tr><tr><td align="left">3</td><td align="left">李老师</td></tr><tr><td align="left">4</td><td align="left">赵老师</td></tr></tbody></table><p><code>classes</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">一班</td></tr><tr><td align="left">2</td><td align="left">二班</td></tr></tbody></table><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><table><thead><tr><th align="left">id</th><th align="left">teacher_id</th><th align="left">class_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">2</td></tr><tr><td align="left">3</td><td align="left">2</td><td align="left">1</td></tr><tr><td align="left">4</td><td align="left">2</td><td align="left">2</td></tr><tr><td align="left">5</td><td align="left">3</td><td align="left">1</td></tr><tr><td align="left">6</td><td align="left">4</td><td align="left">2</td></tr></tbody></table><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。</p><p>例如，对于<code>students</code>表：</p><table><thead><tr><th align="left">id</th><th align="left">class_id</th><th align="left">name</th><th align="left">gender</th><th align="left">score</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">1</td><td align="left">小明</td><td align="left">M</td><td align="left">90</td></tr><tr><td align="left">2</td><td align="left">1</td><td align="left">小红</td><td align="left">F</td><td align="left">95</td></tr><tr><td align="left">3</td><td align="left">1</td><td align="left">小军</td><td align="left">M</td><td align="left">88</td></tr></tbody></table><p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score (score);</span><br></pre></td></tr></table></figure><h1 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h1><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>要指定条件“分数在80分或以上的学生”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><p>条件查询的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;TABLENAME&gt; WHERE &lt;CONDITION&gt;</span><br><span class="line"># 多条件</span><br><span class="line"># 与条件： AND</span><br><span class="line"># 或条件： OR</span><br></pre></td></tr></table></figure><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>如果我们想查询某几列的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, name FROM students;</span><br><span class="line"># 返回某几列的数据</span><br><span class="line">SELECT C1, C2, C3</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序使用关键词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ORDER BY</span><br><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC;</span><br><span class="line"># 默认为升序</span><br></pre></td></tr></table></figure><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每页的最大数量 LIMIT PAGESIZE</span><br><span class="line"># 查询第n页的数据OFFSET PAGESIZE * (n-1)</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><p>SQL提供了一些函数用于统计数据，这些函数被称谓聚合函数。</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">SUM</td><td align="left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td align="left">AVG</td><td align="left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td align="left">MAX</td><td align="left">计算某一列的最大值</td></tr><tr><td align="left">MIN</td><td align="left">计算某一列的最小值</td></tr><tr><td align="left">COUNT</td><td align="left">统计记录数目</td></tr></tbody></table><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p><code>INSERT</code>语句的基本语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br><span class="line"># 例如</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br><span class="line"></span><br><span class="line"># 一次性添加多条数据</span><br><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line">  (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81);</span><br></pre></td></tr></table></figure><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>更新数据库中的记录，使用<code>UPDATE</code> 语句。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</span><br><span class="line">UPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p><code>DELETE</code>语句的基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;TABLENAME&gt; WHERE...;</span><br><span class="line"></span><br><span class="line"># 例</span><br><span class="line">-- 删除id=1的记录</span><br><span class="line">DELETE FROM students WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">begin;# 开始事务</span><br><span class="line">commit; # 提交事务</span><br><span class="line">rollback; # 回滚</span><br><span class="line"></span><br><span class="line"># 使用示例</span><br><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb;  # 创建数据表</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from runoob_transaction_test;</span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; begin;  # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(5);</span><br><span class="line">Query OK, 1 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into runoob_transaction_test value(6);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; commit; # 提交事务</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  select * from runoob_transaction_test;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; begin;    # 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;  insert into runoob_transaction_test values(7);</span><br><span class="line">Query OK, 1 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; rollback;   # 回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;   select * from runoob_transaction_test;   # 因为回滚所以数据没有插入</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">| 6    |</span><br><span class="line">+------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-并发编程</title>
      <link href="/2023/04/13/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/13/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>现代操作系统提供了三种基本的构造并发程序的方法：</p><ul><li>进程。每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用显式的进程间通信机制。</li><li>I&#x2F;O多路复用。</li><li>线程</li></ul><span id="more"></span><h1 id="12-1-基于进程的并发编程"><a href="#12-1-基于进程的并发编程" class="headerlink" title="12.1 基于进程的并发编程"></a>12.1 基于进程的并发编程</h1><h2 id="12-1-1-基于进程的并发服务器代码"><a href="#12-1-1-基于进程的并发服务器代码" class="headerlink" title="12.1.1 基于进程的并发服务器代码"></a>12.1.1 基于进程的并发服务器代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="number">0</span>, WNOHANG) &gt; <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHID, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            Close(listenfd);</span><br><span class="line">            echo(connfd);</span><br><span class="line">            Close(connfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-网络编程</title>
      <link href="/2023/04/12/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/12/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本章将开发一个小但功能齐全的Web服务器，能够为Web浏览器提供静态和动态的内容</p><span id="more"></span><h1 id="11-1-客户端-服务器编程模型"><a href="#11-1-客户端-服务器编程模型" class="headerlink" title="11.1 客户端-服务器编程模型"></a>11.1 客户端-服务器编程模型</h1><p>模型的基本操作是事务。</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcEDmtR-tqJ-C9Mr2d%2F-MIcFLCPfWxblhRZ7AP_%2F11-01%20%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%8B%E5%8A%A1.png?alt=media&token=78c8799d-c6de-4407-8770-609fff26bf02" alt="img"></p><p><strong>客户端和服务器是进程。</strong> 一台主机可以同时运行许多不同的客户端和服务器。</p><h1 id="11-2-网络"><a href="#11-2-网络" class="headerlink" title="11.2 网络"></a>11.2 网络</h1><p>对于主机而言，网络只是I&#x2F;O设备，是数据源与数据接收方。网络主机的硬件组成如图所示：</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcFnVWynYxtK3NJ2f-%2F11-02%20%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png?alt=media&token=3b44a186-e4d9-4249-be30-51873d1fbe14" alt="img" style="zoom:67%;" /><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种局域网技术。一个以太网段如下图所示：</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcG2K-973Kc7SXR3lj%2F11-03%20%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%AE%B5.png?alt=media&token=f1e8e061-ce6a-4f49-be7f-5a7c3444cf39" alt="img"></p><p>电缆的一段连接到主机的适配器，一段连接到集线器的一个端口上。集线器会将数据复制到每个端口上。</p><p><strong>每一个以太网适配器都有一个唯一的48位地址。</strong></p><p>以太网段通过<strong>网桥</strong> 连接成较大的局域网，被称为桥接以太网。在一个桥接以太网里，一些电缆连接网桥与网桥，而另外一些连接网桥和集线器。这些电缆的带宽可以是不同的。在我们的示例中，网桥与网桥之间的电缆有 1 Gb&#x2F;s 的带宽，而四根网桥和集线器之间电缆的带宽却是 100 Mb&#x2F;s。</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcGBwQgcFq_cQ41BB3%2F11-04%20%E6%A1%A5%E6%8E%A5%E4%BB%A5%E5%A4%AA%E7%BD%91.png?alt=media&token=be280145-d387-4296-bc60-2d05e2a78e02" alt="img" style="zoom:67%;" /><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>多个不兼容的局域网通过路由器连接起来。路由器对于它连接到的每个网络都有一个端口。简化的广域网模型如下：</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcGwrig9daBai1FRYF%2F11-06%20%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C.png?alt=media&token=5bcd8467-c2bb-470e-bed0-fac5b929f4e1" alt="img"></p><h2 id="数据通过互联网传送的过程"><a href="#数据通过互联网传送的过程" class="headerlink" title="数据通过互联网传送的过程"></a>数据通过互联网传送的过程</h2><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcFl23F3mZVEkEbplX%2F-MIcHP1NeaIedAWbfoVx%2F11-07%20%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E4%BB%8E%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA%E4%BC%A0%E9%80%81%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA.png?alt=media&token=581d6613-fcdc-4710-b94f-23b375c3423f" alt="img"></p><ol><li><p>运行在主机 A 上的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区中。</p></li><li><p>主机 A 上的协议软件通过在数据前附加互联网络包头和 LAN1 帧头，创建了一个 LAN1 的帧。互联网络包头寻址到互联网络主机 B。LAN1 帧头寻址到路由器。然后它传送此帧到适配器。注意，LAN1 帧的有效载荷是一个互联网络包，而互联网络包的有效载荷是实际的用户数据。这种封装是基本的网络互联方法之一。</p></li><li><p>LAN1 适配器复制该帧到网络上。</p></li><li><p>当此帧到达路由器时，路由器的 LAN1 适配器从电缆上读取它，并把它传送到协议软件。</p></li><li><p>路由器从互联网络包头中提取出目的互联网络地址，并用它作为路由表的索引，确定向哪里转发这个包，在本例中是 LAN2。路由器剥落旧的 LAN1 的帧头，加上寻址到主机 B 的新的 LAN2 帧头，并把得到的帧传送到适配器。</p></li><li><p>路由器的 LAN2 适配器复制该帧到网络上。</p></li><li><p>当此帧到达主机 B 时，它的适配器从电缆上读到此帧，并将它传送到协议软件。</p></li><li><p>最后，主机 B 上的协议软件剥落包头和帧头。当服务器进行一个读取这些数据的系统调用时，协议软件最终将得到的数据复制到服务器的虚拟地址空间。</p></li></ol><h1 id="11-3-全球IP因特网"><a href="#11-3-全球IP因特网" class="headerlink" title="11.3 全球IP因特网"></a>11.3 全球IP因特网</h1><p>下图展示了一个因特网客户端—服务器应用程序的基本硬件和软件组织。</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcHkeFKYXQWEZwjoyA%2F-MIcHnJyVgajdck33wQY%2F11-08%20%E4%B8%80%E4%B8%AA%E5%9B%A0%E7%89%B9%E7%BD%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%84%E7%BB%87.png?alt=media&token=83af1809-b538-4c75-a756-b72fce11d12e" alt="img"></p><p>因特网的客户端和服务器混合使用<strong>套接字接口</strong>函数和 Unix l&#x2F;O 函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的 TCP&#x2F;IP 函数。</p><p>TCP&#x2F;IP 实际是一个协议族，其中每一个都提供不同的功能。</p><p>从程序员的视角来看，因特网是一个世界范围内的主机集合，满足以下特性：</p><ul><li>主机集合被映射为一组32位的IP地址（IPV4,IPV6为128位的地址）。</li><li>IP地址被映射为一组称为因特网域名的标识符。</li><li>因特网主机上的进程能够通过连接来与任何其他因特网主机上的进程通信。</li></ul><h2 id="11-3-1-IP地址"><a href="#11-3-1-IP地址" class="headerlink" title="11.3.1 IP地址"></a>11.3.1 IP地址</h2><p>一个IP地址就是一个32位无符号整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> s_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-2-因特网连接"><a href="#11-3-2-因特网连接" class="headerlink" title="11.3.2 因特网连接"></a>11.3.2 因特网连接</h2><p>一个套接字是连接的一个端点，每个套接字都有相应的套接字地址。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的端口组成的。</p><p>一个连接是偶遇它两端的套接字地址唯一确定的，这对地址叫做套接字对。</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcIVA8Oa5oAQmnqcsA%2F-MIcIdkIs4DHVjeiXnbH%2F11-11%20%E5%9B%A0%E7%89%B9%E7%BD%91%E8%BF%9E%E6%8E%A5%E5%88%86%E6%9E%90.png?alt=media&token=53e83d73-f626-4f94-abc4-71e9dfb9ecf7" alt="img"></p><h1 id="11-4-套接字接口"><a href="#11-4-套接字接口" class="headerlink" title="11.4 套接字接口"></a>11.4 套接字接口</h1><p>套接字接口是一组函数，它们和Unix I&#x2F;O函数结合起来，用以创建网络应用。</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcIVA8Oa5oAQmnqcsA%2F-MIcIpAw0dyTG0YUwyFW%2F11-12%20%E5%9F%BA%E4%BA%8E%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A6%82%E8%BF%B0.png?alt=media&token=74a1bb56-bc88-4cd7-afe6-0f209890a137" alt="img" style="zoom:67%;" /><h2 id="11-4-1-套接字地址结构"><a href="#11-4-1-套接字地址结构" class="headerlink" title="11.4.1 套接字地址结构"></a>11.4.1 套接字地址结构</h2><p>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span>       sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">    <span class="type">uint16_t</span>       sin_port;     <span class="comment">/* Port number in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/* IP address in network byte order */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  sin_zero[<span class="number">8</span>];  <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span>  sa_family;    <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="type">char</span>      sa_data[<span class="number">14</span>];  <span class="comment">/* Address data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-4-2-socket函数"><a href="#11-4-2-socket函数" class="headerlink" title="11.4.2 socket函数"></a>11.4.2 socket函数</h2><p>客户端和服务器使用socket函数来创建一个套接字描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><h2 id="11-4-3-connect函数"><a href="#11-4-3-connect函数" class="headerlink" title="11.4.3 connect函数"></a>11.4.3 connect函数</h2><p>客户端通过connect函数来建立和服务器的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>connect 函数试图与套接字地址为addr的服务器建立一个因特网连接，connect函数会一直阻塞直至成功建立连接或者是发生错误。</p><h2 id="11-4-4-bind函数"><a href="#11-4-4-bind函数" class="headerlink" title="11.4.4 bind函数"></a>11.4.4 bind函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">// bind 函数告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来。参数 addrlen 就是 sizeof(sockaddr_in)。对于 socket 和 connect，最好的方法是用 getaddrinfo 来为 bind 提供参数</span></span><br></pre></td></tr></table></figure><h2 id="11-4-5-listen函数"><a href="#11-4-5-listen函数" class="headerlink" title="11.4.5 listen函数"></a>11.4.5 listen函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">// listen 函数将 sockfd 从一个主动套接字转化为一个监听套接字（listening socket），该套接字可以接受来自客户端的连接请求。backlog 参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。通常我们会把它设置为一个较大的值，比如 1024。</span></span><br></pre></td></tr></table></figure><h2 id="11-4-6-accept函数"><a href="#11-4-6-accept函数" class="headerlink" title="11.4.6 accept函数"></a>11.4.6 accept函数</h2><p>服务器通过调用 accept 函数来等待来自客户端的连接请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">// accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个已连接描述符（connected descriptor），这个描述符可被用来利用 Unix I/O 函数与客户端通信。</span></span><br></pre></td></tr></table></figure><p>监听描述符是作为客户端连接请求的一个端点。它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点。</p><p>下图描绘了监听描述符和已连接描述符的角色</p><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MIcIVA8Oa5oAQmnqcsA%2F-MIcJ4OomcM5yziiKQoR%2F11-14%20%E7%9B%91%E5%90%AC%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E5%B7%B2%E8%BF%9E%E6%8E%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E8%A7%92%E8%89%B2.png?alt=media&token=da343219-c801-4a60-bdbe-d6ef74511cec" alt="img"></p><p><strong>区分监听描述符和已连接描述符的目的：</strong></p><p>因为它使得我们可以. 建立并发服务器，它能够同时处理许多客户端连接。例如，每次一个连接请求到达监听描述符时，我们可以派生（fork）—个新的进程，它通过已连接描述符与客户端通信。</p><h2 id="11-4-7-主机和服务的转换"><a href="#11-4-7-主机和服务的转换" class="headerlink" title="11.4.7 主机和服务的转换"></a>11.4.7 主机和服务的转换</h2><ol><li>getaddrinfo函数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo **result)</span>;</span><br><span class="line"><span class="comment">// 返回：如果成功则为 0，如果错误则为非零的错误代码。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *result)</span>;</span><br><span class="line"><span class="comment">// 返回：无。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errcode)</span>;</span><br><span class="line"><span class="comment">// 返回：错误消息。</span></span><br></pre></td></tr></table></figure><h1 id="11-5-Web服务器"><a href="#11-5-Web服务器" class="headerlink" title="11.5 Web服务器"></a>11.5 Web服务器</h1><h2 id="11-5-1-Web基础"><a href="#11-5-1-Web基础" class="headerlink" title="11.5.1 Web基础"></a>11.5.1 Web基础</h2><p>Web客户端与服务器之间的交互HTTP协议。HTTP 是一个简单的协议。一个 Web 客户端（即浏览器）打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p><h2 id="11-5-2-Web内容"><a href="#11-5-2-Web内容" class="headerlink" title="11.5.2 Web内容"></a>11.5.2 Web内容</h2><p><strong>Web服务器向客户端提供内容的方式</strong></p><ul><li>读取磁盘内容并返回给服务器。静态内容。</li><li>返回可执行文件的输出。动态内容。</li></ul><p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 <strong>URL</strong>（Universal Resource Locator，通用资源定位符）。</p><p>可执行文件的 URL 可以在文件名后包括程序参数。“?” 字符分隔文件名和参数，而且每个参数都用 “&amp;” 字符分隔开。</p><h2 id="11-5-3-HTTP事务"><a href="#11-5-3-HTTP事务" class="headerlink" title="11.5.3 HTTP事务"></a>11.5.3 HTTP事务</h2><h3 id="1-HTTP请求"><a href="#1-HTTP请求" class="headerlink" title="1 HTTP请求"></a>1 HTTP请求</h3><p>一个请求行+请求报头。</p><h3 id="2-HTTP响应"><a href="#2-HTTP响应" class="headerlink" title="2 HTTP响应"></a>2 HTTP响应</h3><p>响应行+响应报头+响应体。</p><p>响应行： version + status-code + status-message</p><table><thead><tr><th>状态代码</th><th>状态消息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>处理请求无误</td></tr><tr><td>301</td><td>永久移动</td><td>内容已移动到 location 头中指明的主机上</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不能理解请求</td></tr><tr><td>403</td><td>禁止</td><td>服务器无权访问所请求的文件</td></tr><tr><td>404</td><td>未发现</td><td>服务器不能找到所请求的文件</td></tr><tr><td>501</td><td>未实现</td><td>服务器不支持请求的方法</td></tr><tr><td>505</td><td>HTTP 版本不支持</td><td>服务器不支持请求的版本</td></tr></tbody></table><h2 id="11-5-4-服务动态内容"><a href="#11-5-4-服务动态内容" class="headerlink" title="11.5.4 服务动态内容"></a>11.5.4 服务动态内容</h2><p> <strong>CGI</strong>（Common Gateway Interface，通用网关接口）。</p><h3 id="1-客户端如何将程序参数传递给服务器"><a href="#1-客户端如何将程序参数传递给服务器" class="headerlink" title="1 客户端如何将程序参数传递给服务器"></a>1 客户端如何将程序参数传递给服务器</h3><p>GET请求的参数在url中传递。</p><p>POST请求的参数在请求主题中传递。</p><h3 id="2-服务器如何将参数传递给子进程"><a href="#2-服务器如何将参数传递给子进程" class="headerlink" title="2 服务器如何将参数传递给子进程"></a>2 服务器如何将参数传递给子进程</h3><p>服务器接收请求后通过fork创建一个子进程，并调用execve执行程序。</p><h3 id="3-服务器如何将其他信息传递给子进程"><a href="#3-服务器如何将其他信息传递给子进程" class="headerlink" title="3 服务器如何将其他信息传递给子进程"></a>3 服务器如何将其他信息传递给子进程</h3><p>CGI 定义了大量的其他环境变量，一个 CGI 程序在它运行时可以设置这些环境变量。</p><table><thead><tr><th>环境变量</th><th>描述</th></tr></thead><tbody><tr><td>QUERY_STRING</td><td>程序参数</td></tr><tr><td>SERVER_PORT</td><td>父进程侦听的端口</td></tr><tr><td>REQUEST_METHOD</td><td>GET 或 POST</td></tr><tr><td>REMOTE_HOST</td><td>客户端的域名</td></tr><tr><td>REMOTE_ADDR</td><td>客户端的点分十进制 IP 地址</td></tr><tr><td>CONTENT_TYPE</td><td>只对 POST 而言：请求体的 MIME 类型</td></tr><tr><td>CONTENT_LENGTH</td><td>只对 POST 而言：请求体的字节大小</td></tr></tbody></table><h3 id="4-子进程将他的输出发送到哪里"><a href="#4-子进程将他的输出发送到哪里" class="headerlink" title="4 子进程将他的输出发送到哪里"></a>4 子进程将他的输出发送到哪里</h3><p>一个 CGI 程序将它的动态内容发送到标准输出。在子进程加载并运行 CGI 程序之前，它使用 Linux dup2 函数将标准输出重定向到和客户端相关联的已连接描述符。因此，任何 CGI 程序写到标准输出的东西都会直接到达客户端。</p><p>下面展示了一个简单的 CGI 程序，它对两个参数求和，并返回带结果的 HTML 文件给客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *buf, *p;</span><br><span class="line">    <span class="type">char</span> arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extract the two arguments */</span></span><br><span class="line">    <span class="keyword">if</span> ((buf = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = <span class="built_in">strchr</span>(buf, ’&amp;’);</span><br><span class="line">        *p = ’\<span class="number">0</span>’;</span><br><span class="line">        <span class="built_in">strcpy</span>(arg1, buf);</span><br><span class="line">        <span class="built_in">strcpy</span>(arg2, p + <span class="number">1</span>);</span><br><span class="line">        n1 = atoi(arg1);</span><br><span class="line">        n2 = atoi(arg2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Make the response body */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;QUERY_STRING=%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;Welcome to add.com: &quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sTHE Internet addition portal.\r\n&lt;p&gt;&quot;</span>, content);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThe answer is: %d + %d = %d\r\n&lt;p&gt;&quot;</span>,</span><br><span class="line">            content, n1, n2, n1 + n2);</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;%sThanks for visiting!\r\n&quot;</span>, content);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Generate the HTTP response */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connection: close\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-length: %d\r\n&quot;</span>, (<span class="type">int</span>)<span class="built_in">strlen</span>(content));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iris-day2</title>
      <link href="/2023/04/10/iris-day2/"/>
      <url>/2023/04/10/iris-day2/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈mmap</title>
      <link href="/2023/04/09/%E6%B5%85%E8%B0%88mmap/"/>
      <url>/2023/04/09/%E6%B5%85%E8%B0%88mmap/</url>
      
        <content type="html"><![CDATA[<p>mmap能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。普通文件在被映射到进程地址空间后，进程可以像访问普通内存一样访问文件，不必通过read()、write()等系统调用来访问文件。</p><span id="more"></span><h4 id="mmap接口描述"><a href="#mmap接口描述" class="headerlink" title="mmap接口描述"></a>mmap接口描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// addr: 内存空间上的起始地址，一般为NULL，内核自动分配</span></span><br><span class="line"><span class="comment">// length: 字节数</span></span><br><span class="line"><span class="comment">// prot: 共享内存的访问权限</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PROT_READ</span></span><br><span class="line"><span class="comment">PROT_WRITE</span></span><br><span class="line"><span class="comment">PROT_EXEC</span></span><br><span class="line"><span class="comment">PROT_NONE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// flags:</span></span><br><span class="line"><span class="comment">// fd: 文件描述符</span></span><br><span class="line"><span class="comment">// offset: 偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值: 文件映射到进程空间的地址。</span></span><br></pre></td></tr></table></figure><h4 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h4><p>匿名映射没有对应的文件。fork()得到的子进程会拷贝父进程映射后的空间，同时也继承了mmap()的返回地址，从而实现进程间的通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名映射的例子</span></span><br><span class="line">ptr = mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">switch</span>(pid) &#123;</span><br><span class="line">    <span class="keyword">case</span> pid &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;err\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> pid = <span class="number">0</span>:</span><br><span class="line">        lock(ptr);</span><br><span class="line">        critical_section();</span><br><span class="line">        unlock(ptr);</span><br><span class="line">    <span class="keyword">case</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        lock(ptr);</span><br><span class="line">        critical_section();</span><br><span class="line">        unlock(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7:链接</title>
      <link href="/2023/04/09/7-%E9%93%BE%E6%8E%A5/"/>
      <url>/2023/04/09/7-%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。</p><span id="more"></span><h1 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h1><p>下面是两个运行示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux下编译该C程序的命令</span></span><br><span class="line">linux&gt; gcc -Og -o prog main.c sum.c</span><br></pre></td></tr></table></figure><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8jCXJzp_pYD5VGG8o%2F-MI8oSBe7kBcpszDCC7T%2F07-02%20%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5.png?alt=media&token=4a1bcea6-9bd1-4222-98e3-fc37075a2c56" alt="img" style="zoom:50%;" /><h1 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h1><p>静态链接器 (static linker)以一组可重定向的目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。</p><p>input:</p><p>​由各种不同的的代码和数据节构成，每一节都是一个连续的字节序列。</p><p>链接器的任务：</p><ul><li>符号解析。将每个符号引用与每个符号定义关联起来。</li><li>重定位。 编译器和汇编器生成从地址0开始代码和数据节。链接器通过把每个符号定义和内存位置关联起来，从而重定向这些节。然后修改所有对这些符号的引用。使得他们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。</li></ul><h1 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h1><p>目标文件有三种形式：</p><ul><li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接复制到内存并执行。</li><li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li></ul><h1 id="7-4-可重定向目标文件"><a href="#7-4-可重定向目标文件" class="headerlink" title="7.4 可重定向目标文件"></a>7.4 可重定向目标文件</h1><p>下图展示了一个典型的ELF可重定向目标文件的格式。</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8p7rbEV-s_nV5Ru6X%2F-MI8pJh5IxzFL80HMTY3%2F07-03%20%E5%85%B8%E5%9E%8B%E7%9A%84ELF%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6.png?alt=media&token=d9d57c1c-24ef-401a-bf91-04bdf60fad68" alt="img" style="zoom:80%;" /><p><strong>ELF 头</strong>（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。</p><p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节： </p><ul><li><strong>.text：</strong>已编译程序的机器代码。</li><li><strong>.rodata：</strong>只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li><li><strong>.data：</strong>已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li><li><strong>.bss：</strong>未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li><li><strong>.symtab：</strong>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li><li><strong>.rel.text：</strong>一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li><li><strong>.rel.data：</strong>被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li><strong>.debug：</strong>一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li><li><strong>.line：</strong>原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li><li><strong>.strtab：</strong>一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li></ul><h1 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h1><p>在链接器的上下文中，有三种不同的符号：</p><ul><li><p>由模块 m 定义并能被其他模块引用的<strong>全局符号</strong>。全局链接器符号对应于非静态的 C 函数和全局变量。</p></li><li><p>由其他模块定义并被模块 m 引用的<strong>全局符号</strong>。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。</p></li><li><p>只被模块 m 定义和引用的<strong>局部符号</strong>。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。</p></li></ul><p>.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ELF符号表条目</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;<span class="comment">// 字符串表中的字节偏移</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>;<span class="comment">// 函数或者数据</span></span><br><span class="line">    <span class="type">char</span> binding:<span class="number">4</span>; <span class="comment">// 本地或者全局</span></span><br><span class="line">    <span class="type">short</span> section;<span class="comment">// 分配的目标文件的节</span></span><br><span class="line">    <span class="type">long</span> value;<span class="comment">// 对齐要求</span></span><br><span class="line">    <span class="type">long</span> size;<span class="comment">// 最小的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h1><h2 id="7-6-1-链接器如何解析多重定义的全局符号"><a href="#7-6-1-链接器如何解析多重定义的全局符号" class="headerlink" title="7.6.1 链接器如何解析多重定义的全局符号"></a>7.6.1 链接器如何解析多重定义的全局符号</h2><p>在编译时，编译器向汇编器输出每个全局符号的强弱类型。汇编器将这个信息编码在可重定向目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p><p>链接器处理多重定义的符号名的规则如下：</p><ul><li><p><strong>规则 1：</strong>不允许有多个同名的强符号。</p></li><li><p><strong>规则 2：</strong>如果有一个强符号和多个弱符号同名，那么选择强符号。</p></li><li><p><strong>规则 3：</strong>如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</p></li></ul><h2 id="7-6-2-与静态链接库"><a href="#7-6-2-与静态链接库" class="headerlink" title="7.6.2 与静态链接库"></a>7.6.2 与静态链接库</h2><p>编译系统提供了一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，可以作为链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标板块。</p><p>与静态库链接的示意图如下图所示：</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8p7rbEV-s_nV5Ru6X%2F-MI8pkPoBiVWj0eMXoIA%2F07-08%20%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5.png?alt=media&token=fcb51f44-d9fc-4e95-8889-4888b9f920ae" alt="img" style="zoom:80%;" /><h2 id="7-6-3-链接器如何使用静态库来解析引用"><a href="#7-6-3-链接器如何使用静态库来解析引用" class="headerlink" title="7.6.3 链接器如何使用静态库来解析引用"></a>7.6.3 链接器如何使用静态库来解析引用</h2><h1 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h1><p>当在命令号中键入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; ./prog</span><br></pre></td></tr></table></figure><p>Shell调用被称为加载器的操作系统代码来运行该可执行目标文件。任何Linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存当中，然后通过跳转到程序的第一条指令或入口点来运行该程序。</p><h1 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h1><p><strong>共享库</strong>（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking），是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。共享库也称为<strong>共享目标</strong>（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。</p><p>动态链接过程如下图所示：</p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MI8qpMNa8rVv2h1gw56%2F-MI8r4myxZNQCTrFzKsH%2F07-16%20%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93.png?alt=media&token=0901e781-87bf-4e4f-b1f9-31ca05c51f7c" alt="img" style="zoom:67%;" /><p>为了构造图中示例向量例程的共享库，我们调用编译器驱动程序，给编译器和链接器如下指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c</span><br><span class="line"><span class="comment">// -shared选项指示链接器创建一个共享的目标文件</span></span><br><span class="line"><span class="comment">// -fpic选项指示编译器生成与位置无关的代码</span></span><br></pre></td></tr></table></figure><p>链接的指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux &gt; gcc -o prog2l main2.c ./libvector.so</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10:系统级IO</title>
      <link href="/2023/04/08/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
      <url>/2023/04/08/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
      
        <content type="html"><![CDATA[<p>I&#x2F;O是在主存和外部设备之间拷贝数据的过程。本章介绍Unix I&#x2F;O 和一般I&#x2F;O的基本概念。并展示在C程序中如何可靠地使用这些接口。</p><span id="more"></span><h1 id="10-1-Unix-I-x2F-O"><a href="#10-1-Unix-I-x2F-O" class="headerlink" title="10.1 Unix I&#x2F;O"></a>10.1 Unix I&#x2F;O</h1><p>在UNIX系统中，一切都被认为是字节序列(文件), 因而所有的输入域输出都能以统一的方式进行。</p><ul><li><p><strong>打开文件</strong> 内核打开文件后，会返回一个小的非负整数，叫做 <strong>描述符</strong> ，用于表示文件。</p></li><li><p><strong>改变当前文件的位置</strong> 内核保持文件位置k，是文件开头起始的字节偏移量。<code>seek</code>操作可以显式的设置文件的当前位置k。</p></li><li><p><strong>读写文件</strong> </p><ul><li>读操作。从文件拷贝n个字节到存储器，偏移量k&#x3D;k+n。若文件大小为m，当k大于等于m时，触发EOF。</li><li>写操作。从存储器拷贝n&gt;0个字节到一个文件，文件k&#x3D; k + n。</li></ul></li><li><p><strong>关闭文件</strong></p></li></ul><h1 id="10-2-打开和关闭文件"><a href="#10-2-打开和关闭文件" class="headerlink" title="10.2 打开和关闭文件"></a>10.2 打开和关闭文件</h1><p>open函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>* filename, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flags</span></span><br><span class="line"><span class="comment">// O_RDONLY: 只读</span></span><br><span class="line"><span class="comment">// O_WRONLY: 只写</span></span><br><span class="line"><span class="comment">// O_RDWR: 读写</span></span><br><span class="line"><span class="comment">// O_CREAT: 如果文件不存在，就创建它的一个截断的文件</span></span><br><span class="line"><span class="comment">// O_TRUNC: 如果文件已经存在，就截断它</span></span><br><span class="line"><span class="comment">// O_APPEND 打开文件时设置文件位置到文件的结尾处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mode: 新文件的访问权限位</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="10-3-读写文件"><a href="#10-3-读写文件" class="headerlink" title="10.3 读写文件"></a>10.3 读写文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span>, n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 成功：读/写的字节数</span></span><br><span class="line"><span class="comment">// EOF: 0</span></span><br><span class="line"><span class="comment">// 失败： -1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ssize_t和size_t的区别</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ssize_t</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> <span class="type">unsigned</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><h1 id="10-4-用RIO包健壮的读写"><a href="#10-4-用RIO包健壮的读写" class="headerlink" title="10.4 用RIO包健壮的读写"></a>10.4 用RIO包健壮的读写</h1><h2 id="10-4-1-RIO无缓冲输入输出函数"><a href="#10-4-1-RIO无缓冲输入输出函数" class="headerlink" title="10.4.1 RIO无缓冲输入输出函数"></a>10.4.1 RIO无缓冲输入输出函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 返回值与read和write类似</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* userbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line">    <span class="type">char</span>* bufp = usrbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno = EINTR)</span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        nleft -= nread;</span><br><span class="line">        bufp += nread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - nleft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> nleft = n;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">char</span>* bufp = usrbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                nwritten = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        bufp += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-2-RIO带缓冲的输入函数"><a href="#10-4-2-RIO带缓冲的输入函数" class="headerlink" title="10.4.2 RIO带缓冲的输入函数"></a>10.4.2 RIO带缓冲的输入函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">// 将描述符fd和地址rp处读缓冲区联系起来</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="comment">// 从一个内部 读缓冲区 拷贝一个文本行，当缓冲区变空时，会自动调用read重新填满缓冲区。最多写maxlen - 1 个字节，然后用一个空字符截断。</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readnb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">// 从文件rp中最多读n个字节到存储器位置usrbuf。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从标准输入拷贝一个文本文件到标准输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">rio_t</span> rio;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;rio, STDIN_FILENO);</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">        Rio_writen(STDOUT_FILENO, buf, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个类型为rio_t的读缓冲区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIO_BUFSIZE 8192</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rio_fd;<span class="comment">// 缓冲区关联的文件描述符</span></span><br><span class="line">    <span class="type">int</span> rio_cnt;<span class="comment">// 缓冲区中未读的字节数</span></span><br><span class="line">    <span class="type">char</span>* rio_bufptr;<span class="comment">// 缓冲区中下一个字节的位置</span></span><br><span class="line">    <span class="type">char</span> rio_buf[RIO_BUFSIZE];<span class="comment">//内部缓冲区大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rio_readinitb函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rio_readinitb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    rp-&gt;rio_fd = fd;</span><br><span class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;</span><br><span class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rio_read函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">rio_read</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">char</span>* usrbuf, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno !=EINTR)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            rp-&gt;rio_bufptr = rp-&gt;rio_buf;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>)</span><br><span class="line">        cnt = rp-&gt;rio_cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt);</span><br><span class="line">    rp-&gt;rio_bufptr += cnt;</span><br><span class="line">    rp-&gt;rio_cnt -= cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rio_readlineb 的一个实现</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">rio_readlineb</span><span class="params">(<span class="type">rio_t</span>* rp, <span class="type">void</span>* usrbuf, <span class="type">size_t</span> maxlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, rc;</span><br><span class="line">    <span class="type">char</span> c, *bufp = usrbuf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (n  = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">           *bufp++ = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((rc == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// EOF, no data read</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// EOF, read some data;</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *bufp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-5-读取文件元数据"><a href="#10-5-读取文件元数据" class="headerlink" title="10.5 读取文件元数据"></a>10.5 读取文件元数据</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat* buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数输入的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>st_dev;<span class="comment">// 设备</span></span><br><span class="line">    <span class="type">ino_t</span>st_ino;<span class="comment">// inode</span></span><br><span class="line">    <span class="type">mode_t</span>st_mode;<span class="comment">// 保护和文件类型</span></span><br><span class="line">    <span class="type">nlink_t</span>st_nlink;<span class="comment">// 硬链接数目</span></span><br><span class="line">    <span class="type">uit_t</span>st_uid;<span class="comment">// 文件拥有者的用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>st_gid;<span class="comment">// 文件拥有者的组ID</span></span><br><span class="line">    <span class="type">dev_t</span>st_rdev;<span class="comment">// 设备类型</span></span><br><span class="line">    <span class="type">off_t</span>st_size;<span class="comment">// 总大小(字节)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blksize;<span class="comment">// 文件系统I/O的块大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> st_blocks;<span class="comment">// 分配的块数</span></span><br><span class="line">    <span class="type">time_t</span>st_atime;<span class="comment">// 最后一次进入的时间</span></span><br><span class="line">    <span class="type">time_t</span>st_mtime;<span class="comment">// 最后一次更新的时间</span></span><br><span class="line">    <span class="type">time_t</span>st_ctime;<span class="comment">// 最后一次改变的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询和处理一个文件的st_mode位</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat</span>;</span></span><br><span class="line">    <span class="type">char</span>* type, *readok;</span><br><span class="line">    Stat(argv[<span class="number">1</span>], &amp;stat);</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;regular&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = <span class="string">&quot;directory&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> type = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((stat.st_mode &amp; S_ISUSR))</span><br><span class="line">        readok = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        readok = <span class="string">&quot;no&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-6-共享文件"><a href="#10-6-共享文件" class="headerlink" title="10.6 共享文件"></a>10.6 共享文件</h1><p>内核用三个相关的数据结构描述打开的文件：</p><ul><li>描述符表。 每个进程都有独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。</li><li>文件表。打开的文件的集合，由所有的进程共享。</li><li>v-node表。同文件表一样，由所有的进程共享。</li></ul><h1 id="10-7-I-x2F-O重定向"><a href="#10-7-I-x2F-O重定向" class="headerlink" title="10.7 I&#x2F;O重定向"></a>10.7 I&#x2F;O重定向</h1><p>Unix Shell提供了I&#x2F;O重定向机制，允许用户将磁盘文件和标准输入输出联系起来。例如：</p><p><code>unix&gt; ls &gt; foo.txt</code></p><p>下面使用dup2函数实现I&#x2F;O重定向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> new fd)</span>;</span><br><span class="line"><span class="comment">// dup2函数拷贝描述符表表项oldfd到描述符表表项newfd，覆盖描述符表表项newfd以前的内容。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iris:day1</title>
      <link href="/2023/04/08/iris-day1/"/>
      <url>/2023/04/08/iris-day1/</url>
      
        <content type="html"><![CDATA[<p>Iris是一个Go语言下的MVC框架。</p><span id="more"></span><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>MVC架构模式的示意图：</p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/1280px-MVC-Process.svg.png" style="zoom:25%;" /><p>下面是一个使用MVC架构实现的一个简单Iris App</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris/middleware/logger&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris/middleware/recover&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris/mvc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := iris.New()</span><br><span class="line">    app.Use(<span class="built_in">recover</span>.New())</span><br><span class="line">    app.Use(logger.New())</span><br><span class="line"></span><br><span class="line">mvc.New(app).Handle(<span class="built_in">new</span>(ExampleController))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// http://localhost:8080</span></span><br><span class="line">    <span class="comment">// http://localhost:8080/ping</span></span><br><span class="line">    <span class="comment">// http://localhost:8080/hello</span></span><br><span class="line">    app.Run(iris.Addr(<span class="string">&quot;:8080&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExampleController serves the &quot;/&quot;, &quot;/ping&quot; and &quot;/hello&quot;.</span></span><br><span class="line"><span class="keyword">type</span> ExampleController <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get serves</span></span><br><span class="line"><span class="comment">// Method:   GET</span></span><br><span class="line"><span class="comment">// Resource: http://localhost:8080</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ExampleController)</span></span> Get() mvc.Result &#123;</span><br><span class="line">    <span class="keyword">return</span> mvc.Response&#123;</span><br><span class="line">        ContentType: <span class="string">&quot;text/html&quot;</span>,</span><br><span class="line">        Text:        <span class="string">&quot;&lt;h1&gt;Welcome&lt;/h1&gt;&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPing serves</span></span><br><span class="line"><span class="comment">// Method:   GET</span></span><br><span class="line"><span class="comment">// Resource: http://localhost:8080/ping</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ExampleController)</span></span> GetPing() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetHello serves</span></span><br><span class="line"><span class="comment">// Method:   GET</span></span><br><span class="line"><span class="comment">// Resource: http://localhost:8080/hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ExampleController)</span></span> GetHello() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello Iris!&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HTTP主机配置"><a href="#HTTP主机配置" class="headerlink" title="HTTP主机配置"></a>HTTP主机配置</h1><h2 id="监听和服务"><a href="#监听和服务" class="headerlink" title="监听和服务"></a>监听和服务</h2><p>服务器的初始化用Run方法执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Tcp 上监听网络地址 0.0.0.0:8080</span></span><br><span class="line">app.Run(iris.Addr(<span class="string">&quot;:8080&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和前面一样，但是使用自定义 http.Server 也可以在其他地方运行</span></span><br><span class="line">app.Run(iris.Server(&amp;http.Server&#123;Addr:<span class="string">&quot;:8080&quot;</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个自定义的或者标准的net.Listener并传递给app.Run</span></span><br><span class="line"><span class="comment">// 使用自定义 net.Listener</span></span><br><span class="line">l, err := net.Listen(<span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">app.Run(iris.Listener(l))</span><br></pre></td></tr></table></figure><p>下面是一个完整的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/kataras/iris&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := iris.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UNIX socket</span></span><br><span class="line">    <span class="keyword">if</span> errOs := os.Remove(socketFile); errOs != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(errOs) &#123;</span><br><span class="line">        app.Logger().Fatal(errOs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l, err := net.Listen(<span class="string">&quot;unix&quot;</span>, socketFile)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        app.Logger().Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = os.Chmod(socketFile, mode); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        app.Logger().Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.Run(iris.Listener(l))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主机配置程序"><a href="#主机配置程序" class="headerlink" title="主机配置程序"></a>主机配置程序</h2><p>以上所有的监听都是接收 <code>func(*iris.Supervisor)</code>为最后一个变量。可以通过这些函数传递的特定主机来添加配置程序。</p><p>下面的示例代码在服务器关闭时触发一个回调函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.Run(iris.Addr(<span class="string">&quot;:8080&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(h *iris.Supervisor)</span></span> &#123;</span><br><span class="line">    h.RegisterOnShutdown(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;server terminated&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h1 id="HTTP路由"><a href="#HTTP路由" class="headerlink" title="HTTP路由"></a>HTTP路由</h1><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p> <code>Handler</code> 用于处理请求</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>iris提供了所有的HTTP方法，第一个参数是路由路径，第二个可变参数是一个或者多个iris.Handler</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">app := iris.New()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;GET&quot;</span></span><br><span class="line">app.Get(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;POST&quot;</span></span><br><span class="line">app.Post(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;PUT&quot;</span></span><br><span class="line">app.Put(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;DELETE&quot;</span></span><br><span class="line">app.Delete(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;OPTIONS&quot;</span></span><br><span class="line">app.Options(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;TRACE&quot;</span></span><br><span class="line">app.Trace(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;CONNECT&quot;</span></span><br><span class="line">app.Connect(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;HEAD&quot;</span></span><br><span class="line">app.Head(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法: &quot;PATCH&quot;</span></span><br><span class="line">app.Patch(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于所有 HTTP 方法</span></span><br><span class="line">app.Any(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(ctx iris.Context)</span></span>&#123;</span><br><span class="line">    ctx.Writef(<span class="string">&quot;Hello from method: %s and path: %s&quot;</span>, ctx.Method(), ctx.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h2><p>一组路由可以用前缀路径分组，组之间共享相同的中间件和模板布局，组内可以嵌套组。</p><p><code>.Party</code> 被用于分组路由，开发者可以声明不限数量的分组。</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app := iris.New()</span><br><span class="line"></span><br><span class="line">users := app.Party(<span class="string">&quot;/users&quot;</span>, myAuthMiddlewareHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:8080/users/42/profile</span></span><br><span class="line">users.Get(<span class="string">&quot;/&#123;id:int&#125;/profile&quot;</span>, userProfileHandler)</span><br><span class="line"><span class="comment">// http://localhost:8080/users/messages/1</span></span><br><span class="line">users.Get(<span class="string">&quot;/messages/&#123;id:int&#125;&quot;</span>, userMessageHandler)</span><br></pre></td></tr></table></figure><h1 id="Context机制"><a href="#Context机制" class="headerlink" title="Context机制"></a>Context机制</h1><p><strong>上下文是服务器用于所有客户端的中间人“对象”</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文是服务器用于所有客户端的中间人 &quot;对象&quot;。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 对于每一个新的连接，会从 sync.Pool 中获取一个新上下文对象。</span></span><br><span class="line"><span class="comment">// 上下文是 iris 的 http 流中最重要的部分。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 开发者发送响应到客户端的请求通过一个上下文。</span></span><br><span class="line"><span class="comment">// 开发者获取请求信息从客户端的请求上下文中。</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// context 是 context.Context 子包的一个实现。</span></span><br><span class="line"><span class="comment">// context.Context 是很好扩展，所以开发者可以按照实际所需重写它的方法。</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ResponseWriter 如期返回一个兼容 http.ResponseWriter 的 响应writer。</span></span><br><span class="line">    ResponseWriter() ResponseWriter</span><br><span class="line">    <span class="comment">// ResetResponseWriter 应该改变或者升级上下文的 ResponseWriter。</span></span><br><span class="line">    ResetResponseWriter(ResponseWriter)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request 方法如期返回原始的 *http.Request。</span></span><br><span class="line">    Request() *http.Request</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SetCurrentRouteName 方法设置内部路由名称，为了当开发者调用</span></span><br><span class="line">    <span class="comment">// `GetCurrentRoute()` 方法的时候能够正确返回当前 「只读」 路由。</span></span><br><span class="line">    <span class="comment">// 它使用 Router 初始化，如果你手动更改了名称，除了当你是使用`GetCurrentRoute()` </span></span><br><span class="line">    <span class="comment">// 的时候将获取到其他路由，其它没啥变化。</span></span><br><span class="line">    <span class="comment">// 为了从上下文中执行一个不同的路径，你应该使用 `Exec` 函数，</span></span><br><span class="line">    <span class="comment">// 或者通过 `SetHandlers/AddHandler` 函数改变处理方法。</span></span><br><span class="line"></span><br><span class="line">    SetCurrentRouteName(currentRouteName <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// GetCurrentRoute 返回当前注册到当前请求路径的 「只读」路由。</span></span><br><span class="line">    GetCurrentRoute() RouteReadOnly</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AddHandler 可以在服务时添加处理方法到当前请求，但是这些处理方法不会持久化到路由。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// Router 将会调用这些添加到某个路由的处理方法。如果 AddHandler 被调用，</span></span><br><span class="line">    <span class="comment">// 那么处理方法将被添加到已经定义的路由的处理方法的后面。</span></span><br><span class="line">    AddHandler(...Handler)</span><br><span class="line">    <span class="comment">// SetHandlers 替换所有原有的处理方法。</span></span><br><span class="line">    SetHandlers(Handlers)</span><br><span class="line">    <span class="comment">// Handlers 记录当前的处理方法。</span></span><br><span class="line">    Handlers() Handlers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HandlerIndex 设置当前上下文处理方法链中当前索引。</span></span><br><span class="line">    <span class="comment">// 如果传入 -1 ，不会当前索引。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 也可以查看 Handlers(), Next() and StopExecution()。</span></span><br><span class="line">    HandlerIndex(n <span class="type">int</span>) (currentIndex <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// HandlerName 返回当前路由名称，方便调试。</span></span><br><span class="line">    HandlerName() <span class="type">string</span></span><br><span class="line">    <span class="comment">// Next 调用从处理方法链中选择剩下的进行调用，他应该被用于一个中间件中。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 提醒：自定义的上下文应该重写这个方法，以便能够传入他自己的 context.Context 实现。</span></span><br><span class="line">    Next()</span><br><span class="line">    <span class="comment">// NextHandler 从处理链中返回下一个处理方法(但不执行)。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 为了执行下一个 ，可以使用 .Skip() 跳过某个处理方法。</span></span><br><span class="line">    NextHandler() Handler</span><br><span class="line">    <span class="comment">// Skip 从处理链中 忽略/跳过 下一个处理方法。</span></span><br><span class="line">    <span class="comment">// 它应该在中间件内使用。</span></span><br><span class="line">    Skip()</span><br><span class="line">    <span class="comment">// 如果调用了 StopExecution ，接下来的 .Next 调用将被局略。</span></span><br><span class="line">    StopExecution()</span><br><span class="line">    <span class="comment">// IsStopped 检查当前位置的Context是否是255, 如果是, 则返回true, 意味着 StopExecution() 被调用了。</span></span><br><span class="line">    IsStopped() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 当前的 &quot;user/request&quot; 存储                                    |</span></span><br><span class="line">    <span class="comment">//  | 处理方法之间共享信息 - Values().                                  |</span></span><br><span class="line">    <span class="comment">//  | 保存并获取路径参数 - Params()                                    |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Params 返回当前URL中的命名参数。命名的路径参数是被保存在这里的。</span></span><br><span class="line">    <span class="comment">// 这个存储对象随着整个上下文，存活于每个请求声明周期。</span></span><br><span class="line">    Params() *RequestParams</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values 返回当前 「用户」的存储信息。</span></span><br><span class="line">    <span class="comment">// 命名路径参数和任何可选数据可以保存在这里。</span></span><br><span class="line">    <span class="comment">// 这个存储对象，也是存在于整个上下文，每个请求的声明周期中。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 你可以用这个函数设置和获取用于在处理方法和中间件之间共享信息的局部值。</span></span><br><span class="line">    Values() *memstore.Store</span><br><span class="line">    <span class="comment">// Translate 是 i18n 函数，用于本地化。它调用 Get(&quot;translate&quot;) 返回翻译值。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/miscellaneous/i18n</span></span><br><span class="line">    Translate(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 路径, 主机, 子域名, IP, HTTP 头 等                            |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Method 返回 request.Method， 客户端的请求方法。</span></span><br><span class="line">    Method() <span class="type">string</span></span><br><span class="line">    <span class="comment">// Path 返回完整请求路径，如果 EnablePathEscape 为 True，将会转义。</span></span><br><span class="line">    Path() <span class="type">string</span></span><br><span class="line">    <span class="comment">// RequestPath 返回转义过的请求完整路径。</span></span><br><span class="line">    RequestPath(escape <span class="type">bool</span>) <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Host 返回当前URL的主机部分。</span></span><br><span class="line">    Host() <span class="type">string</span></span><br><span class="line">    <span class="comment">// Subdomain 返回当前请求的子域名，如果有。</span></span><br><span class="line">    <span class="comment">// 提醒，这个方法可能在某些情况下不能正常使用。</span></span><br><span class="line">    Subdomain() (subdomain <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// RemoteAddr 尝试解析并返回客户端正式IP。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 基于允许的头名称，可以通过 Configuration.RemoteAddrHeaders  修改。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果基于这些请求头的解析失败，将会 Request 的 `RemoteAddr` 字段，它在 Http 处理方法之前有 server 填充。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 查看 `Configuration.RemoteAddrHeaders`,</span></span><br><span class="line">    <span class="comment">//      `Configuration.WithRemoteAddrHeader(...)`,</span></span><br><span class="line">    <span class="comment">//      `Configuration.WithoutRemoteAddrHeader(...)` 获取更多信息。</span></span><br><span class="line">    RemoteAddr() <span class="type">string</span></span><br><span class="line">    <span class="comment">// GetHeader 返回指定的请求头值。</span></span><br><span class="line">    GetHeader(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// IsAjax 返回这个请求是否是一个 &#x27;ajax request&#x27;( XMLHttpRequest)。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 不能百分之百确定一个请求是否是Ajax模式。</span></span><br><span class="line">    <span class="comment">// 永远不要信任来自客户端的数据，他们很容易被篡改。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 提醒，&quot;X-Requested-With&quot; 头可以被任何客户端修改，对于十分严重的情况，不要依赖于 IsAjax。</span></span><br><span class="line">    <span class="comment">// 试试另外的鉴别方式，例如，内容类型（content-type）。</span></span><br><span class="line">    <span class="comment">// 有很多描述这些问题的博客并且提供了很多不同的解决方案，这就是为什么说 `IsAjax` </span></span><br><span class="line">    <span class="comment">// 太简单，只能用于一般目的。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 更多请看： https://developer.mozilla.org/en-US/docs/AJAX</span></span><br><span class="line">    <span class="comment">// 以及： https://xhr.spec.whatwg.org/</span></span><br><span class="line">    IsAjax() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 响应头助手                                                   |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Header 添加响应头到响应 writer。</span></span><br><span class="line">    Header(name <span class="type">string</span>, value <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContentType 设置响应头 &quot;Content-Type&quot; 为 &#x27;cType&#x27;。</span></span><br><span class="line">    ContentType(cType <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// GetContentType 返回响应头 &quot;Content-Type&quot; 的值。</span></span><br><span class="line">    GetContentType() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// StatusCode 设置响应状态码。</span></span><br><span class="line">    <span class="comment">// 也可查看 .GetStatusCode。</span></span><br><span class="line">    StatusCode(statusCode <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// GetStatusCode 返回当前响应的状态码。</span></span><br><span class="line">    <span class="comment">// 也可查阅 StatusCode。</span></span><br><span class="line">    GetStatusCode() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redirect 发送一个重定向响应到客户端，接受两个参数，字符串和可选的证书。</span></span><br><span class="line">    <span class="comment">// 第一个参数是重定向的URL，第二个是重定向状态码，默认是302。</span></span><br><span class="line">    <span class="comment">// 如果必要，你可以设置为301，代表永久转义。</span></span><br><span class="line">    Redirect(urlToRedirect <span class="type">string</span>, statusHeader ...<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 各种请求和 POST 数据                                         |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// URLParam 返回请求中的参数，如果有。</span></span><br><span class="line">    URLParam(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// URLParamInt 从请求返回 int 类型的URL参数，如果解析失败，返回错误。</span></span><br><span class="line">    URLParamInt(name <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// URLParamInt64 从请求返回 int64 类型的参数，如果解析失败，返回错误。</span></span><br><span class="line">    URLParamInt64(name <span class="type">string</span>) (<span class="type">int64</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// URLParams 返回请求查询参数映射，如果没有，返回为空。</span></span><br><span class="line">    URLParams() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FormValue 返回一个表单值。</span></span><br><span class="line">    FormValue(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// FormValues 从 data，get，post 和 查询参数中返回所有的数据值以及他们的键。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 提醒: 检查是否是 nil 是很有必要的。</span></span><br><span class="line">    FormValues() <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span></span><br><span class="line">    <span class="comment">// PostValue 仅仅根据名称返回表单的post值，类似于 Request.PostFormValue。</span></span><br><span class="line">    PostValue(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// FormFile 返回键指定的第一个文件。</span></span><br><span class="line">    <span class="comment">// 如果有必要，FormFile 调用 ctx.Request.ParseMultipartForm 和 ParseForm。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 类似于 Request.FormFile.</span></span><br><span class="line">    FormFile(key <span class="type">string</span>) (multipart.File, *multipart.FileHeader, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 自定义 HTTP 错误                                             |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NotFound 发送一个 404 错误到客户端，使用自定义的错误处理方法。</span></span><br><span class="line">    <span class="comment">// 如果你不想剩下的处理方法被执行，你可能需要去调用 ctx.StopExecution()。</span></span><br><span class="line">    <span class="comment">// 你可以将错误码改成更具体的，例如：</span></span><br><span class="line">    <span class="comment">// users := app.Party(&quot;/users&quot;)</span></span><br><span class="line">    <span class="comment">// users.Done(func(ctx context.Context)&#123; if ctx.StatusCode() == 400 &#123; /*  custom error code for /users */ &#125;&#125;)</span></span><br><span class="line">    NotFound()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | Body Readers                                               |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SetMaxRequestBodySize 设置请求体大小的上限，应该在读取请求体之前调用。</span></span><br><span class="line">    SetMaxRequestBodySize(limitOverBytes <span class="type">int64</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UnmarshalBody 读取请求体，并把它绑定到一个任何类型或者指针的值。</span></span><br><span class="line">    <span class="comment">// 使用实例: context.ReadJSON, context.ReadXML。</span></span><br><span class="line">    UnmarshalBody(v <span class="keyword">interface</span>&#123;&#125;, unmarshaler Unmarshaler) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ReadJSON 从请求体读取 JSON，并把它绑定到任何json有效类型的值。</span></span><br><span class="line">    ReadJSON(jsonObject <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ReadXML 从请求体读取 XML，并把它绑定到任何xml有效类型的值。</span></span><br><span class="line">    ReadXML(xmlObject <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ReadForm 是用表单数据绑定 formObject，支持任何类型的结构体。</span></span><br><span class="line">    ReadForm(formObject <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | Body (raw) Writers                                         |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write 将数据作为一个HTTP响应的一部分写入连接。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 如果 WriteHeader 还没有调用，Write 将在 写入数据之前调用 WriteHeader(http.StatusOK)。</span></span><br><span class="line">    <span class="comment">// 如果 Header 没有 Content-Type，Write 添加一个 Content-Type，设置为写入数据的前</span></span><br><span class="line">    <span class="comment">// 512 字节的类型。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 取决于 HTTP 版本和客户端，调用 Write 或者 WriteHeader 可能组织以后读取 Request.Body。</span></span><br><span class="line">    <span class="comment">// 对于 HTTP/1.x 请求，处理方法应该在写入响应之前读取所有必要的请求体数据。一旦 HTTP 头被清掉</span></span><br><span class="line">    <span class="comment">// (显示调用 Flusher.Flush 或者写入了足够的数据触发了清空操作)，请求体可能变得不可用。</span></span><br><span class="line">    <span class="comment">// 对于 HTTP/2 请求，Go HTTP 服务器允许在写入响应的同时读取请求体。然而，这种行为可能不被所有</span></span><br><span class="line">    <span class="comment">// HTTP/2 客户端支持。处理方法应该尽可能读取最大量的数据在写入之前。</span></span><br><span class="line">    Write(body []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Writef 根据格式声明器格式化，然后写入响应。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回写入的字节数量以及任何写入错误。</span></span><br><span class="line">    Writef(format <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// WriteString 将一个简单的字符串写入响应。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 返回写入的字节数量以及任何写入错误。</span></span><br><span class="line">    WriteString(body <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// WriteWithExpiration 很像 Write，但是它发送了一个失效时间，它会被每个包级别的</span></span><br><span class="line">    <span class="comment">// `StaticCacheDuration` 字段刷新。</span></span><br><span class="line">    WriteWithExpiration(body []<span class="type">byte</span>, modtime time.Time) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// StreamWriter 注册给定的流用于发布响应体。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这个函数可能被用于一下这些情况：</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">//     * 如果响应体太大（超过了iris.LimitRequestBodySize）</span></span><br><span class="line">    <span class="comment">//     * 如果响应体是慢慢从外部资源流入</span></span><br><span class="line">    <span class="comment">//     * 如果响应体必须分片流向客户端（例如 `http server push`）</span></span><br><span class="line">    StreamWriter(writer <span class="function"><span class="keyword">func</span><span class="params">(w io.Writer)</span></span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 带压缩的 Body Writers                            |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">// 如果客户端支持 gzip 压缩，ClientSupportsGzip 返回 true。</span></span><br><span class="line">    ClientSupportsGzip() <span class="type">bool</span></span><br><span class="line">    <span class="comment">// WriteGzip accepts bytes, which are compressed to gzip format and sent to the client.</span></span><br><span class="line">    <span class="comment">// WriteGzip 接受压缩成 gzip 格式的字节然后发送给客户端，并返回写入的字节数量和错误（如果错误不支持 gzip 格式）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。</span></span><br><span class="line">    WriteGzip(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// TryWriteGzip 接受 gzip 格式压缩的字节，然后发送给客户端。</span></span><br><span class="line">    <span class="comment">// 如果客户端不支持 gzip，就按照他们原来未压缩的样子写入。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。</span></span><br><span class="line">    TryWriteGzip(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// GzipResponseWriter converts the current response writer into a response writer</span></span><br><span class="line">    <span class="comment">// GzipResponseWriter 将当前的响应 writer 转化为一个 gzip 响应 writer。</span></span><br><span class="line">    <span class="comment">// 当它的 .Write 方法被调用的时候，数据被压缩成 gzip 格式然后把他们写入客户端。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 也可以使用 .Disable 禁用以及使用 .ResetBody 回滚到常规的响应写入器。</span></span><br><span class="line">    GzipResponseWriter() *GzipResponseWriter</span><br><span class="line">    <span class="comment">// Gzip 开启或者禁用 gzip 响应写入器，如果客户端支持 gzip 压缩，所以接下来的响应数据将被作为</span></span><br><span class="line">    <span class="comment">// 压缩的 gzip 数据发送给客户端。</span></span><br><span class="line">    Gzip(enable <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 富文本内容渲染器                                              |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewLayout 设置 「布局」选项，如果随后在相同的请求中 .View 被调用。</span></span><br><span class="line">    <span class="comment">// 当需要去改变或者设置处理链中前一个方法的布局时很有用。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 注意 &#x27;layoutTmplFile&#x27; 参数可以被设置为 iris.NoLayout 或者 view.NoLayout 去禁用某个试图渲染动作的布局。</span></span><br><span class="line">    <span class="comment">// 它禁用了配置项的布局属性。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 也可查看 .ViewData 和 .View。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/</span></span><br><span class="line">    ViewLayout(layoutTmplFile <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewData 保存一个或者多个键值对为了在后续的 .View 被调用的时候使用。</span></span><br><span class="line">    <span class="comment">// 当需要处理链中前一个处理器的模板数据的时候是很有用的。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果 .View 的绑定参数不是 nil 也不是 map 类型，这些数据就会被忽略，绑定是有优先级的，所以住路由的处理方法仍然有效。</span></span><br><span class="line">    <span class="comment">// 如果绑定是一个map或者context.Map，这些数据然后就被添加到视图数据然后传递给模板。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// .View 调用之后，这些数据不会被丢掉，为了在必要的时候重用（再次声明，同一个请求中），为了清除这些数据，开发者可以调用</span></span><br><span class="line">    <span class="comment">// ctx.Set(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey(), nil)。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 如果 &#x27;key&#x27; 是空的，然后 值被作为它的（struct 或者 map）添加，并且开发者不能添加其他值。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 推荐查看 .ViewLayout 和 .View。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/</span></span><br><span class="line">    ViewData(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetViewData 返回 `context#ViewData` 注册的值。</span></span><br><span class="line">    <span class="comment">// 返回值是 `map[string]interface&#123;&#125;` 类型，这意味着如果一个自定义的结构体被添加到 ViewData， 这个函数将把它解析成</span></span><br><span class="line">    <span class="comment">// map，如果失败返回 nil。</span></span><br><span class="line">    <span class="comment">// 如果不同类型的值或者没有数据通过 `ViewData` 注册，检查是否为nil总是好的编程规范。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 类似于 `viewData := ctx.Values().Get(&quot;iris.viewData&quot;)` 或者 </span></span><br><span class="line">    <span class="comment">// `viewData := ctx.Values().Get(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey())`。</span></span><br><span class="line">    GetViewData() <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// View 基于适配的视图引擎渲染模板。第一个参数是接受相对于视图引擎目录的文件名，</span></span><br><span class="line">    <span class="comment">// 例如如果目录是 &quot;./templates&quot;，想要渲染： &quot;./templates/users/index.html&quot;</span></span><br><span class="line">    <span class="comment">// 你应该传递 &quot;users/index.html&quot; 作为文件名参数。</span></span><br><span class="line">    <span class="comment">// 也可以查看 .ViewData 和 .ViewLayout。</span></span><br><span class="line">    <span class="comment">// 示例：https://github.com/kataras/iris/tree/master/_examples/view/</span></span><br><span class="line">    View(filename <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary 将原生字节作为二进制数据返回。</span></span><br><span class="line">    Binary(data []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Text 将字符串作为空白文本返回。</span></span><br><span class="line">    Text(text <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// HTML 将字符串作为 text/html 返回.</span></span><br><span class="line">    HTML(htmlContents <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// JSON 格式化给定的数据并且返回 json 数据。</span></span><br><span class="line">    JSON(v <span class="keyword">interface</span>&#123;&#125;, options ...JSON) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// JSONP 格式化给定的数据并且返回 json 数据。</span></span><br><span class="line">    JSONP(v <span class="keyword">interface</span>&#123;&#125;, options ...JSONP) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// XML 格式话给定数据，并返回 XML 数据。</span></span><br><span class="line">    XML(v <span class="keyword">interface</span>&#123;&#125;, options ...XML) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Markdown 解析 markdown 数据为 HTML 返回给客户端。</span></span><br><span class="line">    Markdown(markdownB []<span class="type">byte</span>, options ...Markdown) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 文件响应                                                     |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServeContent 返回的内容头是自动设置的，接受三个参数，它是一个低级的函数，你可以调用 .ServeFile(string,bool)/SendFile(string,string)。</span></span><br><span class="line">    <span class="comment">// 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，不要实现 resuming，而应该使用 ctx.SendFile。</span></span><br><span class="line">    ServeContent(content io.ReadSeeker, filename <span class="type">string</span>, modtime time.Time, gzipCompression <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">    <span class="comment">// ServeFile 渲染一个视图文件，如果要发送一个文件（例如zip文件）到客户端，你应该使用 SendFile(serverfilename,clientfilename)。</span></span><br><span class="line">    <span class="comment">// 接受两个参数：</span></span><br><span class="line">    <span class="comment">// filename/path (string)</span></span><br><span class="line">    <span class="comment">// gzipCompression (bool)</span></span><br><span class="line">    <span class="comment">// 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，这个函数没有实现 resuming，你应该使用 ctx.SendFile。</span></span><br><span class="line">    ServeFile(filename <span class="type">string</span>, gzipCompression <span class="type">bool</span>) <span class="type">error</span></span><br><span class="line">    <span class="comment">// SendFile 发送强制下载的文件到客户端</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 使用这个而不是 ServeFile 用于大文件下载到客户端。</span></span><br><span class="line">    SendFile(filename <span class="type">string</span>, destinationName <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | Cookies                                                    |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SetCookie 添加cookie</span></span><br><span class="line">    SetCookie(cookie *http.Cookie)</span><br><span class="line">    <span class="comment">// SetCookieKV 添加一个 cookie，仅仅接受一个名字（字符串）和一个值（字符串）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果你用这个方法设置cookie，它将在两小时之后失效。</span></span><br><span class="line">    <span class="comment">// 如果你想去设置或者改变更多字段，使用 ctx.SetCookie 或者 http.SetCookie。</span></span><br><span class="line">    SetCookieKV(name, value <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// GetCookie 通过名称返回值，如果没找到返回空字符串。</span></span><br><span class="line">    GetCookie(name <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    <span class="comment">// RemoveCookie 通过名字删除 cookie。</span></span><br><span class="line">    RemoveCookie(name <span class="type">string</span>)</span><br><span class="line">    <span class="comment">// VisitAllCookies 接受一个 visitor 循环每个cookie，visitor 接受两个参数：名称和值。</span></span><br><span class="line">    VisitAllCookies(visitor <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, value <span class="type">string</span>)</span></span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MaxAge 返回 &quot;cache-control&quot; 请求头的值，单位为：秒，类型为 int64</span></span><br><span class="line">    <span class="comment">// 如果头没有发现或者解析失败返回 -1。</span></span><br><span class="line">    MaxAge() <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line">    <span class="comment">//  | 高级部分: 响应记录器和事务                                     |</span></span><br><span class="line">    <span class="comment">//  +------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record 转化上下文基本的 responseWriter 为 ResponseRecorder，它可以被用于在任何时候重置内容体，</span></span><br><span class="line">    <span class="comment">// 重置响应头，获取内容体，获取和设置状态码。</span></span><br><span class="line">    Record()</span><br><span class="line">    <span class="comment">// Recorder 返回上下文的 ResponseRecorder，如果没有 recording 然后它将开始记录并返回新的上下文的 ResponseRecorder。</span></span><br><span class="line">    Recorder() *ResponseRecorder</span><br><span class="line">    <span class="comment">// IsRecording 返回响应记录器以及一个bool值</span></span><br><span class="line">    <span class="comment">// true 表示响应记录器正在记录状态码，内容体，HTTP 头以及更多，否则就是 false</span></span><br><span class="line">    IsRecording() (*ResponseRecorder, <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeginTransaction 开启一个有界事务。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 你可以搜索第三方文章或者查看事务 Transaction 如何工作（这里相当简单特别）。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 记着这个是唯一的，也是新的，目前为止，我没有在这个项目中看到任何例子和代码，就大多数 iris 功能而言。</span></span><br><span class="line">    <span class="comment">// 它没有覆盖所有路径，例如数据库，这个应该由你使用的创建数据库连接的库管理，这个事务域仅仅用于上下文响应，</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 阅读 https://github.com/kataras/iris/tree/master/_examples/ 查看更多。</span></span><br><span class="line">    BeginTransaction(pipe <span class="function"><span class="keyword">func</span><span class="params">(t *Transaction)</span></span>)</span><br><span class="line">    <span class="comment">// 如果调用 SkipTransactions 将跳过剩余的事务，或者如果在第一个事务之前调用，将跳过所有</span></span><br><span class="line">    SkipTransactions()</span><br><span class="line">    <span class="comment">// TransactionsSkipped 返回事务到底被跳过还是被取消了。</span></span><br><span class="line">    TransactionsSkipped() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec根据这个上下文调用framewrok的ServeCtx，但是改变了方法和路径，就像用户请求的那样，但事实并非如此。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 离线意味着路线已注册到 iris 并具有正常路由所具有的所有功能。</span></span><br><span class="line">    <span class="comment">// 但是它不能通过浏览获得，它的处理程序仅在其他处理程序的上下文调用它们时执行，它可以验证路径，拥有会话，路径参数等。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 你可以通过 app.GetRoute(&quot;theRouteName&quot;) 找到路由，你可以设置一个路由名称如：</span></span><br><span class="line">    <span class="comment">// myRoute := app.Get(&quot;/mypath&quot;, handler)(&quot;theRouteName&quot;)</span></span><br><span class="line">    <span class="comment">// 这个将给路由设置一个名称并且返回它的 RouteInfo 实例为了进一步使用。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 它不会更改全局状态，如果路由处于“脱机”状态，它将保持脱机状态。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// app.None(...) and app.GetRoutes().Offline(route)/.Online(route, method)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 实例：https://github.com/kataras/iris/tree/master/_examples/routing/route-state</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 用户可以通过简单调用得到响应：rec := ctx.Recorder(); rec.Body()/rec.StatusCode()/rec.Header()</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Context 的 Values 和 Session 被记住为了能够通过结果路由通信，</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 它仅仅由于特别案例，99% 的用户不会用到的。</span></span><br><span class="line">    Exec(method <span class="type">string</span>, path <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Application 返回 属于这个上下文的 iris 实例。</span></span><br><span class="line">    <span class="comment">// 值得留意的是这个函数返回 Application 的一个接口，它包含的方法能够安全地在运行是执行。</span></span><br><span class="line">    <span class="comment">// 为了开发者的安全性，整个 app 的 字段和方法这里是不可用的。</span></span><br><span class="line">    Application() Application</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:并发</title>
      <link href="/2023/04/07/go-%E5%B9%B6%E5%8F%91/"/>
      <url>/2023/04/07/go-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该代码的运行结果不唯一，因为是两个goroutine在执行</span></span><br></pre></td></tr></table></figure><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>通道是用来传递数据的数据结构</p><p>通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于制定通道的方向，如果未指定方向，则为双向通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v<span class="comment">// 把v发送到ch</span></span><br><span class="line">v := &lt;-ch<span class="comment">// 从ch接收数据</span></span><br><span class="line"><span class="comment">// 并把值赋给v</span></span><br><span class="line"><span class="comment">// 声明一个通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p><strong>默认情况下，通道是不带缓冲区的。</strong></p><h2 id="带缓冲区的通道"><a href="#带缓冲区的通道" class="headerlink" title="带缓冲区的通道"></a>带缓冲区的通道</h2><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><p>Go通过range关键字来实现遍历读取到的数据，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;- ch</span><br></pre></td></tr></table></figure><h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2><p>如果通道接收不到数据后ok就为false，这时通道就可以使用close函数来关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:方法与接口</title>
      <link href="/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="7-1-接口的定义"><a href="#7-1-接口的定义" class="headerlink" title="7.1 接口的定义"></a>7.1 接口的定义</h1><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><p>接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。</p><p>Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab *itab;</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="7-2-接口使用实例"><a href="#7-2-接口使用实例" class="headerlink" title="7.2 接口使用实例"></a>7.2 接口使用实例</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;<span class="comment">// 定义了一个接口Phone, 有方法call()</span></span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;<span class="comment">// 接口Phone的一个实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;<span class="comment">// 接口Phone的一个实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone<span class="comment">// 利用接口实现多态</span></span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go:数据</title>
      <link href="/2023/04/05/go-%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/04/05/go-%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-字符串string"><a href="#5-1-字符串string" class="headerlink" title="5.1 字符串string"></a>5.1 字符串string</h1><p><strong>字符串是不可变字符序列</strong></p><p><strong>默认值为空串，而不是空指针。</strong></p><p><strong>遍历</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&#x27;Hello, world&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// byte</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;%d: [%c]\n&quot;</span>, i, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rune</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;%d ,[%c]\n&quot;</span>, i, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="5-2-数组"><a href="#5-2-数组" class="headerlink" title="5.2 数组"></a>5.2 数组</h1><h2 id="5-2-1-数组的初始化"><a href="#5-2-1-数组的初始化" class="headerlink" title="5.2.1 数组的初始化"></a>5.2.1 数组的初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">4</span>]<span class="type">int</span><span class="comment">// 元素自动初始成0</span></span><br><span class="line">    b := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">5</span>&#125;<span class="comment">// 剩余元素自动初始化成0</span></span><br><span class="line">    c := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">3</span>:<span class="number">10</span>&#125;;<span class="comment">// 指定索引位置</span></span><br><span class="line">    d := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">// 编译器确定数组长度</span></span><br><span class="line">    <span class="comment">// 在定义多维数组时， 仅第一维允许使用...</span></span><br><span class="line">    b := [...][<span class="number">2</span>]<span class="type">int</span> &#123;</span><br><span class="line">        &#123;<span class="number">10</span>, <span class="number">20</span>&#125;, </span><br><span class="line">        &#123;<span class="number">30</span> ,<span class="number">40</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-2-指针"><a href="#5-2-2-指针" class="headerlink" title="5.2.2 指针"></a>5.2.2 指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">10</span> ,<span class="number">20</span></span><br><span class="line">    a := [...]*<span class="type">int</span>&#123;&amp;x, &amp;y&#125;<span class="comment">//指针数组</span></span><br><span class="line">    p = &amp;a<span class="comment">//数组指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-3-复制"><a href="#5-2-3-复制" class="headerlink" title="5.2.3 复制"></a>5.2.3 复制</h2><p><strong>与C数组变量隐式作为指针使用不同， Go数组是值类型，赋值和传参工作都会复制整个数组数据</strong></p><h1 id="5-3-切片"><a href="#5-3-切片" class="headerlink" title="5.3 切片"></a>5.3 切片</h1><p><strong>slice本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="keyword">type</span> slice strcut &#123;</span><br><span class="line">    arrary unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span><span class="comment">//限定可读的写元素数量</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="type">int</span><span class="comment">// 切片所引用数组片段的真实长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切片本身是一个只读对象， 其工作机制类似数组指针的一种包装</strong></p><h2 id="5-3-1-创建切片对象"><a href="#5-3-1-创建切片对象" class="headerlink" title="5.3.1 创建切片对象"></a>5.3.1 创建切片对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)<span class="comment">//指定len, cap, 底层数组初始化成零值 </span></span><br><span class="line">    s2 := <span class="built_in">make</span>([<span class="type">int</span>], <span class="number">3</span>)<span class="comment">// 省略cap, 和len相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片是包装过的数组对象，用来代替数组减少值传递带来的开销</p><h1 id="5-4-字典"><a href="#5-4-字典" class="headerlink" title="5.4 字典"></a>5.4 字典</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;</span><br><span class="line">        <span class="string">&quot;a&quot;</span>: <span class="number">1</span>, </span><br><span class="line">        <span class="string">&quot;b&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断key是否存在</span></span><br><span class="line">    <span class="keyword">if</span> v, ok := m[<span class="string">&quot;d&quot;</span>]; ok &#123;</span><br><span class="line">        <span class="built_in">println</span>(v)</span><br><span class="line">    &#125;<span class="comment">// 访问不存在的键值， 默认返回零值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim杂谈</title>
      <link href="/2023/04/02/vim%E6%9D%82%E8%B0%88/"/>
      <url>/2023/04/02/vim%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>vim是Linux环境下的一款重要的文本编辑器。</p><span id="more"></span><h1 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h1><h2 id="1-1-三种基本模式"><a href="#1-1-三种基本模式" class="headerlink" title="1.1 三种基本模式"></a>1.1 三种基本模式</h2><ol><li>一般模式</li><li>编辑模式</li><li>命令行模式</li></ol><h2 id="1-2-按键"><a href="#1-2-按键" class="headerlink" title="1.2 按键"></a>1.2 按键</h2><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><p>(hjkl)对应(左下上右)“30j” &#x3D; 向下移动三十行</p><p>C+f 屏幕向下移动一页</p><p>C+b 屏幕向上移动一页</p><p>“+” 光标移动到非空格行的下一行</p><p>“-“ 光标移动到非空格行的上一行</p><p>n<space> 光标向后移动20个字符的距离</p><p>n[Enter] 光标向下移动n行</p><p>G 移动到这个文件的最后一行</p><p>&#x2F;word 向下寻找名为word的字符串</p><p>dd 删除光标所在的一整行</p><p>yy 复制一整行</p><p>x [delete] X[backsapce]</p><p>u 复原前一个操作</p><p>C+r 重做上一个操作</p><p>. 重复前一个操作</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.虚拟内存</title>
      <link href="/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><strong>虚拟存储器</strong>：</p><p>三个能力：</p><ol><li>将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。</li><li>为每个进程提供了一致的地址空间，从而简化了存储管理。</li><li>保护了每个进程的地址空间不被其他进程破坏。</li></ol><span id="more"></span><h2 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h2><p>CPU—(VA)–&gt;MMU—-&gt;PA—–&gt;Memory</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.异常控制流</title>
      <link href="/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
      <url>/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>CSAPP关于异常处理的章节。</p><span id="more"></span><h1 id="8-4进程控制"><a href="#8-4进程控制" class="headerlink" title="8.4进程控制"></a>8.4进程控制</h1><h2 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取进程的pid</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 获取进程父进程的pid</span></span><br></pre></td></tr></table></figure><h2 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">exit函数以status退出状态来终止进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父进程通过调用fork函数创建一个新的运行的子进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回值：子进程返回0，父进程返回子进程的PID，如果出错，返回-1.</span></span><br></pre></td></tr></table></figure><p>fork被调用一次，却会返回两次：父进程返回子进程的PID，子进程返回0.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        prinf(<span class="string">&quot;child: x = %d\n&quot;</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prinf(<span class="string">&quot;parent: x = %d\n&quot;</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">parent: x = 0</span></span><br><span class="line"><span class="comment">child: x = 2</span></span><br><span class="line"><span class="comment">or </span></span><br><span class="line"><span class="comment">child: x = 2</span></span><br><span class="line"><span class="comment">parent: x = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h2><p>如果一个父进程终止，内核会安排init进程成为他的孤儿进程的养父</p><h2 id="8-4-6"><a href="#8-4-6" class="headerlink" title="8.4.6"></a>8.4.6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个简单的shell的main例程 */</span></span><br><span class="line"><span class="comment">/*shellex.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128</span></span><br><span class="line"><span class="comment">/* Function protoytpes */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span>* buf, <span class="type">char</span>** argv)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span>** argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> cmdline[MAXLINE];<span class="comment">// Command line</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Read */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">        Fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Evaluate */</span></span><br><span class="line">        eval(cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Evaluate a commmand line*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span>* cmdline)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS];</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> bg;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    bg = parseline(buf, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">// Ignore empty line</span></span><br><span class="line">    <span class="keyword">if</span> (!builtin_command(argv)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Parent waits for foreground job to terminate</span></span><br><span class="line">        <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">if</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                unix_error(<span class="string">&quot;waitfg: waitpid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %s&quot;</span>, pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If first arg is a builtin command, run it and return true*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_command</span><span class="params">(<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* parseline - Parse the command line and build the argv array*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">char</span>* buf, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* delim;<span class="comment">// points to the first space delimiter</span></span><br><span class="line">    <span class="type">int</span> argc;<span class="comment">// number of args</span></span><br><span class="line">    <span class="type">int</span> bg;</span><br><span class="line">    </span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        buf ++;</span><br><span class="line">    <span class="comment">/* build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (delm = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>) ) ) &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        buf = delim + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">            buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>)</span><br><span class="line">        argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h1><p><strong>Linux信号: 软件形式的异常</strong></p><h2 id="8-5-1-信号的术语"><a href="#8-5-1-信号的术语" class="headerlink" title="8.5.1 信号的术语"></a>8.5.1 信号的术语</h2><p>发送信号到用户进程的步骤：</p><ul><li><p>发送信号。 方式： 更新进程上下文的状态。 发送信号的原因： 1. 监测到异常、2进程调用了kill。</p></li><li><p>接收信号。进程接收信号并将信号转移给信号处理程序。</p></li></ul><h2 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h2><h3 id="1-进程组"><a href="#1-进程组" class="headerlink" title="1. 进程组"></a>1. 进程组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">pid <span class="title function_">getgrp</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 返回进程的进程组id</span></span><br><span class="line"><span class="comment">// 子进程与父进程的进程组id默认相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;<span class="comment">// 改变进程的进程组id</span></span><br></pre></td></tr></table></figure><h3 id="2-用-x2F-bin-x2F-kill程序发送信号"><a href="#2-用-x2F-bin-x2F-kill程序发送信号" class="headerlink" title="2. 用&#x2F;bin&#x2F;kill程序发送信号"></a>2. 用&#x2F;bin&#x2F;kill程序发送信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; /bin/kill <span class="number">-9</span> <span class="number">15213</span></span><br><span class="line"><span class="comment">// 发送信号SIGKILL给pid为15213的进程</span></span><br><span class="line">linux&gt; /bin/kill <span class="number">-9</span> <span class="number">-15213</span></span><br><span class="line"><span class="comment">// 发送信号SIGKILL给pgid为15213下的所有进程</span></span><br></pre></td></tr></table></figure><h3 id="3-从键盘发送信号"><a href="#3-从键盘发送信号" class="headerlink" title="3.从键盘发送信号"></a>3.从键盘发送信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + C <span class="comment">// 终止前台作业</span></span><br><span class="line">Ctrl + C <span class="comment">// 挂起前台作业</span></span><br></pre></td></tr></table></figure><h3 id="4-用kill函数发送信号"><a href="#4-用kill函数发送信号" class="headerlink" title="4. 用kill函数发送信号"></a>4. 用kill函数发送信号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C盘扩容教程</title>
      <link href="/2022/06/30/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99C%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
      <url>/2022/06/30/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99C%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。<br>电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。<br>本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。<br>Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。</p><span id="more"></span><h1 id="磁盘的分区"><a href="#磁盘的分区" class="headerlink" title="磁盘的分区"></a>磁盘的分区</h1><p>右击‘此电脑’，可以看到‘管理’，点开‘管理’。<br><img src="/../images/expand_c/management.png" alt="管理我的电脑" title="管理"><br>进入管理界面后，点击左侧的“磁盘管理”，即可进入电脑的磁盘页面。可以看到，我的电脑有两个磁盘，其中磁盘0未分区，磁盘1分为C、D两个分区。<br><img src="/../images/expand_c/management2.png" alt="磁盘管理器" title="磁盘管理器"><br>首先要压缩D盘，如果你有多个磁盘也可以压缩别的磁盘，但不建议这样做。因为磁盘的读取方式不一致可能会造成错误。<br>右击分区D，选择压缩分区，并输入你要压缩的空间大小。<br><img src="/../images/expand_c/zip.png" alt="压缩分区" title="压缩分区"><br>压缩后，你可以看到现在有了未分配的空间。<br>检查一下，可以发现，当前未分配的空间可以给D盘扩容，但却不能给C盘扩容。这是因为逻辑分区之间具有顺序关系。可以理解成当前未分配的空间只能给它前面的分区扩容，而不能给它不相邻的分区扩容。<br><img src="/../images/expand_c/afterzip.png" alt="未分配的空间" title="未分配的空间"><br><img src="/../images/expand_c/expand_d.png" alt="D盘的扩容" title="D盘的扩容"><br><img src="/../images/expand_c/cant_expand_c.png" alt="C盘的扩容" title="C盘的扩容"><br>只使用系统的磁盘管理器是不能直接给C盘扩容的，除非先把数据拷贝好，然后将D盘格式化，再重新将1磁盘分区。这样过于麻烦，下面介绍一下利用软件给C盘扩容的方法。</p><h1 id="使用DiskGenius实现无损扩容"><a href="#使用DiskGenius实现无损扩容" class="headerlink" title="使用DiskGenius实现无损扩容"></a>使用DiskGenius实现无损扩容</h1><p>DiskGenius是一款免费的国产磁盘管理软件，它能够直接用未分区的逻辑分区给主分区扩容。前往DiskGenius的官网可直接下载。<br>进入软件，选中C盘，点击上方的分区选项卡选择扩容分区。<br><img src="/../images/expand_c/DiskGenius.png" alt="扩容分区" title="扩容分区"><br>但现在还别着急，磁盘中可能有的簇未使用，却被标记成了已使用。为了解决这一问题，需要按<code>Windows+x</code>，选择‘Windows PowerShell’，进入管理员界面。<br>在命令行中键入<code>chkdsk /f /x c:</code>,其中’c’代表盘符，建议对所有盘都扫描一遍，保证不出问题。<br>回到刚才的步骤，现在选择未分配的空间，然后按照提示进行操作。<br><img src="/../images/expand_c/expand.png" alt="扩容"><br>然后选中‘重启’,等待软件进行操作，重启两次后，你的C盘就扩容成功了！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网上的教程鱼龙混杂，大多是互相复制粘贴，好多操作都已经过时了，为了扩容C盘我花费了一下午，到处参考教程，不断的试错，最终写成了这篇博客，如果你觉得有用的话，可以分享给你的朋友哦。</p>]]></content>
      
      
      <categories>
          
          <category> 搞机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
