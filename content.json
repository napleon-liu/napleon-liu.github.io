{"meta":{"title":"Napleon","subtitle":"Napleon的个人博客","description":"Talk is cheap, give me the code.","author":"napleon-liu","url":"https://www.napleon.cn"},"pages":[{"title":"categories","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T02:46:26.935Z","comments":true,"path":"categories/index.html","permalink":"https://www.napleon.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-30T07:57:51.000Z","updated":"2023-05-19T04:02:31.987Z","comments":false,"path":"about/index.html","permalink":"https://www.napleon.cn/about/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T09:02:18.622Z","comments":true,"path":"guestbook/index.html","permalink":"https://www.napleon.cn/guestbook/index.html","excerpt":"","text":"欢迎来到我的博客！ 欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的，添加email可以获得更快的回复速度，在nickname栏目输入QQ号可以直接获取你的QQ头像。"},{"title":"","date":"2023-05-14T03:15:31.110Z","updated":"2023-05-14T03:15:31.110Z","comments":true,"path":"css/style.css","permalink":"https://www.napleon.cn/css/style.css","excerpt":"","text":"#recent-posts>.recent-post-item,.layout_page>div:first-child:not(.recent-posts),.layout_post>#page,.layout_post>#post,.read-mode .layout_post>#post { background: var(--light_bg_color) } #aside-content .card-widget { background: var(--light_bg_color) } #web_bg { background: linear-gradient(90deg,rgba(247,149,51,.1),rgba(243,112,85,.1) 15%,rgba(239,78,123,.1) 30%,rgba(161,102,171,.1) 44%,rgba(80,115,184,.1) 58%,rgba(16,152,173,.1) 72%,rgba(7,179,155,.1) 86%,rgba(109,186,130,.1)) }"},{"title":"","date":"2023-05-14T02:59:43.578Z","updated":"2023-05-14T02:59:43.578Z","comments":true,"path":"js/script.js","permalink":"https://www.napleon.cn/js/script.js","excerpt":"","text":""},{"title":"友链","date":"2023-05-04T11:51:28.000Z","updated":"2023-05-04T11:54:12.126Z","comments":true,"path":"link/index.html","permalink":"https://www.napleon.cn/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2023-05-04T11:49:53.000Z","updated":"2023-05-04T11:51:27.099Z","comments":true,"path":"messageboard/index.html","permalink":"https://www.napleon.cn/messageboard/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-29T02:48:59.000Z","updated":"2023-03-29T02:49:18.511Z","comments":true,"path":"tags/index.html","permalink":"https://www.napleon.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"go-内存管理","slug":"go-内存管理","date":"2023-07-26T10:26:44.000Z","updated":"2023-07-26T10:27:59.475Z","comments":true,"path":"2023/07/26/go-内存管理/","link":"","permalink":"https://www.napleon.cn/2023/07/26/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"Go 的内存是自动管理的，我们可以随意定义变量直接使用，不需要考虑变量背后的内存申请和释放的问题。本文意在搞清楚 Go 在方面帮我们做了什么，使我们不用关心那些复杂内存的问题，还依旧能写出较为高效的程序。 Pool程序动态申请内存空间，是要使用系统调用的，比如 Linux 系统上是调用 mmap 方法实现的。但对于大型系统服务来说，直接调用 mmap 申请内存，会有一定的代价。比如： 内核态与用户态之间的切换浪费系统资源 频繁申请小块内存空间容易造成内存碎片 为了保证内存访问具有良好的局部性，开发者需要投入大量的精力去做优化，这是一个很重的负担。 解决方案：对象池（缓存）。 假设系统需要频繁动态申请内存来存放一个数据结构，比如 [10]int 。那么我们完全可以在程序启动之初，一次性申请几百甚至上千个 [10]int 。这样完美的解决了上面遇到的问题： 不需要频繁申请内存了，而是从对象池里拿，程序不会频繁进入内核态。 因为一次性申请一个连续的大空间，对象池会被重复利用，不会出现碎片。 程序频繁访问的就是对象池背后的同一块内存空间，局部性良好。 Golang内存管理Golang 的内存管理本质上就是一个内存池，只不过内部做了很多的优化。比如自动伸缩内存池大小，合理的切割内存块等等。 内存池mheapGolang的程序在启动时，会一次性从操作系统申请一大块内存作为内存池。这块内存空间会放在一个叫mheap的struct中管理，mheap负责将这一块内存切割成不同的区域，并将其中一部分的内存切割成合适的大小。 关于mheap的几个重要概念： page：内存页，一块8K大小的内存空间。 span: 一个或者多个连续的page。 sizeclass：空间规格，标记span中的page应该如何使用。 object：对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object 。假设 object 的大小是 16B ， span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去。 示意图： 内部的整体内存布局如下图所示： mheap.spans: 存储page和span信息，比如一个span的起始地址，page数目。 mheap.bitmap: 存储着各个span中对象的标记信息，比如对象是否可回收。 mheap.arena_start: 将要分配给应用程序使用的空间。 mcentral用途相同的span会以链表的形式组织在一起。这里的用途用sizeclass来表示。 比如当分配一块大小为 n 的内存时，系统计算 n 应该使用哪种 sizeclass ，然后根据 sizeclass 的值去找到一个可用的 span 来用作分配。其中 sizeclass 一共有 67 种(Go1.5)，如图所示： 找到合适的 span 后，会从中取一个 object 返回给上层使用。这些 span 被放在一个叫做 mcentral 的结构中管理。 mheap 将从 OS 那里申请过来的内存初始化成一个大 span (sizeclass&#x3D;0)。然后根据需要从这个大 span 中切出小 span ，放在 mcentral 中来管理。大 span 由 mheap.freelarge 和 mheap.busylarge 等管理。如果 mcentral 中的 span 不够用了，会从 mheap.freelarge 上再切一块，如果 mheap.freelarge 空间不够，会再次从 OS 那里申请内存重复上述步骤。下面是 mheap 和 mcentral 的数据结构： 12345678910111213141516171819202122232425262728293031323334353637383940GOtype mheap struct &#123;// other fields lock mutex free [_MaxMHeapList]mspan // free lists of given length， 1M 以下 freelarge mspan // free lists length &gt;= _MaxMHeapList, &gt;= 1M busy [_MaxMHeapList]mspan // busy lists of large objects of given length busylarge mspan // busy lists of large objects length &gt;= _MaxMHeapList central [_NumSizeClasses]struct &#123;// _NumSizeClasses = 67 mcentral mcentral// other fields&#125;// other fields&#125;// Central list of free objects of a given size.type mcentral struct &#123; lock mutex // 分配时需要加锁 sizeclass int32 // 哪种 sizeclass nonempty mspan // 还有可用的空间的 span 链表 empty mspan // 没有可用的空间的 span 列表&#125; mcachemcental中有一个lock字段，在高并发场景下必要时用锁来避免冲突。 但是锁是低效的，在高并发的服务中，它会使内存申请成为整个系统的瓶颈；所以在mcentral的前面又加了一层mchache。 每一个 mcache 和每一个处理器(P) 是一一对应的，也就是说每一个 P 都有一个 mcache 成员。 Goroutine 申请内存时，首先从其所在的 P 的 mcache 中分配，如果 mcache 没有可用 span ，再从 mcentral 中获取，并填充到 mcache 中。 从 mcache 上分配内存空间是不需要加锁的，因为在同一时间里，一个 P 只有一个线程在其上面运行，不可能出现竞争。没有了锁的限制，大大加速了内存分配。 其他优化Tiny对象面提到的 sizeclass&#x3D;1 的 span，用来给 &lt;&#x3D; 8B 的对象使用，所以像 int32 , byte , bool 以及小字符串等常用的微小对象，都会使用 sizeclass&#x3D;1 的 span，但分配给他们 8B 的空间，大部分是用不上的。并且这些类型使用频率非常高，就会导致出现大量的内部碎片。 所以 Go 尽量不使用 sizeclass&#x3D;1 的 span， 而是将 &lt; 16B 的对象为统一视为 tiny 对象(tinysize)。配时，从 sizeclass&#x3D;2 的 span 中获取一个 16B 的 object 用以分配。如果存储的对象小于 16B ，这个空间会被暂时保存起来 (mcache.tiny 字段)，下次分配时会复用这个空间，直到这个 object 用完为止。 大对象如上面所述，最大的 sizeclass 最大只能存放 32K 的对象。如果一次性申请超过 32K 的内存，系统会直接绕过 mcache 和 mcentral，直接从 mheap 上获取，mheap 中有一个 freelarge 字段管理着超大 span。","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"redis基础","slug":"redis基础","date":"2023-07-24T09:23:33.000Z","updated":"2023-07-26T13:50:04.866Z","comments":true,"path":"2023/07/24/redis基础/","link":"","permalink":"https://www.napleon.cn/2023/07/24/redis%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Redis的基本数据类型基础命令判断一个键是否存在 1EXISTS key 删除键 1DEL key [key...] 获得键值的数据类型 1TYPE key 字符串字符串类型是其他4种数据类型的基础，其他数据类型和字符串类 型的差别从某种角度来说只是组织字符串的形式不同。例如，列表类 型是以列表的形式组织字符串，而集合类型是以集合的形式组织字符串。 命令 赋值与查询 12SET KEY VALUEGET KEY 递增数字 1INCR NUM 当要操作的键不存在时会默认键值为0，所以第一次递增后的结果 是1。当键值不是整数时Redis会提示错误。 增加&#x2F;减少指定的整数 12INCRBY KEY INCREMENTDECRBY KEY DECREMENT 增加指定浮点数 1INCRBYFLOAT key increment 向尾部追加值 1APPEND key value APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value,即相当于SET key value。返回值是追加字符串的总长度。 获取字符串长度 1STRLEN key STRLEN命令返回键值的长度，如果键不存在则返回0。 字符串类型可以存储二进制数据，所以它可以存储任 何编码的字符串。例子中Redis接收到的是使用UTF-8编码的中文，由 于“你”和“好”两个字的UTF-8编码的长度都是3, 因此STRLEN key的返回值为6。 同时获取多个键值 12MGET key [key...]MSET key value[key value...] MGET&#x2F;MSET 与GET&#x2F;SET 相似，不过MGET&#x2F;MSET 可以同时获 得&#x2F;设置多个键的键值。 位操作 1234GETBIT key offsetSETBIT key offset valueBITCOUNT key [start][end]BITOP operation destkey key [key...] 一个字节由8个二进制位组成，Redis提供了4个命令可以直接对二 进制位进行操作。为了演示，我们首先将foo键赋值为bar： 12redis&gt; SET foo barOK bar的3个字母“b”“a”和“r”对应的ASCII码分别为98、97和114，转 换成二进制后分别为1100010、1100001和1110010，所以foo键中的二 进制位结构如图所示：","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.napleon.cn/tags/SQL/"},{"name":"Redis","slug":"Redis","permalink":"https://www.napleon.cn/tags/Redis/"}],"keywords":[]},{"title":"http包","slug":"http包","date":"2023-07-21T05:52:10.733Z","updated":"2023-06-30T06:03:10.718Z","comments":true,"path":"2023/07/21/http包/","link":"","permalink":"https://www.napleon.cn/2023/07/21/http%E5%8C%85/","excerpt":"Go 语言中的 http 包提供了创建 http 服务或者访问 http 服务所需要的能力，不需要额外的依赖。在这篇文章中，我们会介绍这些功能的使用，以及看一下 http 包的设计思路。","text":"Go 语言中的 http 包提供了创建 http 服务或者访问 http 服务所需要的能力，不需要额外的依赖。在这篇文章中，我们会介绍这些功能的使用，以及看一下 http 包的设计思路。 概览http标准库的各个组成部分: 发送GET,HEAD,POST,POSTFORM请求： 12345resp, err := http.Get(&quot;http://example.com/&quot;)...resp, err := http.Post(&quot;http://example.com/upload&quot;, &quot;image/jpeg&quot;, &amp;buf)...resp, err := http.PostForm(&quot;http://example.com/form&quot;, url.Values&#123;&quot;key&quot;:&#123;&quot;Value&quot;&#125;, &quot;id&quot;:&#123;&quot;123&quot;&#125;&#125;) 客户端必须在结束时关闭响应体。 1234567resp, err := http.Get(&quot;http://example.com/&quot;)if err != nil &#123; // handle err&#125;defer resp.Body.Close()body, err := io.ReadAll(resp.Body)// ... 可以配置客户端： 12345678910111213client := &amp;http.Client&#123; CheckRedirect: redirectPolicyFunc, &#125;resp, err := client.Get(&quot;http://example.com&quot;)// ...req, err := http.NewRequest(&quot;GET&quot;, &quot;http://example.com&quot;, nil)// ...req.Header.Add(&quot;If-None-Match&quot;, `W/&quot;wyzzy&quot;`)resp, err := client.Do(req)// ... 为了控制代理，TLS配置，等配置，可以创建一个Transport: 1234567tr := &amp;http.Transport &#123; MaxIdleConns: 10, IdleConnTimeout: 30 * time.Second, DisableCompression: true,&#125;client := &amp;http.Client&#123;Transport: tr&#125;resp, err := client.Get(&quot;http://example.com&quot;) ListenAndServe函数使用给定的地址和处理函数开启一个HTTP服务器。handler通常是nil，意味着使用DefaultServeMux。 1234567http.Handle(&quot;/foo&quot;, fooHandler)http.HandleFunc(&quot;/bar&quot;, func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))&#125;)log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil)) 使用定制的服务器来控制服务器的行为 12345678s := &amp;http.Server &#123; Addr: &quot;:8080&quot;, Handler: myHandler, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20&#125;log.Fatal(s.ListenAndServe())","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://www.napleon.cn/tags/Web/"},{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"操作系统课程设计","slug":"操作系统课程设计","date":"2023-05-24T07:30:17.000Z","updated":"2023-07-26T10:29:17.821Z","comments":true,"path":"2023/05/24/操作系统课程设计/","link":"","permalink":"https://www.napleon.cn/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/","excerpt":"文章中的代码我都放在了github上，有需要的可以自取 。记得点个star。","text":"文章中的代码我都放在了github上，有需要的可以自取 。记得点个star。 基础题目Shell编程编写shell脚本，该脚本接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “自己学号的后3位 MYFILE”。 这个比较简单，稍微了解一下shell编程和常用命令就能写出来，不多赘述。 12345678910111213141516171819# read_write.shfilename=&quot;$1&quot;flag=&quot;$2&quot;if [ &quot;$flag&quot; = 0 ]; then # 读取文件内容 content=$(cat &quot;$filename&quot;) echo &quot;文件内容：$content&quot;elif [ &quot;$flag&quot; = 1 ]; then # 获取学号后3位 student_id=&quot;21069100223&quot; last_three_digits=&quot;$&#123;student_id: -3&#125;&quot; # 写入文件 echo &quot;$last_three_digits MYFILE&quot; &gt; &quot;$filename&quot; echo &quot;已成功写入文件：$filename&quot;else echo &quot;无效的标志位!请使用0(读)或1(写)作为第二个参数。&quot;fi 保存文件，在Terminal中执行 12sudo chmod -x read_write.sh # 给予可执行权限./read_write_file.sh &quot;test.txt&quot; 1 系统调用编程使用系统调用open read write,完成一个C语言程序：该程序接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “学号 MYFILE”，其中学号填为自己的学号。改造上面的程序，使用semaphore，并利用该程序生成2个进程，这两个进程写同一个文件，要求：a.互斥写，即只有一个进程写完后，才能让另一个进程写; b. 一个进程写入内容：“自己学号的后3位PROC1 MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2 MYFILE2” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define MAX_SIZE 1024sem_t semaphore;int fd; // 文件描述符void* print1(void* arg) &#123; sem_wait(&amp;semaphore); // printf(&quot;223PROC1 MYFILE1\\n&quot;); char* content = &quot;223PROC1 MYFILE1\\n&quot;; for (int i = 0; i &lt; 19; i++) &#123; write(fd, content + i, 1); &#125; sem_post(&amp;semaphore);&#125;void* print2(void* arg) &#123; sem_wait(&amp;semaphore); // printf(&quot;223PROC2 MYFILE2\\n&quot;); char* content = &quot;223PROC2 MYFILE1\\n&quot;; for (int i = 0; i &lt; 19; i++) &#123; write(fd, content + i, 1); &#125; sem_post(&amp;semaphore);&#125;/** * * @brief 接受两个参数，第一个参数是读写的文件名，第二个参数是标志位，0代表读，1代表写*/int main(int argc, char* argv[]) &#123; // 参数检测 if (argc != 3) &#123; printf(&quot;usage: &lt;filename&gt; &lt;flag&gt;\\n&quot;); exit(1); &#125; // 打开文件 if ((fd = open(argv[1], O_WRONLY | O_APPEND)) == -1) &#123; fprintf(stderr, &quot;fail to open %s\\n&quot;, argv[1]); exit(2); &#125; // 读信息 if(strcmp(argv[2], &quot;0&quot;) == 0) &#123; char buf[MAX_SIZE]; read(fd, buf, MAX_SIZE - 1); printf(&quot;%s&quot;, buf); &#125; // 写信息 else if (strcmp(argv[2], &quot;1&quot;) == 0) &#123; sem_init(&amp;semaphore, 0, 1); // 初始化信号量 pid_t pid = fork(); // 创建子进程 // 子进程 if (pid == 0) &#123; print2(NULL); &#125; else &#123; print1(NULL); &#125; // 父进程 sem_destroy(&amp;semaphore); // 销毁信号量 &#125; else &#123; fprintf(stderr, &quot;usage: 0:read, 1:write.\\n&quot;); &#125; close(fd); // 关闭文件 exit(0);&#125; 编译文件的命令: 1gcc read_write.c -o read_write -pthread 运行结果如下： 内核编程添加一个系统调用, 该系统调用接受两个参数：参数1：以整型数表示的自己学号的后3位；参数2：flag，取值为0或1，若为0，该系统调用的返回值为参数1的个位。若为1。该系统调用的返回值为参数1的十位。 我用的版本是Ubuntu 20.04。源是阿里源。 本文参考https://moefactory.com/3041.moe 编译内核添加系统调用官网地址： https://www.kernel.org/ 。本文写作时最新的稳定版为6.2.11。 安装依赖： 1sudo apt install gcc make libncurses5-dev openssl libssl-dev build-essential pkg-config libc6-dev bison flex libelf-dev 系统调用os_exp，添加在kernel/sys.c中。 1234SYSCALL_DEFINE1(os_exp, long long, id) &#123; long long mod = (id % 2 == 0) ? 1000000 : 100000; return id % mod;&#125; 在include/linux/syscalls.h中添加系统调用的函数声明: 1asmlinkage long sys_os_exp(long long id); 最后在系统调用表中添加我们自定义的系统调用。arch/x86/entry/syscalls/syscall_64.tbl中，在335号系统调用后添加： 1335 common os_exp __x64_sys_os_exp &lt;系统调用编号&gt; common &lt;系统调用名称&gt; &lt;系统调用的函数名称&gt;，这四列之间请使用制表符分隔。注意系统调用的函数名称是有格式要求的，格式为 __x64_sys_&lt;函数名&gt;，而这里的函数名就是之前我们自己拟定的 os_exp。 配置内核代码在下载下来的内核目录下，执行： 1cp -v /boot/config-$(uname -r) .config 目的是为了使我们编译的内核的配置与当前环境的配置一致。 修改.config文件 1234//vim .config// / CONFIG_SYSTEM_TRUSTED_KEYS = &quot;&quot;// / CONFIG_SYSTEM_REVOCATION_KEYS = &quot;&quot;// 结果如下图所示 编译安装内核编译编译命令： 1sudo make -j4 分配线程的数目取决于虚拟机的CPU核数以及每个核的线程数，比如我的虚拟机是双核双线程的，因此选择4线程编译。 安装安装内核模块命令： 1sudo make modules_install 安装内核： 1sudo make install 重启系统并查看新内核： 12sudo rebootuname -a 测试系统调用驱动编程完善1.7节设备驱动例子中的字符设备程序，使之满足以下功能： i.安装设备后从设备中读出字符串为自己学号的后3位； ii. 设备支持每次写入字符不超过1024个，超过部分被丢弃，并且能够保存最近一次修改前的rwbuf里的内容。 iii. 设备支持系统调用ioctl(int d, int req,…),共支持设置三种模式：a. 清除设备中写入的字符串; b. 从设备中读时，读出的是最近一次修改前的内容。 c. 从设备中读时，读出的是最新内容 iv. 设备关闭前不能被多次打开； v. 自己编写测试程序，验证以上功能 此处参考了小梦学长的 博客。为了实现读最新内容和读最近一次修改前的内容两种模式，我设置了两个缓冲区。一个存储最新的信息，另一个在更新信息时保存new_buf的信息，以实现保存最近一次修改前的内容。具体细节参见代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// rwbuf.c#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;// 用于 ioctl 命令#define RW_CLEAR 0x909090#define RW_RDOLD 0x909091#define RW_RDNEW 0x909092// 设备名称#define DEVICE_NAME &quot;rwbuf&quot;// 锁机制，保证只能有一个打开的设备。0 为未打开，1 为已打开static int inuse = 0;// 缓冲区最大长度#define RWBUF_MAX_SIZE 1024// 模式static int mode = 1;// 缓冲区，初始值需要是学号以便能在设备安装后立刻读出static char rwbuf_old[RWBUF_MAX_SIZE] = &quot;223&quot;;static int old_cnt = 3;static char rwbuf_new[RWBUF_MAX_SIZE] = &quot;223&quot;;static int new_cnt = 3;/** * 打开设备 * * @return 0 表示成功，-1 表示失败 */int rwbuf_open(struct inode *inode, struct file *file)&#123; if (inuse == 0) &#123; inuse = 1; // increase the use count in struct module try_module_get(THIS_MODULE); return 0; &#125; else return -1;&#125;/** * 关闭设备 * * @return 0 表示成功 */int rwbuf_release(struct inode *inode, struct file *file)&#123; inuse = 0; // decrease the use count in struct module module_put(THIS_MODULE); return 0;&#125;/** * 将内容写入到设备 * * @param buf 存放待写入内容的缓冲区 * @return 正数表示成功，-1 表示错误 */ssize_t rwbuf_write(struct file *file, const char *buf, size_t count, loff_t *f_pos)&#123; if (count &gt; 0) &#123; strcpy(rwbuf_old, rwbuf_new); old_cnt = new_cnt; new_cnt = count &gt; RWBUF_MAX_SIZE ? RWBUF_MAX_SIZE : count; copy_from_user(rwbuf_new, buf, new_cnt); printk(&quot;[rwbuf] Write successful. After writing, new_cnt = %d\\n&quot;, new_cnt); return new_cnt; &#125; else &#123; printk(&quot;[rwbuf] Write failed. Length of string to be written = %lu\\n&quot;, count); return -1; &#125;&#125;/** * 从设备中读取内容 * * @param buf 存放读取内容的缓冲区 */ssize_t rwbuf_read(struct file *file, char *buf, size_t count, loff_t *f_pos)&#123; if (mode == 1) &#123; copy_to_user(buf, rwbuf_new, count); &#125; else &#123; copy_to_user(buf, rwbuf_old, count); &#125; return count;&#125;/** * ioctl 操作 * * @param arg 要执行的操作 * @return 0 表示成功，-1 表示错误 */long rwbuf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; printk(&quot;[rwbuf] [RW_CLEAR:%x],[cmd:%x]\\n&quot;, RW_CLEAR, cmd); if (cmd == RW_CLEAR) // 清空缓冲区 &#123; new_cnt = 0; printk(&quot;[rwbuf] Do ioctl successful. After doing ioctl, new_cnt = %d\\n&quot;, new_cnt); &#125; else if (cmd == RW_RDNEW) &#123; mode = 1; &#125; else if (cmd == RW_RDOLD) &#123; mode = 0; &#125; else // 无效命令 &#123; printk(&quot;[rwbuf] Do ioctl failed. new_cnt = %d\\n&quot;, new_cnt); return -1; &#125; return 0;&#125;static struct file_operations rwbuf_fops = &#123; open : rwbuf_open, release : rwbuf_release, read : rwbuf_read, write : rwbuf_write, unlocked_ioctl : rwbuf_ioctl &#125;;static int __init rwbuf_init(void)&#123; int ret = -1; printk(&quot;[rwbuf] Initializing device...\\n&quot;); // 60: 主设备号，与创建 /dev/rwbuf 时使用的对应 // DEVICE_NAME: 上面定义的设备名称 // &amp;rwbuf_fops: VFS 相关 ret = register_chrdev(60, DEVICE_NAME, &amp;rwbuf_fops); if (ret != -1) printk(&quot;[rwbuf] Initialize successful\\n&quot;); else printk(&quot;[rwbuf] Initialize failed\\n&quot;); return ret;&#125;static void __exit rwbuf_exit(void)&#123; unregister_chrdev(60, DEVICE_NAME); printk(&quot;[rwbuf] Uninstall successful\\n&quot;);&#125;module_init(rwbuf_init);module_exit(rwbuf_exit);MODULE_LICENSE(&quot;GPL&quot;); 设备的Makefile如下： 1234567891011121314151617# Makefile# 指定编译器CC := gcc# 内核源代码目录KERNEL_DIR := /lib/modules/$(shell uname -r)/build# 模块名称MODULE_NAME := rwbuf# 模块源文件MODULE_SRC := rwbuf.c# 构建目标obj-m := $(MODULE_NAME).o# 构建规则all: $(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules# 清理规则clean: $(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean 测试前需要安装设备，在terminal中依次键入以下命令： 123sudo mknod /dev/rwbuf c 60 0 # 创建虚拟字符设备sudo chmod 777 /dev/rwbuf # 修改设备权限sudo insmod rwbuf.ko # 安装设备驱动 测试程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// test.c#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;#define DEVICE_NAME &quot;/dev/rwbuf&quot;#define RW_CLEAR 0x909090#define RW_RDOLD 0x909091#define RW_RDNEW 0x909092int main() &#123; int fd; int ret; char buf[1024]; fd = open(DEVICE_NAME, O_RDWR); if (fd == -1) &#123; printf(&quot;Open device error&quot;); return 0; &#125; printf(&quot;\\nRead student id...&quot;); if (read(fd, buf, 3) &gt; 0) &#123; buf[3] = &#x27;\\0&#x27;; printf(&quot;%s\\n&quot;, buf); &#125; else &#123; printf(&quot;%s\\n&quot;, buf); &#125; printf(&quot;read old_buf. Then write aaaaa into buf.\\n&quot;); write(fd, &quot;aaaaa&quot;, 5); ioctl(fd, RW_RDOLD); if (read(fd, buf, 3) &gt; 0) &#123; printf(&quot;Old Buffer:%s\\n&quot;, buf); &#125; ioctl(fd, RW_RDNEW); if (read(fd, buf, 5) &gt; 0) &#123; printf(&quot;New Buffer:%s\\n&quot;, buf); &#125; printf(&quot;Write 1100 &#x27;a&#x27;...&quot;); if (write(fd, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;, 1100) == -1) &#123; printf(&quot;Failed\\n&quot;); return 0; &#125; printf(&quot;\\nRead from device...&quot;); if (read(fd, buf, 1024) &gt; 0) &#123; buf[1023] = &#x27;\\0&#x27;; printf(&quot;%s\\n&quot;, buf); &#125; else &#123; printf(&quot;Failed\\n&quot;); return 0; &#125; printf(&quot;\\nClear device...&quot;); if (ioctl(fd, RW_CLEAR) == 0) printf(&quot;Successful\\n&quot;); else &#123; printf(&quot;Failed\\n&quot;); return 0; &#125; ret = close(fd); printf(&quot;Device closed\\n&quot;); return 0;&#125; 编译并执行设备驱动，结果如下图。 测试结果： 最后记得卸载设备 1sudo rmmod rwbuf 中级题目Shell编程编写一个脚本，能够生成完成基础题目（即：“编写shell脚本，该脚本接收两个参数，参数1作为要读写的文件，参数2作为标志位，标识是读还是写。功能完成对参数1所示文件的读写，该文件的内容为 “自己学号的后3位 MYFILE”。“）的脚本，并且自动执行该生成的脚本（执行功能：写入文件）。 写一个脚本，将基础题目的脚本作为内容写进文件里，然后自动执行生成的文件即可。 12345678910111213141516171819202122232425262728293031323334353637383940#!/bin/bash# Set the filename and flag variablesfilename=&quot;$1&quot;flag=&quot;$2&quot;# Generate the script contentscript_content=$(cat &lt;&lt;&#x27;EOF&#x27;#!/bin/bashfilename=&quot;$1&quot;flag=&quot;$2&quot;if [ &quot;$flag&quot; = &quot;0&quot; ]; then # Read file content content=$(cat &quot;$filename&quot;) echo &quot;文件内容：$content&quot;elif [ &quot;$flag&quot; = &quot;1&quot; ]; then # Get the last three digits of the student ID student_id=&quot;21069100223&quot; last_three_digits=&quot;$&#123;student_id: -3&#125;&quot; # Write to the file echo &quot;$last_three_digits MYFILE&quot; &gt; &quot;$filename&quot; echo &quot;已成功写入文件：$filename&quot;else echo &quot;无效的标志位!请使用0(读)或1(写)作为第二个参数。&quot;fiEOF)# Write the script content to a filescript_filename=&quot;rw.sh&quot;echo &quot;$script_content&quot; &gt; &quot;$script_filename&quot;echo &quot;Generated script: $script_filename&quot;# Make the generated script executablechmod +x &quot;$script_filename&quot;# Execute the generated script with the provided arguments./&quot;$script_filename&quot; &quot;$filename&quot; &quot;$flag&quot; 测试结果： 系统调用编程对于基础题目系统调用编程中的第2题（即：使用semaphore，并利用该程序生成2个进程（注意：非线程），这两个进程写同一个文件，要求：a.互斥写，即只有一个进程写完后，才能让另一个进程写; b. 一个进程写入内容：“自己学号的后3位PROC1 MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2 MYFILE2”），将该程序的semaphore替换成使用strict alternation算法的忙等待互斥锁完成。 严格轮换法参考课本。我申请了一块共享内存作为lock，对于父子进程均可见。注意，write具有原子性，我身边有很多人使用一个全局变量作为lock，但是write时直接将一句话写进文件里，这样结果看起来是对的，实际上并没有实现互斥。因为fork()出的子进程是父进程的一个副本，二者的地址空间不同，所以lock不是共享的，实现父子进程之间的通信的方法有很多，可以参考我的另外一篇 博客。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// read_write.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;semaphore.h&gt;#include &lt;syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#define MAX_SIZE 1024int fd; // 文件描述符int* shm_addr;void print1() &#123; while (shm_addr[0] == 0); char* content = &quot;223PROC1 MYFILE1\\n&quot;; for (int i = 0; i &lt; 19; i++) &#123; write(fd, content + i, 1); &#125; shm_addr[0] = 0; &#125;void print2() &#123; while (shm_addr[0] == 1); char* content = &quot;223PROC2 MYFILE1\\n&quot;; for (int i = 0; i &lt; 19; i++) &#123; write(fd, content + i, 1); &#125; shm_addr[0] = 1; &#125;int main(int argc, char* argv[])&#123; int shmid; key_t key; char* filename = argv[1]; char* mode = argv[2]; // for test // char* filename = &quot;myfile.txt&quot;; // char* mode = &quot;1&quot;; key = ftok(&quot;./&quot;, 2023); if (key == -1) &#123; perror(&quot;ftok&quot;); &#125; shmid = shmget(key, MAX_SIZE, IPC_CREAT | 0666); if (shmid &lt; 0) &#123; perror(&quot;shmget&quot;); exit(-1); &#125; // 连接共享内存 shm_addr = shmat(shmid, NULL, 0); // 连接共享内存 shm_addr[0] = 0; if ((fd = open(filename, O_RDONLY)) == -1) &#123; fprintf(stderr, &quot;fail to open %s\\n&quot;, filename); exit(2); &#125; if(strcmp(mode, &quot;0&quot;) == 0) &#123; char buf[MAX_SIZE]; read(fd, buf, MAX_SIZE - 1); printf(&quot;%s&quot;, buf); &#125; // 写信息 else if (strcmp(mode, &quot;1&quot;) == 0) &#123; pid_t pid = fork(); if (pid == 0) &#123; print2(); &#125; else &#123; print1(); &#125; &#125; else &#123; fprintf(stderr, &quot;usage: 0:read, 1:write.\\n&quot;); &#125; close(fd); exit(0);&#125; 编译的命令： 1gcc read_write.c -o read_write -lpthread 测试结果： 内核编程 对于基础题目中的内核编程题（即： 添加一个系统调用, 该系统调用接受两个参数：参数1：以整型数表示的自己学号的后3位；参数2：flag，取值为0或1，若为0，该系统调用的返回值为参数1的个位。若为1。该系统调用的返回值为参数1的十位），进行修改，修改如下： 声明一个内核全局变量gOSE, 该系统首先将参数1的值赋给gOSE，并且，对于参数2：flag，取值为0或1，若为0，将gOSE的值按位取反，后赋值给gOSE，然后返回gOSE的值；若为1，则将gOSE的值与0Xffffffff异或，后赋值给gOSE，然后返回gOSE的值； 加入内核互斥锁，使得两个进程在调用该系统调用时，能够做到互斥访问gOSE。 对于中级题目中系统调用编程的第1题，给出strict alternation算法中turn变量的虚地址，并且给出该变量的物理地址。 驱动编程对基础题目中的驱动编程进行修改增加mmap接口，使其能够通过mmap读写rwbuf中的内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/slab.h&gt;#include &lt;asm/io.h&gt;#include &lt;linux/gfp.h&gt;// 用于 ioctl 命令#define RW_CLEAR 0x909090#define RW_RDOLD 0x909091#define RW_RDNEW 0x909092// 设备名称#define DEVICE_NAME &quot;rwbuf&quot;// 锁机制，保证只能有一个打开的设备。0 为未打开，1 为已打开static int inuse = 0;// 缓冲区最大长度#define RWBUF_MAX_SIZE 1024// 模式static int mode = 1;// 缓冲区，初始值需要是学号以便能在设备安装后立刻读出static char* rwbuf_old;static int old_cnt = 3;static char* rwbuf_new;static int new_cnt = 3;/** * 打开设备 * * @return 0 表示成功，-1 表示失败 */int rwbuf_open(struct inode *inode, struct file *file)&#123; if (inuse == 0) &#123; inuse = 1; // increase the use count in struct module try_module_get(THIS_MODULE); return 0; &#125; else return -1;&#125;/** * 关闭设备 * * @return 0 表示成功 */int rwbuf_release(struct inode *inode, struct file *file)&#123; inuse = 0; // decrease the use count in struct module module_put(THIS_MODULE); return 0;&#125;/** * 将内容写入到设备 * * @param buf 存放待写入内容的缓冲区 * @return 正数表示成功，-1 表示错误 */ssize_t rwbuf_write(struct file *file, const char *buf, size_t count, loff_t *f_pos)&#123; if (count &gt; 0) &#123; // rwbuf_old = rwbuf_new; strcpy(rwbuf_old, rwbuf_new); old_cnt = new_cnt; new_cnt = count &gt; RWBUF_MAX_SIZE ? RWBUF_MAX_SIZE : count; copy_from_user(rwbuf_new, buf, new_cnt); printk(&quot;[rwbuf] Write successful. After writing, new_cnt = %d\\n&quot;, new_cnt); return new_cnt; &#125; else &#123; printk(&quot;[rwbuf] Write failed. Length of string to be written = %lu\\n&quot;, count); return -1; &#125;&#125;/** * 从设备中读取内容 * * @param buf 存放读取内容的缓冲区 */ssize_t rwbuf_read(struct file *file, char *buf, size_t count, loff_t *f_pos)&#123; if (mode == 1) &#123; copy_to_user(buf, rwbuf_new, count); &#125; else &#123; copy_to_user(buf, rwbuf_old, count); &#125; // printk(&quot;[rwbuf] Read successful. After reading, new_cnt = %d\\n&quot;, new_cnt); return count;&#125;/** * ioctl 操作 * * @param arg 要执行的操作 * @return 0 表示成功，-1 表示错误 */long rwbuf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; printk(&quot;[rwbuf] [RW_CLEAR:%x],[cmd:%x]\\n&quot;, RW_CLEAR, cmd); if (cmd == RW_CLEAR) // 清空缓冲区 &#123; new_cnt = 0; printk(&quot;[rwbuf] Do ioctl successful. After doing ioctl, new_cnt = %d\\n&quot;, new_cnt); &#125; else if (cmd == RW_RDNEW) &#123; mode = 1; &#125; else if (cmd == RW_RDOLD) &#123; mode = 0; &#125; else // 无效命令 &#123; printk(&quot;[rwbuf] Do ioctl failed. new_cnt = %d\\n&quot;, new_cnt); return -1; &#125; return 0;&#125;int rwbuf_mmap(struct file *file, struct vm_area_struct *vma) &#123; unsigned long offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT; unsigned long pfn_start = (virt_to_phys(rwbuf_new) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff; unsigned long virt_start = (unsigned long)rwbuf_new + offset; unsigned long size = vma-&gt;vm_end - vma-&gt;vm_start; if (remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, size, vma-&gt;vm_page_prot )) return -EAGAIN; return 0;&#125;static struct file_operations rwbuf_fops = &#123; open : rwbuf_open, release : rwbuf_release, read : rwbuf_read, write : rwbuf_write, unlocked_ioctl : rwbuf_ioctl, mmap : rwbuf_mmap, &#125;;static int __init rwbuf_init(void)&#123; int ret = -1; rwbuf_new = kzalloc(RWBUF_MAX_SIZE, GFP_KERNEL); strcpy(rwbuf_new, &quot;223\\0&quot;); rwbuf_old = kzalloc(RWBUF_MAX_SIZE, GFP_KERNEL); strcpy(rwbuf_old, &quot;223\\0&quot;); printk(&quot;[rwbuf] Initializing device...\\n&quot;); // 60: 主设备号，与创建 /dev/rwbuf 时使用的对应 // DEVICE_NAME: 上面定义的设备名称 // &amp;rwbuf_fops: VFS 相关 ret = register_chrdev(60, DEVICE_NAME, &amp;rwbuf_fops); if (ret != -1) printk(&quot;[rwbuf] Initialize successful\\n&quot;); else printk(&quot;[rwbuf] Initialize failed\\n&quot;); return ret;&#125;static void __exit rwbuf_exit(void)&#123; unregister_chrdev(60, DEVICE_NAME); printk(&quot;[rwbuf] Uninstall successful\\n&quot;);&#125;module_init(rwbuf_init);module_exit(rwbuf_exit);MODULE_LICENSE(&quot;GPL&quot;); 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#define DEVICE_PATH &quot;/dev/rwbuf&quot;#define MAP_SIZE 1024int main() &#123; int fd; char *mapped_addr; // 打开设备文件 // printf(&quot;hello\\n&quot;); fd = open(DEVICE_PATH, O_RDWR); // printf(&quot;hello\\n&quot;); if (fd == -1) &#123; perror(&quot;Failed to open device&quot;); return -1; &#125; // 进行 mmap 映射 // printf(&quot;hello\\n&quot;); mapped_addr = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // mapped_addr[1023] = &#x27;\\0&#x27;; // printf(&quot;hello\\n&quot;); if (mapped_addr == MAP_FAILED) &#123; perror(&quot;Failed to mmap&quot;); close(fd); return -1; &#125; printf(&quot;hello\\n&quot;); // 从映射的内存读取数据 printf(&quot;Device Data: %s\\n&quot;, mapped_addr); // printf(&quot;hello\\n&quot;); // 修改映射的内存中的数据 // mapped_addr[0] = &#x27;A&#x27;; // printf(&quot;hello\\n&quot;); // 解除映射 if (munmap(mapped_addr, MAP_SIZE) == -1) &#123; perror(&quot;Failed to unmap&quot;); close(fd); return -1; &#125; // printf(&quot;hello\\n&quot;); // 关闭设备文件 close(fd); return 0;&#125; 测试结果： 高级题目制作启动盘(选做) 使用麒麟桌面操作系统内核（只能使用麒麟桌面操作系统内核），在不重新编译内核的情况下，制作USB启动盘，使得计算机从USB盘上启动，加载initial ramdisk，并能够自动运行一个shell脚本，该shell 脚本在中端上输出自己学号的后·3位。 对上题的USB启动盘进行修改（注意，无论何种修改，只能使用麒麟桌面操作系统内核），并不能重新编译内核），能够将USB启动盘作为根目录进行挂载，并且从USB盘上启动后，能够自动运行一个shell脚本，该shell 脚本在将自己学号的后·3位写入USB启动盘上的一个文件中。 系统调用编程(必做)编写一个程序，并利用该程序生成2个进程（注意，非线程），这两个进程写同一个文件，要求： a.互斥写，即只有一个进程写完后，才能让另一个进程写; 该互斥实现使用忙等待锁完成互斥。该忙等待锁在x86平台上必须使用xchg和cmp汇编语句完成，如果在arm平台上，必须使用ldrex和strex 和cmp完成，并且，对于锁变量lock，lock为1时表示锁被释放，lock为0时表示上锁。 b. 一个进程写入内容：“自己学号的后3位PROC1 MYFILE1”；另一个进程写入内容：“自己学号的后3位PROC2 MYFILE2” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#define BUFSZ 8#define LOCK_BUSY 0#define LOCK_FREE 1volatile int* lock;void lock_acquire(volatile int *lock)&#123; int tmp = LOCK_BUSY; asm volatile(&quot;xchg %0, %1&quot; : &quot;=r&quot;(tmp) //输出部分 : &quot;m&quot;(*lock), &quot;0&quot;(tmp) //输入部分 : &quot;memory&quot;); while (tmp == LOCK_BUSY) &#123; asm volatile(&quot;pause&quot;:::&quot;memory&quot;); tmp = *lock; asm volatile(&quot;xchg %0, %1&quot; : &quot;=r&quot;(tmp) : &quot;m&quot;(*lock), &quot;0&quot;(tmp) : &quot;memory&quot;); &#125;&#125;void lock_release(volatile int *lock)&#123; asm volatile(&quot;movl %1, %0&quot; : &quot;+m&quot;(*lock) : &quot;r&quot;(LOCK_FREE) : &quot;memory&quot;);&#125;void write_proc(char* fname, char* msg)&#123; lock_acquire(lock); int fd = open(fname, O_CREAT|O_WRONLY|O_APPEND, 0666); if(fd &lt; 0)&#123; perror(&quot;open failed&quot;); exit(1); &#125; // write(fd, msg, strlen(msg)); for (int i = 0; i &lt; strlen(msg); i++) &#123; write(fd, msg+i, 1); &#125; close(fd); lock_release(lock);&#125;int main(void)&#123; int shmid; key_t key; key = ftok(&quot;./&quot;, 2015); if (key == -1) &#123; perror(&quot;ftok&quot;); &#125; shmid = shmget(key, BUFSZ, IPC_CREAT | 0666); if (shmid &lt; 0) &#123; perror(&quot;shmget&quot;); exit(-1); &#125; lock = shmat(shmid, NULL, 0); // 连接共享内存 *lock = LOCK_FREE; int pid = fork(); char fname[] = &quot;./test.txt&quot;; char msg1[128], msg2[128]; sprintf(msg1, &quot;223PROC1 MYFILE1\\n&quot;); sprintf(msg2, &quot;223PROC2 MYFILE2\\n&quot;); if((pid) &lt; 0)&#123; perror(&quot;fork failed&quot;); exit(1); &#125; else if(pid == 0)&#123; //子进程写文件1 write_proc(fname, msg1); &#125; else&#123; //父进程写文件2 write_proc(fname, msg2); &#125; return 0;&#125; 驱动编程(选做) 安装Qemu虚机，注：在线资料中“已安装Qemu的虚机”中解压后是一个vmware虚机，这里称其为VW虚机。VW虚机里面已经安装好Qemu，并且也安装了一个Qemu 虚机，这里称其为QVM，QVM自身并不携带gcc，仅作为示例。VWroot密码是1，QVM的root密码是0；同学可在QVM基础上补完gcc等编程环境，或重新装一个完整的QVM。 对于给出edu设备（它是Qemu虚拟化出的一个设备）的驱动，请对其进行改进，使其能够完成DMA数据传输；并且编写相关的用户态下测试程序进行证明。 内核编程(选做)添加系统调用，根据传入的标志位，通过轮询方式、或DMA方式读取上述edu设备驱动程序的结果","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"},{"name":"os","slug":"os","permalink":"https://www.napleon.cn/tags/os/"}],"keywords":[]},{"title":"go-测试","slug":"go-测试","date":"2023-05-16T14:13:06.000Z","updated":"2023-05-19T09:37:12.366Z","comments":true,"path":"2023/05/16/go-测试/","link":"","permalink":"https://www.napleon.cn/2023/05/16/go-%E6%B5%8B%E8%AF%95/","excerpt":"","text":"编写测试编写测试和函数很类似， 其中有一些规则： 程序需要在一个名为xxx_test.go 的文件中编写 测试函数的命名必须以单词Test开始 测试函数只接受一个参数t *testing.T 测试hello.go1234567891011package mainimport &quot;fmt&quot;func Hello() string &#123; return &quot;Hello, world&quot;&#125;func main() &#123; fmt.Println(Hello())&#125; 测试函数 123456789101112package mainimport &quot;testing&quot;func TestHello(t *testing.T) &#123; got := Hello() want := &quot;Hello, world&quot; if got != want &#123; t.Errorf(&quot;got &#x27;%q&#x27; want &#x27;%q&#x27;&quot;, got, want) &#125;&#125; 在解释这个测试之前，让我们先在终端运行 go test，它应该通过测试了！为了再次验证，可以尝试改变 want 字符串来破坏测试的结果。","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"Linux下进程间通信","slug":"Linux下进程间通信","date":"2023-05-10T03:42:53.000Z","updated":"2023-05-27T02:44:27.849Z","comments":true,"path":"2023/05/10/Linux下进程间通信/","link":"","permalink":"https://www.napleon.cn/2023/05/10/Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"进程的地址空间是相互独立的，因此进程之间交互数据必须需要专门的通信机制。 概述Linux下的主要IPC手段： 管道pipe。数据只能单方面流通， 只能在父子进程间进行。 有名管道named pipe。半双工通信方式，可用于非父子进程通信。 信号量semophore 进程间或不同进程间的同步手段。 消息队列message queue。消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息量少，管道只能承载无格式字节流以及缓冲区大小受限的缺点。 信号signal 共享内存shared memory。 映射一段能被其他进程访问的内存。共享内存能被一个进程创建但是被多个进程访问。 套接字socket。 可用于不同机器间的通信。 管道管道是一个特殊的文件，这个文件只存在与内存中。创建管道时，系统为管道分配一个页面作为数据缓冲区，进行管道通信的两个进程通过读写这个缓冲区来实现通信。 dup与dup2在子进程调用exec函数执行另外一个程序时，可以将子进程的文件描述符重定向到标准输入，新执行的程序能够从标准输入获取数据，实际上是从父进程获取输入数据。 12345#include &lt;unistd.h&gt;// 返回文件描述符，为当前可用文件描述符的最小数值。int dup(int oldfd);// 利用参数newfd指定欲返回的文件描述符。如果newfd指定的文件描述符已经打开，先将其关闭，然后将oldfd指定的文件描述符赋值给该参数。int dup2(int oldfd, int newfd); 有名管道有名管道(named pipe或FIFO)。FIFO不同与管道之处在于它提供了一个路径名与之关联，以FIFO的形式存储与文件系统中。 基本使用创建方式可以用shell创建或者在程序中用系统函数创建。 1234567891011#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;/*path: 有名管道的路径名mod: 模式dev: 设备值return: 成功返回0， 失败返回-1*/int mknod(const char *path, mode_t mod, dev_t dev);int mkfifo(const char *path, mode_t mode); 读写方式有名管道是一个硬盘上的文件，使用前需要先open()将其打开。 有名管道是存在与硬盘上的文件，而管道是存在与内存中的特殊文件 消息队列基本概念消息队列是存放在内核中的一个消息链表，每个消息队列用消息队列标识符标识。与管道不同的是消息队列存放在内核中，只有在内核重启或者显式的删除一个消息队列时，该消息队列才会被真正的删除。 数据结构消息缓冲结构向消息队列发送消息时，必须组成合理的数据 结构。Linux系统定义了一个模板数据结构msgbuf： 1234567#include &lt;linux/msg.h&gt;struct msgbuf &#123; // 消息类型 long mtype; // 消息内容 char mtext[1];&#125; msqid_ds内核数据结构Linux中，每个消息队列都维护着一个结构体msqid_ds。该结构体保存着当前消息队列的状态信息。该结构体定义在linux&#x2F;msg.h中，具体定义如下： ipc_perm内核数据结构ipc_perm保存着消息队列的一些重要信息，比如消息队列关联的键值，消息队列的用户ID、组ID。 创建与读写创建消息队列消息队列是随着内核的存在而存在的，每个消息队列在系统范围内对应唯一的键值。通过ftok函数获取该键值 123#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;ket_t ftok(const char *pathname, int proj_id); 读写消息队列函数原型： 12int msgsnd(int msqid, struct msgbuf *msgp, size_t msgsz, int mapflg);int msgrcv(int msqid, struct msgbuf *msgp, size_t msgsz, long int msgtyp, itn msgflg); 信号量信号量大于等于0时表示可供并发进程使用的资源实体数；小于0时代表正在等待使用临界资源的进程数目。 数据结构12345678910struct semid_ds &#123; struct ipc_perm sem_perm; // 对信号进行操作的许可权 __kernel_time_t sem_otime; // 对信号进行操作的最后时间 __kernel_time_t em_ctime; // 对信号进行修改的最后时间 struct sem *sembase; // 指向第一个信号 struct sem_queue sem_pending; // 等待处理的挂起操作 struct sem_undo *undo; // 撤销的请求 ushort sem_nsems; // 数组中的信号数目 &#125; 共享内存数据结构共享内存是分配一块能被其他进程访问的内存。每个内存块在内核中维护这一个内部结构shmid_ds(和消息队列，信号量)一样，该结构定义在头文件linux&#x2F;shm.h中。 12345struct shmid_ds &#123; struct ipc_perm shm_perm; int shm_segsz; ******&#125; 共享内存区的创建shmget来创建一个共享内存区。原型如下： 123456/*key: ftok得到的键值size: 以字节为单位指定内存的大小shmflg: 操作标志位*/int shmget(key_t key, size_t size, int shmflg); 共享内存区的操作在使用共享内存区之前，必须通过shmat将其附加到进程的地址空间。进程就与共享内存建立了连接。shmat调用成功后会返回一个指向共享内存区的指针，使用该指针即可访问共享内存区，如果失败返回-1.代码原型如下： 123456/*shimid: shmget的返回值shmaddr: 共享内存的附加点，一般设为空，由MMU自动管理shmflg: 存取权限标志*/void* shmat(int shmid, const void *shmaddr, int shmflg); 当进程结束使用共享内存区，要通过函数shmdt断开与共享内存区的连接。该函数声明在sys&#x2F;shm.h中代码原型如下： 1int shmdt(const void *shmaddr); Linux对共享内存区的控制是通过调用函数shmctl来完成的，该函数定义在头文件sys&#x2F;shm.h中，原型代码如下： 123456/*shimid: 共享内存区的标识符buf:指向shmid_ds结构体的指针cmd：操作标志位*/int shmctl(int shmid, int cmd, struct shimid_ds *buf);","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"},{"name":"os","slug":"os","permalink":"https://www.napleon.cn/tags/os/"}],"keywords":[]},{"title":"浅谈wsl","slug":"浅谈wsl","date":"2023-05-03T13:41:39.000Z","updated":"2023-05-27T02:42:23.074Z","comments":true,"path":"2023/05/03/浅谈wsl/","link":"","permalink":"https://www.napleon.cn/2023/05/03/%E6%B5%85%E8%B0%88wsl/","excerpt":"本文简单介绍了WSL的工作原理。","text":"本文简单介绍了WSL的工作原理。 介绍Windows Subsystem for Linux（WSL）是一个用于在本地运行linux二进制可执行文件（ELF格式）的兼容层。 在软件工程领域，兼容层是一个允许面向旧或异质系统的二进制文件运行在特定主机系统上的接口。这意味着将面向异质系统的系统调用转换为面向主机系统。有些库会面向异质系统，这通常是为主机系统提供运行异质二进制文件的能力。而硬件兼容层工具允许硬件仿真。 与虚拟机相比，wsl没有虚拟硬件的过程，而是直接在windows上虚拟一个linux内核，模拟linux系统调用，以运行linux执行文件。 可以简单的将它理解为可以运行linux可执行文件的、类似于powershell的shell，具有互操作性（在linux中执行windows命令，在windows中执行linux命令）。 虚拟机技术的原理 HypervisorHypervisor（虚拟机管理器）是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor）。 WSL原理wsl组件 wsl实现的组件涉及到了用户和内核模式。在Windows NT内核模式中，LXCore，LXSS这两个驱动提供了linux内核调用的实现，即将linux调用转化为对应的windows NT内核调用；还提供了两种文件系统：VolFs（挂载在&#x2F;目录上，支持linux文件系统所有特性）和DriverFs（挂载在&#x2F;mnt&#x2F;c，&#x2F;mnt&#x2F;d等等windows分区，主要为了支持系统间的互操作性）；驱动还会模拟内核的行为，对linux进程进行调度。 在用户模式下，windows提供了一种特殊的进程类型：Pico进程，来支持linux进程的运行。windows会 “放松” 对该类型进程的控制，主要交由linux虚拟内核调用和管理，即隔离性（因此需要系统的支持，低版本的系统不能使用wls的功能）。pico会将ELF二进制可执行文件装入到自己的地址空间，然后执行在linux虚拟内核提供的兼容层上。一个pico对应一个linux进程，并且pico进程也是windows的一种特殊进程，因此你可以在任务管理器上看到linux进程。 无论exe还是elf格式的二进制文件，原理上都可以在同架构的cpu上执行，只是结构不同操作系统不能解析罢了。而Pico能够解析ELF格式的二进制文件，只需要linux虚拟内核能够提供正确的系统调用，就能够运行大部分linux命令。 LXSS管理服务主要用于协调windows和linux进程之间的关系，和给于Bash.exe（并不是shell，只是我们访问wsl的入口）调用linux命令的接口。所有的运行的linux进程都会被加入到叫Linux实例（应该有LXSS记录的）中，只有第一次请求访问linux进程时才会创建Linux实例，才会创建init进程；当window关机时，会自动关闭linux实例，即关闭linux所有进程。 也就是wsl不会随windows系统自启而自启，同时没有使用发行版的init进程，导致wsl中没有服务的存在。 COM简介Microsoft 组件对象模型 (COM) 定义了一个二进制互操作性标准，用于创建在运行时交互的可重用软件库。 无需将它们编译到应用程序中即可使用 COM 库。 COM 是许多 Microsoft 产品和技术的基础，例如Windows 媒体播放器和Windows服务器。 Pico ProcessAs part of Project Drawbridge, the Windows kernel introduced the concept of Pico processes and Pico drivers. Pico processes are OS processes without the trappings of OS services associated with subystems like a Win32 Process Environment Block (PEB). Furthermore, for a Pico process, system calls and user mode exceptions are dispatched to a paired driver. Pico processes and drivers provide the foundation for the Windows Subsystem for Linux, which runs native unmodified Linux binaries by loading executable ELF binaries into a Pico process’s address space and executes them atop a Linux-compatible layer of syscalls. System CallWSL executes unmodified Linux ELF64 binaries by virtualizing a Linux kernel interface on top of the Windows NT kernel. On native Linux, when a syscall is made from a user mode executable it is handled by the Linux kernel. On WSL, when a syscall is made from the same executable the Windows NT kernel forwards the request to lxcore.sys. Where possible, lxcore.sys translates the Linux syscall to the equivalent Windows NT call which in turn does the heavy lifting. Where there is no reasonable mapping the Windows kernel mode driver must service the request directly. File SystemFile system support in WSL was designed to meet two goals. Provide an environment that supports the full fidelity of Linux file systems Allow interoperability with drives and files in Windows The Windows Subsystem for Linux provides virtual file system support similar to the real Linux kernel. Two file systems are used to provide access to files on the users system: VolFs and DriveFs. VolFsVolFs is a file system that provides full support for Linux file system features, including: Linux permissions that can be modified through operations such as chmod and chroot Symbolic links to other files File names with characters that are not normally legal in Windows file names Case sensitivity Directories containing the Linux system, application files (&#x2F;etc, &#x2F;bin, &#x2F;usr, etc.), and users Linux home folder, all use VolFs. Interoperability between Windows applications and files in VolFs is not supported wsl运行过程 一个正常完整的Linux系统的启动过程为：引导程序载入内核，内核初始化后载入init进程。init开启各项服务。 wsl并不是一个真正的系统，它是一个可以执行Linux ELF的程序。wsl的内核是虚拟内核，具有一定的隔离性。 wsl的工作流程为：windows自启结束并加载了LxCore&#x2F;LXSS两个驱动后，准备工作结束。当用户执行bash.exe时，创建linux实例，执行init服务进程。然后创建bash shell和另一个init进程，在本次会话结束时（关闭Bash.exe窗口）这两个进程结束。之后再通过Bash.exe连接wsl，都只会创建bash和右边的init进程。 文件系统上述讲到了，wsl只有两种windows设计的文件系统：VolFs和DriverFs。其中VolFs文件系统主要是为了支持linux文件系统的全部特性，如linux的文件权限、符号链接、不同于windows的文件名、文件名大小写敏感等等。 而DriveFs主要是为了挂载windows的分区，并且实现互操作性而存在。实际上就是NTFS文件系统的包装，能够让NTFS在linux中使用，即使也提供了大部分linux文件系统特性，但是限制很多，如： 文件目录权限全为777，实际上就算是root用户，在windows分区中也只有打开Base.exe命令拥有者的权限。说明普通用户使用root权限也不能修改c盘中大部分文件。 最好不要在windows下创建文件名只有大小写不同的文件，尽管NTFS支持了。 支持linux符号链接，为windows可执行文件创建符号链接时，注意添加后缀.exe。不要与windows的快捷方式混淆，它们目的一致，但结构不一致，不能在linux中使用。 缺陷 并非所有系统调用都被实现。 WSL不能使用所有的硬件资源。例如，在wsl下不能访问GPU，重复性的计算只能通过CPU完成。 磁盘IO比原生Linux效率低。后果是，wsl下的编译会很慢。 设计wsl1WSL 1的设计没有硬件模拟&#x2F;虚拟化（与coLinux等其他项目不同），WSL直接使用主机文件系统（通过VolFS和DrvFS）和硬件的某些部分，例如网络（Web服务器，用于例如，可以通过主机上配置的相同接口和IP地址进行访问，并且对使用需要管理权限的端口或已经被其他应用程序占用的端口共享相同的限制），这保证了互操作性。 即使从shell运行sudo，某些位置（例如系统文件夹）和配置的访问&#x2F;修改也受到限制。必须启动具有提升权限的实例才能获得“真正的sudo”并允许此类访问。 wsl2Hyper-VMicrosoft的本地虚拟机管理系统。 基于Hyper-V的更高层次的虚拟化。 VPN VPN是通过使用专用线路或在现有网络上使用隧道协议创建一个虚拟的点对点连接而形成的。可从公共 Internet 获得的 VPN可以提供广域网 (WAN) 的一些好处。 从用户的角度来看，可以远程访问专用网络中可用的资源。 正常网络通信时，所有网络请求都是通过我们的物理网卡直接发送出去。而VPN是客户端使用相应的VPN协议先与VPN服务器进行通信，成功连接后就在操作系统内建立一个虚拟网卡，一般来说默认PC上所有网络通信都从这虚拟网卡上进出，经过VPN服务器中转之后再到达目的地。 VPN有多种协议：OPENVPN、PPTP、L2TP&#x2F;IPSec、SSLVPN、IKEv2 VPN，Cisco VPN等。其中的PPTP和L2TP是明文传输协议。只负责传输，不负责加密。分别利用了MPPE和IPSec进行加密。 背景 PPTP 是一个基于 PPP 的很基本的协议。PPTP 是微软 Windows 平台第一个支持的 VPN 协议。PPTP 标准并没有实际描述加密和授权特性，并且依赖于 PPP 协议的隧道来实现安全功能。 L2TP 是一个在 IETF RFC 3193 中被正式标准化的高级协议。推荐在需要安全加密的地方用来替代 PPTP。 OpenVPN 是一个高级的开源 VPN 解决方案，由 “OpenVPN technologies” 支持，并且已经成为开源网络领域里的事实标准。OpenVPN 使用成熟的 SSL&#x2F;TLS 加密协议。 数据加密 PPP 负载是使用微软点对点协议（Microsoft’s Point-to-Point Encryption protocol，MPPE）加密。MPPE 实现了 RSA RC4 加密算法，并使用最长 128 位密钥。 L2TP 负载使用标准的 IPSec 协议加密。在 RFC 4835 中指定了使用 3DES 或 AES 加密算法作为保密方式。 OpenVPN 使用 OpenSSL 库来提供加密。OpenSSL 支持好几种不同的加密算法，如：3DES，AES，RC5 等。 安装&#x2F;配置 Windows 所有版本和大多数其他操作系统包括移动平台都内建了对 PPTP 的支持。PPTP 只需要一个用户名和密码，以及一个服务器地址，所以安装和配置相当简单。 从 2000&#x2F;XP 起的所有 Windows 平台和 Mac OS X 10.3+ 都内建了 L2TP&#x2F;IPSec 的支持。大多数现代的移动平台比如 iPhone 和 Android 也有内建的客户端。 OpenVPN 不包含在任何操作系统中，需要安装客户端软件，但安装也是相当简单，基本上 5 分钟可以完成。 速度 由于使用 128 位密钥，加密开销相比 OpenVPN 使用 256位密钥要小，所以速度感觉稍快一点，但这个差异微不足道。 L2TP&#x2F;IPSec 将数据封装两次，所以相比其他竞争者效率稍低，速度也慢一些。 当使用默认的 UDP 模式，OpenVPN 的表现是最佳的。 端口 PPTP 使用 TCP 1723 端口和 GRE（协议 47）。通过限制 GRE 协议，PPTP 可以轻易地被封锁。 L2TP&#x2F;IPSec 使用 UDP 500 端口用来初始化密钥交换，使用协议 50 用来传输 IPSec 加密的数据（ ESP ），使用 UDP 1701 端口用来初始化 L2TP 的配置，还使用 UDP 4500 端口来穿过 NAT。L2TP&#x2F;IPSec 相比 OpenVPN 容易封锁，因为它依赖于固定的协议和端口。 OpenVPN 可以很容易的配置为使用任何端口运行，也可以使用 UDP 或 TCP 协议。为了顺利穿越限制性的防火墙，可以将 OpenVPN 配置成使用 TCP 443 端口，因为这样就无法和标准的 HTTPS 无法区分，从而极难被封锁。 稳定性&#x2F;兼容性 PPTP 不如 OpenVPN 可靠，也不能像 OpenVPN 那样在不稳定网络中快速恢复。另外还有部分同 GRE 协议和一些路由器的兼容性问题。 L2TP&#x2F;IPSec 比 OpenVPN 更复杂，为了使在 NAT 路由器下的设备可靠地使用，配置可以会更加困难。但是，只要服务器和客户端都支持 NAT 穿越，那么就没什么问题了。 无论是无线网络、蜂窝网络，还是丢包和拥塞经常发生的不可靠网络，OpenVPN 都非常稳定、快速。对于那些相当不可以的连接，OpenVPN 有一个 TCP 模式可以使用，但是要牺牲一点速度，因为将 TCP 封装在 TCP 时效率不高。 安全弱点 微软实现的 PPTP 有一个严重的安全问题（serious security vulnerabilities）。对于词典攻击来说 MSCHAP-v2 是很脆弱的，并且 RC4 算法也会遭到“位翻转攻击（ bit-flipping attack ）”。如果保密是重要的，微软也强烈建议升级到 IPSec。 IPSec 没有明显的漏洞，当和安全加密算法如 AES 一起使用时，被认为是很安全的。 OpenVPN 也没有明显漏洞，当和安全加密算法如 AES 一起使用时，也被认为是相当安全的。 客户端的兼容性 Windows、Mac OS X、Linux、Apple iOS、Android、DD-WRT Windows、Mac OS X、Linux、Apple iOS、Android Windows、Mac OS X、Linux 结论 由于主要的安全漏洞，除了兼容性以外没有好的理由选择使用 PPTP。如果你的设备既不支持 L2TP&#x2F;IPSec 又不支持 OpenVPN，那么 PPTP 是一个合理的选择。如果关心快速安装和简易配置，那么 L2TP&#x2F;IPSec 值得考虑。 L2TP&#x2F;IPSec 是优秀的，但相比 OpenVPN 的高效和杰出的稳定性要落后一点。如果你使用运行 iOS 或 Android 的移动设备，那么这就是最佳的选择，因为 OpenVPN 目前还不支持这些平台。另外，如果需要快速安装，L2TP&#x2F;IPSec 也是一个较佳的选择。 对于所有的 Windows, Mac OS X 以及 Linux 桌面用户来说，OpenVPN 是最好的选择。OpenVPN 速度快，并且安全可信。但劣势是缺乏对移动设备的支持，另外还需要安装第三方客户端。 代理服务器代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个终端（一般为客户端）通过这个服务与另一个终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，在一定程度上能够阻止网络攻击。 SSH安全外壳协议（Secure Shell Protocol，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境[1]。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接[2]。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。SSH使用频率最高的场合是类Unix系统，但是Windows操作系统也能有限度地使用SSH。","categories":[],"tags":[{"name":"os","slug":"os","permalink":"https://www.napleon.cn/tags/os/"}],"keywords":[]},{"title":"GORM学习笔记","slug":"GORM基础","date":"2023-04-24T13:58:17.000Z","updated":"2023-05-19T09:33:20.447Z","comments":true,"path":"2023/04/24/GORM基础/","link":"","permalink":"https://www.napleon.cn/2023/04/24/GORM%E5%9F%BA%E7%A1%80/","excerpt":"","text":"GORM的特性： 全功能 ORM 关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承) Create，Save，Update，Delete，Find 中钩子方法 支持 Preload、Joins 的预加载 事务，嵌套事务，Save Point，Rollback To Saved Point Context、预编译模式、DryRun 模式 批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询 复合主键，索引，约束 Auto Migration 自定义 Logger 灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus… 每个特性都经过了测试的重重考验 开发者友好 模型模型是标准的struct 例如： 1234567891011type User struct &#123; ID uint Name string Email *string Age uint8 Birthday *time.Time MemberNumber sql.NullString ActivatedAt sql.NullTime CreatedAt time.Time UpdatedAt time.Time&#125; 权限控制设置字段的权限位只读、只写、只创建、只更新或者被忽略 123456789101112type User struct &#123; Name string `gorm:&quot;&lt;-:create&quot;` // 允许读和创建 Name string `gorm:&quot;&lt;-:update&quot;` // 允许读和更新 Name string `gorm:&quot;&lt;-&quot;` // 允许读和写（创建和更新） Name string `gorm:&quot;&lt;-:false&quot;` // 允许读，禁止写 Name string `gorm:&quot;-&gt;&quot;` // 只读（除非有自定义配置，否则禁止写） Name string `gorm:&quot;-&gt;;&lt;-:create&quot;` // 允许读和写 Name string `gorm:&quot;-&gt;:false;&lt;-:create&quot;` // 仅创建（禁止从 db 读） Name string `gorm:&quot;-&quot;` // 通过 struct 读写会忽略该字段 Name string `gorm:&quot;-:all&quot;` // 通过 struct 读写、迁移会忽略该字段 Name string `gorm:&quot;-:migration&quot;` // 通过 struct 迁移会忽略该字段&#125; 字段标签 标签名 说明 column 指定 db 列名 type 列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：not null、size, autoIncrement… 像 varbinary(8) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT serializer 指定将数据序列化或反序列化到数据库中的序列化器, 例如: serializer:json/gob/unixtime size 定义列数据类型的大小或长度，例如 size: 256 primaryKey 将列定义为主键 unique 将列定义为唯一键 default 定义列的默认值 precision 指定列的精度 scale 指定列大小 not null 指定列为 NOT NULL autoIncrement 指定列为自动增长 autoIncrementIncrement 自动步长，控制连续记录之间的间隔 embedded 嵌套字段 embeddedPrefix 嵌入字段的列名前缀 autoCreateTime 创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano&#x2F;milli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano autoUpdateTime 创建&#x2F;更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano&#x2F;milli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli index 根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 索引 获取详情 uniqueIndex 与 index 相同，但创建的是唯一索引 check 创建检查约束，例如 check:age &gt; 13，查看 约束 获取详情 &lt;- 设置字段写入的权限， &lt;-:create 只创建、&lt;-:update 只更新、&lt;-:false 无写入权限、&lt;- 创建和更新权限 -&gt; 设置字段读的权限，-&gt;:false 无读权限 - 忽略该字段，- 表示无读写，-:migration 表示无迁移权限，-:all 表示无读写迁移权限 comment 迁移时为字段添加注释 连接到数据库GORM官方支持的数据库类型有：MySQL, PostgreSQL, SQLite, SQL Server 和 TiDB 连接到MySQL1234567import ( &quot;gorm.io/driver/mysql&quot; &quot;gorm.io/gorm&quot;)func main() &#123; dsn := &quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;&#125; MySQL驱动程序提供了一些高级配置可以在初始化时使用，例如： 12345678db, err := gorm.Open(mysql.New(mysql.Config&#123; DSN: &quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;, // DSN data source name DefaultStringSize: 256, // string 类型字段的默认长度 DisableDatetimePrecision: true, // 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持 DontSupportRenameIndex: true, // 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引 DontSupportRenameColumn: true, // 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列 SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置&#125;), &amp;gorm.Config&#123;&#125;) CRUD创建创建一条记录12user := User&#123;Name:&quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;result := db.Create(&amp;user) 用所选字段创建记录12db.Select(&quot;Name&quot;, &quot;Age&quot;, &quot;CreatedAt&quot;).Create(&amp;user)// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;jinzhu&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;) 创建一条记录，忽略未指出的字段。 批量插入123456789101112var users = []User&#123;&#123;Name: &quot;jinzhu1&quot;&#125;, &#123;Name: &quot;jinzhu2&quot;&#125;, &#123;Name: &quot;jinzhu3&quot;&#125;&#125;db.Create(&amp;users)for _, user := range users &#123; user.ID // 1,2,3&#125;// 指定插入数量var users = []User&#123;&#123;Name: &quot;jinzhu_1&quot;&#125;, ...., &#123;Name: &quot;jinzhu_10000&quot;&#125;&#125;// batch size 100db.CreateInBatches(users, 100) 创建HooksGORM提供的hooks有BeforeSave, BeforeCreate,AfterSave,AfterCreate. 12345678func (u *User) BeforeCreate(tx *gorm.DB) (err error) &#123; u.UUID = uuid.New() if u.Role == &quot;admin&quot; &#123; return errors.New(&quot;invalid role&quot;) &#125; return &#125; 查询查询单个对象GORM提供了First, Take, Last 方法从数据库中检索对象 12345678// 查询主键值第一的记录db.First(&amp;user)// 查询一条记录db.Take(&amp;user)// 查询主键值倒数第一的记录db.Last(&amp;user) 根据主键查询12345678db.First(&amp;user, 10)// SELECT * FROM users WHERE id = 10;db.First(&amp;user, &quot;10&quot;)// SELECT * FROM users WHERE id = 10;db.Find(&amp;users, []int&#123;1,2,3&#125;)// SELECT * FROM users WHERE id IN (1,2,3); 条件查询字符串条件123456789// 获取匹配的记录db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Find(&amp;user)// INdb.Where(&quot;name IN ?&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(&amp;user)// LIKEdb.Where(&quot;name LIKE ?&quot;, &quot;%jinzhu%&quot;).Find(&amp;users)// AND// Time// BETWEEN","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"go-协程","slug":"go-协程","date":"2023-04-24T13:42:09.000Z","updated":"2023-06-24T11:54:08.226Z","comments":true,"path":"2023/04/24/go-协程/","link":"","permalink":"https://www.napleon.cn/2023/04/24/go-%E5%8D%8F%E7%A8%8B/","excerpt":"协程是一种用户态的轻量级线程，又称微线程，协程的调度完全由用户控制。与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。","text":"协程是一种用户态的轻量级线程，又称微线程，协程的调度完全由用户控制。与传统的系统级线程和进程相比，协程的最大优势在于其”轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程通常最多也不能超过1万的。这也是协程也叫轻量级线程的原因。 1.1 Goroutine创建Goroutine的成本很小，它就是一段代码，一个函数入口。以及在堆上为其分配的一个堆栈（初始大小为4K，会随着程序的执行自动增长删除）。因此它非常廉价，Go应用程序可以并发运行数千个Goroutines。 与线程相比，Goroutines非常便宜。它们只是堆栈大小的几个kb，堆栈可以根据应用程序的需要增长和收缩，而在线程的情况下，堆栈大小必须指定并且是固定的 Goroutines被多路复用到较少的OS线程。在一个程序中可能只有一个线程与数千个Goroutines。如果线程中的任何Goroutine都表示等待用户输入，则会创建另一个OS线程，剩下的Goroutines被转移到新的OS线程。所有这些都由运行时进行处理，我们作为程序员从这些复杂的细节中抽象出来，并得到了一个与并发工作相关的干净的API。 当使用Goroutines访问共享内存时，通过设计的通道可以防止竞态条件发生。通道可以被认为是Goroutines通信的管道。 1.2 主goroutine封装main函数的goroutine称为主goroutine。 主goroutine的任务： 创建一个defer语句，用于在主goroutine退出时做必要的善后工作。 启动垃圾回收的gotoutine。 执行main包中的init函数 执行main函数。 1.3 goroutine与线程可增长的栈线程都具有一个固定大小的栈内存(2MB)，作为对比，一个goroutine在生命周期开始时只有一个很小的栈，典型情况为2KB。goroutine的栈不是固定大小的，它可以按需增大或者缩小，goroutine栈最大可达1GB。 goroutine调度OS线程由内核调度器函数来调度，过程为：保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。这个过程较为缓慢。 Go有自己的调度器，采用m:n调度技术(复用&#x2F;调度m个goroutine到n个os线程)。Go调度器和内核调度器的工作类似，但Go调度器只需关心单个Go程序的goroutine调度问题。 os线程调度器由硬件时钟定期触发，Go调度器并非如此。它不需要切换到内核环境，所以调用一个goroutine比调度一个线程的成本低很多。","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"go-垃圾回收","slug":"go-垃圾回收","date":"2023-04-20T13:31:12.000Z","updated":"2023-06-24T04:39:35.935Z","comments":true,"path":"2023/04/20/go-垃圾回收/","link":"","permalink":"https://www.napleon.cn/2023/04/20/go-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"常见的垃圾回收机制引用计数对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。 缺点： 降低性能 循环引用 标记-清除该方法分为两步： 标记从根节点开始迭代遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”； 清除操作。对没有被标记的内存进行清除操作。 缺点： 启动垃圾回收时会暂停当前所用代码的执行。 分代收集分代收集的基本思想是，将堆划分成两个或者多个称为代的空间。新创建的对象存放在称为新生代中，随着垃圾回收的重复执行，生命周期较长的对象会被提升到老年代中，因此，新生代垃圾回收和老年代垃圾回收两种方式共存，分别对其空间中的对象进行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。 Go的GCgo的垃圾回收机制是标记-清除算法。 标记阶段。获取这些对象的状态信息。 清扫阶段。回收状态为unreachable的对象。 三色标记法 白色对象：潜在的垃圾，其内存可能被垃圾收集器回收； 黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象； 灰色对象：活跃的对象，存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。 在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。 三色标记法的工作流程可以归纳成以下几个步骤： 从灰色对象的集合中选择一个灰色对象将其标记成黑色。 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收； 重复上述两个步骤直到对象图中不存在灰色对象。 当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾： 因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。 混合写屏障想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种： 强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象； 弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。 上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。 垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。 Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色。 为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。 GC的时机运行时通过runtime.gcTrigger.test方法决定是否要触发垃圾回收，当满足垃圾收集的基本条件时–允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同的方式触发不同的检查： 123456789101112131415161718func (t gcTrigger) test() bool &#123; if !meestats.enablegc || panicking != 0 || gcphase != _GCoff &#123; return false &#125; switch t.kind &#123; case gcTriggerHeap: return memstats.heap_live &gt;= memstats.gc_trigger case gcTriggerTime: if gcpercent &lt; 0 &#123; return false &#125; lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime)) return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod case gcTriggerCycle: return int32(t.n - owrk.cycles) &gt; 0 &#125; return true&#125; 1、gcTriggerHeap ：堆内存的分配达到达控制器计算的触发堆大小；2、gcTriggerTime ：如果一定时间内没有触发，就会触发新的循环，该出发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟；3、gcTriggerCycle：如果当前没有开启垃圾收集，则触发新的循环；4、runtime.gcpercent 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集。 用于开启垃圾收集的方法 runtime.gcStart 会接收一个 runtime.gcTrigger 类型的结构，所有出现 runtime.gcTrigger 结构体的位置都是触发垃圾收集的代码： runtime.sysmon 和 runtime.forcegchelper ：后台运行定时检查和垃圾收集； runtime.GC ：用户程序手动触发垃圾收集； runtime.mallocgc ：申请内存时根据堆大小触发垃圾收集。","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"MYSQL学习笔记","slug":"MYSQL学习笔记","date":"2023-04-14T07:35:05.000Z","updated":"2023-04-14T09:10:16.531Z","comments":true,"path":"2023/04/14/MYSQL学习笔记/","link":"","permalink":"https://www.napleon.cn/2023/04/14/MYSQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"关系模型主键在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。 对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。 联合主键关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 外键12FOREIGN KEY (class_id)REFERENCES classes (id); 多对多多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系： teachers表： id name 1 张老师 2 王老师 3 李老师 4 赵老师 classes表： id name 1 一班 2 二班 中间表teacher_class关联两个一对多关系： id teacher_id class_id 1 1 1 2 1 2 3 2 1 4 2 2 5 3 1 6 4 2 索引索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 例如，对于students表： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 如果要经常根据score列进行查询，就可以对score列创建索引： 12ALTER TABLE studentsADD INDEX idx_score (score); 查询数据条件查询要指定条件“分数在80分或以上的学生”： 1SELECT * FROM students WHERE score &gt;= 80; 条件查询的语法： 1234SELECT * FROM &lt;TABLENAME&gt; WHERE &lt;CONDITION&gt;# 多条件# 与条件： AND# 或条件： OR 投影查询如果我们想查询某几列的数据： 123SELECT id, score, name FROM students;# 返回某几列的数据SELECT C1, C2, C3 排序排序使用关键词 123456# ORDER BYSELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC;# 默认为升序 分页查询12# 每页的最大数量 LIMIT PAGESIZE# 查询第n页的数据 OFFSET PAGESIZE * (n-1) 聚合查询SQL提供了一些函数用于统计数据，这些函数被称谓聚合函数。 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 COUNT 统计记录数目 连接查询注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 修改数据INSERTINSERT语句的基本语法为： 12345678910INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);# 例如INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);-- 查询并观察结果:SELECT * FROM students;# 一次性添加多条数据INSERT INTO students (class_id, name, gender, score) VALUES (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87), (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81); UPDATE更新数据库中的记录，使用UPDATE 语句。 基本语法： 1234UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;UPDATE students SET name=&#x27;大牛&#x27;, score=66 WHERE id=1;-- 查询并观察结果:SELECT * FROM students WHERE id=1; DELETEDELETE语句的基本语法： 1234567DELETE FROM &lt;TABLENAME&gt; WHERE...;# 例-- 删除id=1的记录DELETE FROM students WHERE id=1;-- 查询并观察结果:SELECT * FROM students; 事务基础语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253begin; # 开始事务commit; # 提交事务rollback; # 回滚# 使用示例mysql&gt; use RUNOOB;Database changedmysql&gt; CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb; # 创建数据表Query OK, 0 rows affected (0.04 sec) mysql&gt; select * from runoob_transaction_test;Empty set (0.01 sec) mysql&gt; begin; # 开始事务Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into runoob_transaction_test value(5);Query OK, 1 rows affected (0.01 sec) mysql&gt; insert into runoob_transaction_test value(6);Query OK, 1 rows affected (0.00 sec) mysql&gt; commit; # 提交事务Query OK, 0 rows affected (0.01 sec) mysql&gt; select * from runoob_transaction_test;+------+| id |+------+| 5 || 6 |+------+2 rows in set (0.01 sec) mysql&gt; begin; # 开始事务Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into runoob_transaction_test values(7);Query OK, 1 rows affected (0.00 sec) mysql&gt; rollback; # 回滚Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from runoob_transaction_test; # 因为回滚所以数据没有插入+------+| id |+------+| 5 || 6 |+------+2 rows in set (0.01 sec) mysql&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.napleon.cn/tags/SQL/"}],"keywords":[]},{"title":"12-并发编程","slug":"12-并发编程","date":"2023-04-13T12:35:04.000Z","updated":"2023-04-15T03:43:52.251Z","comments":true,"path":"2023/04/13/12-并发编程/","link":"","permalink":"https://www.napleon.cn/2023/04/13/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","excerpt":"现代操作系统提供了三种基本的构造并发程序的方法： 进程。每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用显式的进程间通信机制。 I&#x2F;O多路复用。 线程","text":"现代操作系统提供了三种基本的构造并发程序的方法： 进程。每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用显式的进程间通信机制。 I&#x2F;O多路复用。 线程 12.1 基于进程的并发编程12.1.1 基于进程的并发服务器代码123456789101112131415161718192021222324252627282930void echo(int connfd);void sigchld_handler(int sig) &#123; while (waitpid(-1, 0, WNOHANG) &gt; 0) ; return ;&#125;int main(int argc, char **argv) &#123; int listenfd, connfd; socklen_t clientlen; struct sockaddr_storage clientaddr; if (argc != 2) &#123; fprintf(stderr, &quot;usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(0); &#125; Signal(SIGCHID, sigchld_handler); listenfd = Open_listenfd(argv[1]); while (1) &#123; clientlen = sizeof(struct sockaddr_storage); connfd = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen); if (Fork() == 0) &#123; Close(listenfd); echo(connfd); Close(connfd); exit(0); &#125; Close(connfd); &#125;&#125;","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}],"keywords":[]},{"title":"11-网络编程","slug":"11-网络编程","date":"2023-04-12T14:34:28.000Z","updated":"2023-04-13T12:14:16.081Z","comments":true,"path":"2023/04/12/11-网络编程/","link":"","permalink":"https://www.napleon.cn/2023/04/12/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"本章将开发一个小但功能齐全的Web服务器，能够为Web浏览器提供静态和动态的内容","text":"本章将开发一个小但功能齐全的Web服务器，能够为Web浏览器提供静态和动态的内容 11.1 客户端-服务器编程模型模型的基本操作是事务。 客户端和服务器是进程。 一台主机可以同时运行许多不同的客户端和服务器。 11.2 网络对于主机而言，网络只是I&#x2F;O设备，是数据源与数据接收方。网络主机的硬件组成如图所示： 以太网以太网是一种局域网技术。一个以太网段如下图所示： 电缆的一段连接到主机的适配器，一段连接到集线器的一个端口上。集线器会将数据复制到每个端口上。 每一个以太网适配器都有一个唯一的48位地址。 以太网段通过网桥 连接成较大的局域网，被称为桥接以太网。在一个桥接以太网里，一些电缆连接网桥与网桥，而另外一些连接网桥和集线器。这些电缆的带宽可以是不同的。在我们的示例中，网桥与网桥之间的电缆有 1 Gb&#x2F;s 的带宽，而四根网桥和集线器之间电缆的带宽却是 100 Mb&#x2F;s。 广域网多个不兼容的局域网通过路由器连接起来。路由器对于它连接到的每个网络都有一个端口。简化的广域网模型如下： 数据通过互联网传送的过程 运行在主机 A 上的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区中。 主机 A 上的协议软件通过在数据前附加互联网络包头和 LAN1 帧头，创建了一个 LAN1 的帧。互联网络包头寻址到互联网络主机 B。LAN1 帧头寻址到路由器。然后它传送此帧到适配器。注意，LAN1 帧的有效载荷是一个互联网络包，而互联网络包的有效载荷是实际的用户数据。这种封装是基本的网络互联方法之一。 LAN1 适配器复制该帧到网络上。 当此帧到达路由器时，路由器的 LAN1 适配器从电缆上读取它，并把它传送到协议软件。 路由器从互联网络包头中提取出目的互联网络地址，并用它作为路由表的索引，确定向哪里转发这个包，在本例中是 LAN2。路由器剥落旧的 LAN1 的帧头，加上寻址到主机 B 的新的 LAN2 帧头，并把得到的帧传送到适配器。 路由器的 LAN2 适配器复制该帧到网络上。 当此帧到达主机 B 时，它的适配器从电缆上读到此帧，并将它传送到协议软件。 最后，主机 B 上的协议软件剥落包头和帧头。当服务器进行一个读取这些数据的系统调用时，协议软件最终将得到的数据复制到服务器的虚拟地址空间。 11.3 全球IP因特网下图展示了一个因特网客户端—服务器应用程序的基本硬件和软件组织。 因特网的客户端和服务器混合使用套接字接口函数和 Unix l&#x2F;O 函数来进行通信。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的 TCP&#x2F;IP 函数。 TCP&#x2F;IP 实际是一个协议族，其中每一个都提供不同的功能。 从程序员的视角来看，因特网是一个世界范围内的主机集合，满足以下特性： 主机集合被映射为一组32位的IP地址（IPV4,IPV6为128位的地址）。 IP地址被映射为一组称为因特网域名的标识符。 因特网主机上的进程能够通过连接来与任何其他因特网主机上的进程通信。 11.3.1 IP地址一个IP地址就是一个32位无符号整数。 123struct in_addr &#123; uint32_t s_addr;&#125; 11.3.2 因特网连接一个套接字是连接的一个端点，每个套接字都有相应的套接字地址。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的端口组成的。 一个连接是偶遇它两端的套接字地址唯一确定的，这对地址叫做套接字对。 11.4 套接字接口套接字接口是一组函数，它们和Unix I&#x2F;O函数结合起来，用以创建网络应用。 11.4.1 套接字地址结构结构体如下： 12345678910111213/* IP socket address structure */struct sockaddr_in &#123; uint16_t sin_family; /* Protocol family (always AF_INET) */ uint16_t sin_port; /* Port number in network byte order */ struct in_addr sin_addr; /* IP address in network byte order */ unsigned char sin_zero[8]; /* Pad to sizeof(struct sockaddr) */&#125;;/* Generic socket address structure (for connect, bind, and accept) */struct sockaddr &#123; uint16_t sa_family; /* Protocol family */ char sa_data[14]; /* Address data */&#125;; 11.4.2 socket函数客户端和服务器使用socket函数来创建一个套接字描述符 1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); 11.4.3 connect函数客户端通过connect函数来建立和服务器的连接。 123#include &lt;sys/socket.h&gt;int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen); connect 函数试图与套接字地址为addr的服务器建立一个因特网连接，connect函数会一直阻塞直至成功建立连接或者是发生错误。 11.4.4 bind函数1234#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);// bind 函数告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来。参数 addrlen 就是 sizeof(sockaddr_in)。对于 socket 和 connect，最好的方法是用 getaddrinfo 来为 bind 提供参数 11.4.5 listen函数1234#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);// listen 函数将 sockfd 从一个主动套接字转化为一个监听套接字（listening socket），该套接字可以接受来自客户端的连接请求。backlog 参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。通常我们会把它设置为一个较大的值，比如 1024。 11.4.6 accept函数服务器通过调用 accept 函数来等待来自客户端的连接请求。 1234#include &lt;sys/socket.h&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen);// accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个已连接描述符（connected descriptor），这个描述符可被用来利用 Unix I/O 函数与客户端通信。 监听描述符是作为客户端连接请求的一个端点。它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点。 下图描绘了监听描述符和已连接描述符的角色 区分监听描述符和已连接描述符的目的： 因为它使得我们可以. 建立并发服务器，它能够同时处理许多客户端连接。例如，每次一个连接请求到达监听描述符时，我们可以派生（fork）—个新的进程，它通过已连接描述符与客户端通信。 11.4.7 主机和服务的转换 getaddrinfo函数。 123456789101112131415// getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构。#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);// 返回：如果成功则为 0，如果错误则为非零的错误代码。void freeaddrinfo(struct addrinfo *result);// 返回：无。const char *gai_strerror(int errcode);// 返回：错误消息。 11.5 Web服务器11.5.1 Web基础Web客户端与服务器之间的交互HTTP协议。HTTP 是一个简单的协议。一个 Web 客户端（即浏览器）打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。 11.5.2 Web内容Web服务器向客户端提供内容的方式 读取磁盘内容并返回给服务器。静态内容。 返回可执行文件的输出。动态内容。 每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL（Universal Resource Locator，通用资源定位符）。 可执行文件的 URL 可以在文件名后包括程序参数。“?” 字符分隔文件名和参数，而且每个参数都用 “&amp;” 字符分隔开。 11.5.3 HTTP事务1 HTTP请求一个请求行+请求报头。 2 HTTP响应响应行+响应报头+响应体。 响应行： version + status-code + status-message 状态代码 状态消息 描述 200 成功 处理请求无误 301 永久移动 内容已移动到 location 头中指明的主机上 400 错误请求 服务器不能理解请求 403 禁止 服务器无权访问所请求的文件 404 未发现 服务器不能找到所请求的文件 501 未实现 服务器不支持请求的方法 505 HTTP 版本不支持 服务器不支持请求的版本 11.5.4 服务动态内容 CGI（Common Gateway Interface，通用网关接口）。 1 客户端如何将程序参数传递给服务器GET请求的参数在url中传递。 POST请求的参数在请求主题中传递。 2 服务器如何将参数传递给子进程服务器接收请求后通过fork创建一个子进程，并调用execve执行程序。 3 服务器如何将其他信息传递给子进程CGI 定义了大量的其他环境变量，一个 CGI 程序在它运行时可以设置这些环境变量。 环境变量 描述 QUERY_STRING 程序参数 SERVER_PORT 父进程侦听的端口 REQUEST_METHOD GET 或 POST REMOTE_HOST 客户端的域名 REMOTE_ADDR 客户端的点分十进制 IP 地址 CONTENT_TYPE 只对 POST 而言：请求体的 MIME 类型 CONTENT_LENGTH 只对 POST 而言：请求体的字节大小 4 子进程将他的输出发送到哪里一个 CGI 程序将它的动态内容发送到标准输出。在子进程加载并运行 CGI 程序之前，它使用 Linux dup2 函数将标准输出重定向到和客户端相关联的已连接描述符。因此，任何 CGI 程序写到标准输出的东西都会直接到达客户端。 下面展示了一个简单的 CGI 程序，它对两个参数求和，并返回带结果的 HTML 文件给客户端： 12345678910111213141516171819202122232425262728293031323334#include &quot;csapp.h&quot;int main(void) &#123; char *buf, *p; char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE]; int n1 = 0, n2 = 0; /* Extract the two arguments */ if ((buf = getenv(&quot;QUERY_STRING&quot;)) != NULL) &#123; p = strchr(buf, ’&amp;’); *p = ’\\0’; strcpy(arg1, buf); strcpy(arg2, p + 1); n1 = atoi(arg1); n2 = atoi(arg2); &#125; /* Make the response body */ sprintf(content, &quot;QUERY_STRING=%s&quot;, buf); sprintf(content, &quot;Welcome to add.com: &quot;); sprintf(content, &quot;%sTHE Internet addition portal.\\r\\n&lt;p&gt;&quot;, content); sprintf(content, &quot;%sThe answer is: %d + %d = %d\\r\\n&lt;p&gt;&quot;, content, n1, n2, n1 + n2); sprintf(content, &quot;%sThanks for visiting!\\r\\n&quot;, content); /* Generate the HTTP response */ printf(&quot;Connection: close\\r\\n&quot;); printf(&quot;Content-length: %d\\r\\n&quot;, (int)strlen(content)); printf(&quot;Content-type: text/html\\r\\n\\r\\n&quot;); printf(&quot;%s&quot;, content); fflush(stdout); exit(0);&#125;","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}],"keywords":[]},{"title":"浅谈mmap","slug":"浅谈mmap","date":"2023-04-09T13:13:58.000Z","updated":"2023-04-09T13:36:32.233Z","comments":true,"path":"2023/04/09/浅谈mmap/","link":"","permalink":"https://www.napleon.cn/2023/04/09/%E6%B5%85%E8%B0%88mmap/","excerpt":"mmap能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。普通文件在被映射到进程地址空间后，进程可以像访问普通内存一样访问文件，不必通过read()、write()等系统调用来访问文件。","text":"mmap能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。普通文件在被映射到进程地址空间后，进程可以像访问普通内存一样访问文件，不必通过read()、write()等系统调用来访问文件。 mmap接口描述1234567891011121314151617#include &lt;sys/mman.h&gt;void *mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);// addr: 内存空间上的起始地址，一般为NULL，内核自动分配// length: 字节数// prot: 共享内存的访问权限/*PROT_READPROT_WRITEPROT_EXECPROT_NONE*/// flags:// fd: 文件描述符// offset: 偏移量// 返回值: 文件映射到进程空间的地址。 匿名映射匿名映射没有对应的文件。fork()得到的子进程会拷贝父进程映射后的空间，同时也继承了mmap()的返回地址，从而实现进程间的通信。 12345678910111213141516// 匿名映射的例子ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);pid = fork();switch(pid) &#123; case pid &lt; 0: printf(&quot;err\\n&quot;); break; case pid = 0: lock(ptr); critical_section(); unlock(ptr); case pid &gt; 0: lock(ptr); critical_section(); unlock(ptr);&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"}],"keywords":[]},{"title":"7:链接","slug":"7-链接","date":"2023-04-09T08:24:36.000Z","updated":"2023-04-09T13:36:46.552Z","comments":true,"path":"2023/04/09/7-链接/","link":"","permalink":"https://www.napleon.cn/2023/04/09/7-%E9%93%BE%E6%8E%A5/","excerpt":"链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。","text":"链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。 7.1 编译器驱动程序下面是两个运行示例： 1234567891011121314151617181920// main.cint fum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main() &#123; int val = sum(array, 2); return val;&#125;// sum.cint sum(int *a, int n) &#123; int i, s = 0; for (int i = 0; i &lt; n; i++) &#123; s += a[i]; &#125; return s;&#125;// Linux下编译该C程序的命令linux&gt; gcc -Og -o prog main.c sum.c 7.2 静态链接静态链接器 (static linker)以一组可重定向的目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。 input: ​ 由各种不同的的代码和数据节构成，每一节都是一个连续的字节序列。 链接器的任务： 符号解析。将每个符号引用与每个符号定义关联起来。 重定位。 编译器和汇编器生成从地址0开始代码和数据节。链接器通过把每个符号定义和内存位置关联起来，从而重定向这些节。然后修改所有对这些符号的引用。使得他们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。 7.3 目标文件目标文件有三种形式： 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。 7.4 可重定向目标文件下图展示了一个典型的ELF可重定向目标文件的格式。 ELF 头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节： .text：已编译程序的机器代码。 .rodata：只读数据，比如 printf 语句中的格式串和开关语句的跳转表。 .data：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。 .bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。 .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。 .rel.text：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。 .rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。 .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。 .line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。 .strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。 7.5 符号和符号表在链接器的上下文中，有三种不同的符号： 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。 由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。 只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。 .symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理。 123456789// ELF符号表条目typedef struct &#123; int name; // 字符串表中的字节偏移 char type:4; // 函数或者数据 char binding:4; // 本地或者全局 short section; // 分配的目标文件的节 long value; // 对齐要求 long size; // 最小的大小&#125; 7.6 符号解析7.6.1 链接器如何解析多重定义的全局符号在编译时，编译器向汇编器输出每个全局符号的强弱类型。汇编器将这个信息编码在可重定向目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 链接器处理多重定义的符号名的规则如下： 规则 1：不允许有多个同名的强符号。 规则 2：如果有一个强符号和多个弱符号同名，那么选择强符号。 规则 3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。 7.6.2 与静态链接库编译系统提供了一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，可以作为链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标板块。 与静态库链接的示意图如下图所示： 7.6.3 链接器如何使用静态库来解析引用7.9 加载可执行目标文件当在命令号中键入 1linux &gt; ./prog Shell调用被称为加载器的操作系统代码来运行该可执行目标文件。任何Linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存当中，然后通过跳转到程序的第一条指令或入口点来运行该程序。 7.10 动态链接共享库共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序来执行的。共享库也称为共享目标（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。 动态链接过程如下图所示： 为了构造图中示例向量例程的共享库，我们调用编译器驱动程序，给编译器和链接器如下指令： 123linux &gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c// -shared选项指示链接器创建一个共享的目标文件// -fpic选项指示编译器生成与位置无关的代码 链接的指令： 1linux &gt; gcc -o prog2l main2.c ./libvector.so","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}],"keywords":[]},{"title":"10:系统级IO","slug":"10-系统级IO","date":"2023-04-08T04:20:32.000Z","updated":"2023-04-08T11:00:05.816Z","comments":true,"path":"2023/04/08/10-系统级IO/","link":"","permalink":"https://www.napleon.cn/2023/04/08/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/","excerpt":"I&#x2F;O是在主存和外部设备之间拷贝数据的过程。本章介绍Unix I&#x2F;O 和一般I&#x2F;O的基本概念。并展示在C程序中如何可靠地使用这些接口。","text":"I&#x2F;O是在主存和外部设备之间拷贝数据的过程。本章介绍Unix I&#x2F;O 和一般I&#x2F;O的基本概念。并展示在C程序中如何可靠地使用这些接口。 10.1 Unix I&#x2F;O在UNIX系统中，一切都被认为是字节序列(文件), 因而所有的输入域输出都能以统一的方式进行。 打开文件 内核打开文件后，会返回一个小的非负整数，叫做 描述符 ，用于表示文件。 改变当前文件的位置 内核保持文件位置k，是文件开头起始的字节偏移量。seek操作可以显式的设置文件的当前位置k。 读写文件 读操作。从文件拷贝n个字节到存储器，偏移量k&#x3D;k+n。若文件大小为m，当k大于等于m时，触发EOF。 写操作。从存储器拷贝n&gt;0个字节到一个文件，文件k&#x3D; k + n。 关闭文件 10.2 打开和关闭文件open函数 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(char* filename, int flags, mode_t mode);// flags// O_RDONLY: 只读// O_WRONLY: 只写// O_RDWR: 读写// O_CREAT: 如果文件不存在，就创建它的一个截断的文件// O_TRUNC: 如果文件已经存在，就截断它// O_APPEND 打开文件时设置文件位置到文件的结尾处/*mode: 新文件的访问权限位*/ 10.3 读写文件123456789#include &lt;unistd.h&gt;ssize_t read(int fd, void* buf, size_t n);ssize_t write(int fd, const void* buf, size_t, n);// 返回值// 成功：读/写的字节数// EOF: 0// 失败： -1 123//ssize_t和size_t的区别typedef ssize_t int;typedef size_t unsigned int; 10.4 用RIO包健壮的读写10.4.1 RIO无缓冲输入输出函数12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;csapp.h&quot;ssize_t rio_readn(int fd, void* usrbuf, size_t n);ssize_t rio_writen(int fd, void* usrbuf, size_t n);// 返回值与read和write类似ssize_t rio_readn(int fd, void* userbuf, size_t n) &#123; size_t nleft = n; ssize_t nread; char* bufp = usrbuf; while (nleft &gt; 0) &#123; if ((nread = read(fd, bufp, nleft)) &lt; 0) &#123; if (errno = EINTR) nread = 0; else return -1; &#125; else if (nread == 0) break; nleft -= nread; bufp += nread; &#125; return (n - nleft);&#125;ssize_t rio_writen(int fd, void* usrbuf, size_t n) &#123; size_t nleft = n; ssize_t nwritten; char* bufp = usrbuf; while (nleft &gt; 0) &#123; if ((nwritten = write(fd, bufp, nleft)) &lt;= 0) &#123; if (errno == EINTR) nwritten = 0; else return -1; &#125; nleft -= nwritten; bufp += nwritten; &#125; return n;&#125; 10.4.2 RIO带缓冲的输入函数123456void rio_readinitb(rio_t* rp, int fd);// 将描述符fd和地址rp处读缓冲区联系起来void rio_readlineb(rio_t* rp, void* usrbuf, size_t maxlen);// 从一个内部 读缓冲区 拷贝一个文本行，当缓冲区变空时，会自动调用read重新填满缓冲区。最多写maxlen - 1 个字节，然后用一个空字符截断。ssize_t rio_readnb(rio_t* rp, void* usrbuf, size_t n);// 从文件rp中最多读n个字节到存储器位置usrbuf。 123456789101112// 从标准输入拷贝一个文本文件到标准输出#include &quot;csapp.h&quot;int main(int argc, char** argv) &#123; int n; rio_t rio; char buf[MAXLINE]; Rio_readinitb(&amp;rio, STDIN_FILENO); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) Rio_writen(STDOUT_FILENO, buf, n);&#125; 12345678// 一个类型为rio_t的读缓冲区#define RIO_BUFSIZE 8192typedef struct &#123; int rio_fd; // 缓冲区关联的文件描述符 int rio_cnt; // 缓冲区中未读的字节数 char* rio_bufptr; // 缓冲区中下一个字节的位置 char rio_buf[RIO_BUFSIZE]; // 内部缓冲区大小&#125; 123456// rio_readinitb函数void rio_readinitb(rio_t* rp, int fd) &#123; rp-&gt;rio_fd = fd; rp-&gt;rio_cnt = 0; rp-&gt;rio_bufptr = rp-&gt;rio_buf;&#125; 1234567891011121314151617181920212223// rio_read函数static ssize_t rio_read(rio_t* rp, char* usrbuf, size_t n) &#123; int cnt; while (rp-&gt;rio_cnt &lt;= 0) &#123; if (rp-&gt;rio_cnt &lt; 0) &#123; if (errno !=EINTR) return -1; &#125; else if (rp-&gt;rio_cnt == 0) return 0; else rp-&gt;rio_bufptr = rp-&gt;rio_buf; &#125; cnt = n; if (rp-&gt;rio_cnt &lt; 0) cnt = rp-&gt;rio_cnt; memcpy(usrbuf, rp-&gt;rio_bufptr, cnt); rp-&gt;rio_bufptr += cnt; rp-&gt;rio_cnt -= cnt; return cnt;&#125; 123456789101112131415161718192021// rio_readlineb 的一个实现ssize_t rio_readlineb(rio_t* rp, void* usrbuf, size_t maxlen) &#123; int n, rc; char c, *bufp = usrbuf; for (n = 1; n &lt; maxlen; n++) &#123; if ((rc = rio_read(rp, &amp;c, 1)) == 1) &#123; *bufp++ = c; if (c == &#x27;\\n&#x27;) break; &#125; else if ((rc == 0)) &#123; if (n == 1) return 0; // EOF, no data read else break; // EOF, read some data; &#125; else return -1; &#125; *bufp = 0; return n;&#125; 10.5 读取文件元数据12345678910111213141516171819202122#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int stat(const char* filename, struct stat* buf);int fstat(int fd, struct stat* buf);// 函数输入的数据结构struct stat &#123; dev_t st_dev; // 设备 ino_t st_ino; // inode mode_t st_mode; // 保护和文件类型 nlink_t st_nlink; // 硬链接数目 uit_t st_uid; // 文件拥有者的用户ID gid_t st_gid; // 文件拥有者的组ID dev_t st_rdev; // 设备类型 off_t st_size; // 总大小(字节) unsigned long st_blksize; // 文件系统I/O的块大小 unsigned long st_blocks; // 分配的块数 time_t st_atime; // 最后一次进入的时间 time_t st_mtime; // 最后一次更新的时间 time_t st_ctime; // 最后一次改变的时间&#125; 1234567891011121314151617181920// 查询和处理一个文件的st_mode位#include &quot;csapp.h&quot;int main(int argc, char** argv) &#123; struct stat stat; char* type, *readok; Stat(argv[1], &amp;stat); if (S_ISREG(stat.st_mode)) type = &quot;regular&quot;; else if (S_ISDIR(stat.st_mode)) type = &quot;directory&quot;; else type = &quot;other&quot;; if ((stat.st_mode &amp; S_ISUSR)) readok = &quot;yes&quot;; else readok = &quot;no&quot;; printf(&quot;type: %s, read: %s\\n&quot;, type, readok); exit(0);&#125; 10.6 共享文件内核用三个相关的数据结构描述打开的文件： 描述符表。 每个进程都有独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。 文件表。打开的文件的集合，由所有的进程共享。 v-node表。同文件表一样，由所有的进程共享。 10.7 I&#x2F;O重定向Unix Shell提供了I&#x2F;O重定向机制，允许用户将磁盘文件和标准输入输出联系起来。例如： unix&gt; ls &gt; foo.txt 下面使用dup2函数实现I&#x2F;O重定向。 1234#include &lt;unistd.h&gt;int dup2(int oldfd, int new fd);// dup2函数拷贝描述符表表项oldfd到描述符表表项newfd，覆盖描述符表表项newfd以前的内容。","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}],"keywords":[]},{"title":"iris:day1","slug":"iris基础","date":"2023-04-08T02:45:15.000Z","updated":"2023-04-10T12:52:31.892Z","comments":true,"path":"2023/04/08/iris基础/","link":"","permalink":"https://www.napleon.cn/2023/04/08/iris%E5%9F%BA%E7%A1%80/","excerpt":"Iris是一个Go语言下的MVC框架。","text":"Iris是一个Go语言下的MVC框架。 概览MVC架构模式的示意图： 下面是一个使用MVC架构实现的一个简单Iris App 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( &quot;github.com/kataras/iris&quot; &quot;github.com/kataras/iris/middleware/logger&quot; &quot;github.com/kataras/iris/middleware/recover&quot; &quot;github.com/kataras/iris/mvc&quot;)func main() &#123; app := iris.New() app.Use(recover.New()) app.Use(logger.New())mvc.New(app).Handle(new(ExampleController)) // http://localhost:8080 // http://localhost:8080/ping // http://localhost:8080/hello app.Run(iris.Addr(&quot;:8080&quot;))&#125;// ExampleController serves the &quot;/&quot;, &quot;/ping&quot; and &quot;/hello&quot;.type ExampleController struct &#123;&#125;// Get serves// Method: GET// Resource: http://localhost:8080func (c *ExampleController) Get() mvc.Result &#123; return mvc.Response&#123; ContentType: &quot;text/html&quot;, Text: &quot;&lt;h1&gt;Welcome&lt;/h1&gt;&quot;, &#125;&#125;// GetPing serves// Method: GET// Resource: http://localhost:8080/pingfunc (c *ExampleController) GetPing() string &#123; return &quot;pong&quot;&#125;// GetHello serves// Method: GET// Resource: http://localhost:8080/hellofunc (c *ExampleController) GetHello() interface&#123;&#125; &#123; return map[string]string&#123;&quot;message&quot;: &quot;Hello Iris!&quot;&#125;&#125; HTTP主机配置监听和服务服务器的初始化用Run方法执行 12345678910111213// 在 Tcp 上监听网络地址 0.0.0.0:8080app.Run(iris.Addr(&quot;:8080&quot;))// 和前面一样，但是使用自定义 http.Server 也可以在其他地方运行app.Run(iris.Server(&amp;http.Server&#123;Addr:&quot;:8080&quot;&#125;))// 创建一个自定义的或者标准的net.Listener并传递给app.Run// 使用自定义 net.Listenerl, err := net.Listen(&quot;tcp4&quot;, &quot;:8080&quot;)if err != nil &#123; panic(err)&#125;app.Run(iris.Listener(l)) 下面是一个完整的例子 1234567891011121314151617181920212223242526272829package mainimport ( &quot;os&quot; &quot;net&quot; &quot;github.com/kataras/iris&quot;)func main() &#123; app := iris.New() // UNIX socket if errOs := os.Remove(socketFile); errOs != nil &amp;&amp; !os.IsNotExist(errOs) &#123; app.Logger().Fatal(errOs) &#125; l, err := net.Listen(&quot;unix&quot;, socketFile) if err != nil &#123; app.Logger().Fatal(err) &#125; if err = os.Chmod(socketFile, mode); err != nil &#123; app.Logger().Fatal(err) &#125; app.Run(iris.Listener(l))&#125; 主机配置程序以上所有的监听都是接收 func(*iris.Supervisor)为最后一个变量。可以通过这些函数传递的特定主机来添加配置程序。 下面的示例代码在服务器关闭时触发一个回调函数 12345app.Run(iris.Addr(&quot;:8080&quot;, func(h *iris.Supervisor) &#123; h.RegisterOnShutdown(func() &#123; println(&quot;server terminated&quot;) &#125;)&#125;)) HTTP路由Handler Handler 用于处理请求 APIiris提供了所有的HTTP方法，第一个参数是路由路径，第二个可变参数是一个或者多个iris.Handler 1234567891011121314151617181920212223242526272829303132333435app := iris.New()// 方法: &quot;GET&quot;app.Get(&quot;/&quot;, handler)// 方法: &quot;POST&quot;app.Post(&quot;/&quot;, handler)// 方法: &quot;PUT&quot;app.Put(&quot;/&quot;, handler)// 方法: &quot;DELETE&quot;app.Delete(&quot;/&quot;, handler)// 方法: &quot;OPTIONS&quot;app.Options(&quot;/&quot;, handler)// 方法: &quot;TRACE&quot;app.Trace(&quot;/&quot;, handler)// 方法: &quot;CONNECT&quot;app.Connect(&quot;/&quot;, handler)// 方法: &quot;HEAD&quot;app.Head(&quot;/&quot;, handler)// 方法: &quot;PATCH&quot;app.Patch(&quot;/&quot;, handler)// 用于所有 HTTP 方法app.Any(&quot;/&quot;, handler)func handler(ctx iris.Context)&#123; ctx.Writef(&quot;Hello from method: %s and path: %s&quot;, ctx.Method(), ctx.Path())&#125; 路由分组一组路由可以用前缀路径分组，组之间共享相同的中间件和模板布局，组内可以嵌套组。 .Party 被用于分组路由，开发者可以声明不限数量的分组。 示例代码： 12345678app := iris.New()users := app.Party(&quot;/users&quot;, myAuthMiddlewareHandler)// http://localhost:8080/users/42/profileusers.Get(&quot;/&#123;id:int&#125;/profile&quot;, userProfileHandler)// http://localhost:8080/users/messages/1users.Get(&quot;/messages/&#123;id:int&#125;&quot;, userMessageHandler) Context机制上下文是服务器用于所有客户端的中间人“对象” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421// 上下文是服务器用于所有客户端的中间人 &quot;对象&quot;。// // 对于每一个新的连接，会从 sync.Pool 中获取一个新上下文对象。// 上下文是 iris 的 http 流中最重要的部分。//// 开发者发送响应到客户端的请求通过一个上下文。// 开发者获取请求信息从客户端的请求上下文中。// // context 是 context.Context 子包的一个实现。// context.Context 是很好扩展，所以开发者可以按照实际所需重写它的方法。type Context interface &#123; // ResponseWriter 如期返回一个兼容 http.ResponseWriter 的 响应writer。 ResponseWriter() ResponseWriter // ResetResponseWriter 应该改变或者升级上下文的 ResponseWriter。 ResetResponseWriter(ResponseWriter) // Request 方法如期返回原始的 *http.Request。 Request() *http.Request // SetCurrentRouteName 方法设置内部路由名称，为了当开发者调用 // `GetCurrentRoute()` 方法的时候能够正确返回当前 「只读」 路由。 // 它使用 Router 初始化，如果你手动更改了名称，除了当你是使用`GetCurrentRoute()` // 的时候将获取到其他路由，其它没啥变化。 // 为了从上下文中执行一个不同的路径，你应该使用 `Exec` 函数， // 或者通过 `SetHandlers/AddHandler` 函数改变处理方法。 SetCurrentRouteName(currentRouteName string) // GetCurrentRoute 返回当前注册到当前请求路径的 「只读」路由。 GetCurrentRoute() RouteReadOnly // AddHandler 可以在服务时添加处理方法到当前请求，但是这些处理方法不会持久化到路由。 // // Router 将会调用这些添加到某个路由的处理方法。如果 AddHandler 被调用， // 那么处理方法将被添加到已经定义的路由的处理方法的后面。 AddHandler(...Handler) // SetHandlers 替换所有原有的处理方法。 SetHandlers(Handlers) // Handlers 记录当前的处理方法。 Handlers() Handlers // HandlerIndex 设置当前上下文处理方法链中当前索引。 // 如果传入 -1 ，不会当前索引。 // // 也可以查看 Handlers(), Next() and StopExecution()。 HandlerIndex(n int) (currentIndex int) // HandlerName 返回当前路由名称，方便调试。 HandlerName() string // Next 调用从处理方法链中选择剩下的进行调用，他应该被用于一个中间件中。 // // 提醒：自定义的上下文应该重写这个方法，以便能够传入他自己的 context.Context 实现。 Next() // NextHandler 从处理链中返回下一个处理方法(但不执行)。 // // 为了执行下一个 ，可以使用 .Skip() 跳过某个处理方法。 NextHandler() Handler // Skip 从处理链中 忽略/跳过 下一个处理方法。 // 它应该在中间件内使用。 Skip() // 如果调用了 StopExecution ，接下来的 .Next 调用将被局略。 StopExecution() // IsStopped 检查当前位置的Context是否是255, 如果是, 则返回true, 意味着 StopExecution() 被调用了。 IsStopped() bool // +------------------------------------------------------------+ // | 当前的 &quot;user/request&quot; 存储 | // | 处理方法之间共享信息 - Values(). | // | 保存并获取路径参数 - Params() | // +------------------------------------------------------------+ // Params 返回当前URL中的命名参数。命名的路径参数是被保存在这里的。 // 这个存储对象随着整个上下文，存活于每个请求声明周期。 Params() *RequestParams // Values 返回当前 「用户」的存储信息。 // 命名路径参数和任何可选数据可以保存在这里。 // 这个存储对象，也是存在于整个上下文，每个请求的声明周期中。 // // 你可以用这个函数设置和获取用于在处理方法和中间件之间共享信息的局部值。 Values() *memstore.Store // Translate 是 i18n 函数，用于本地化。它调用 Get(&quot;translate&quot;) 返回翻译值。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/miscellaneous/i18n Translate(format string, args ...interface&#123;&#125;) string // +------------------------------------------------------------+ // | 路径, 主机, 子域名, IP, HTTP 头 等 | // +------------------------------------------------------------+ // Method 返回 request.Method， 客户端的请求方法。 Method() string // Path 返回完整请求路径，如果 EnablePathEscape 为 True，将会转义。 Path() string // RequestPath 返回转义过的请求完整路径。 RequestPath(escape bool) string // Host 返回当前URL的主机部分。 Host() string // Subdomain 返回当前请求的子域名，如果有。 // 提醒，这个方法可能在某些情况下不能正常使用。 Subdomain() (subdomain string) // RemoteAddr 尝试解析并返回客户端正式IP。 // // 基于允许的头名称，可以通过 Configuration.RemoteAddrHeaders 修改。 // // 如果基于这些请求头的解析失败，将会 Request 的 `RemoteAddr` 字段，它在 Http 处理方法之前有 server 填充。 // // 查看 `Configuration.RemoteAddrHeaders`, // `Configuration.WithRemoteAddrHeader(...)`, // `Configuration.WithoutRemoteAddrHeader(...)` 获取更多信息。 RemoteAddr() string // GetHeader 返回指定的请求头值。 GetHeader(name string) string // IsAjax 返回这个请求是否是一个 &#x27;ajax request&#x27;( XMLHttpRequest)。 // // 不能百分之百确定一个请求是否是Ajax模式。 // 永远不要信任来自客户端的数据，他们很容易被篡改。 // // 提醒，&quot;X-Requested-With&quot; 头可以被任何客户端修改，对于十分严重的情况，不要依赖于 IsAjax。 // 试试另外的鉴别方式，例如，内容类型（content-type）。 // 有很多描述这些问题的博客并且提供了很多不同的解决方案，这就是为什么说 `IsAjax` // 太简单，只能用于一般目的。 // // 更多请看： https://developer.mozilla.org/en-US/docs/AJAX // 以及： https://xhr.spec.whatwg.org/ IsAjax() bool // +------------------------------------------------------------+ // | 响应头助手 | // +------------------------------------------------------------+ // Header 添加响应头到响应 writer。 Header(name string, value string) // ContentType 设置响应头 &quot;Content-Type&quot; 为 &#x27;cType&#x27;。 ContentType(cType string) // GetContentType 返回响应头 &quot;Content-Type&quot; 的值。 GetContentType() string // StatusCode 设置响应状态码。 // 也可查看 .GetStatusCode。 StatusCode(statusCode int) // GetStatusCode 返回当前响应的状态码。 // 也可查阅 StatusCode。 GetStatusCode() int // Redirect 发送一个重定向响应到客户端，接受两个参数，字符串和可选的证书。 // 第一个参数是重定向的URL，第二个是重定向状态码，默认是302。 // 如果必要，你可以设置为301，代表永久转义。 Redirect(urlToRedirect string, statusHeader ...int) // +------------------------------------------------------------+ // | 各种请求和 POST 数据 | // +------------------------------------------------------------+ // URLParam 返回请求中的参数，如果有。 URLParam(name string) string // URLParamInt 从请求返回 int 类型的URL参数，如果解析失败，返回错误。 URLParamInt(name string) (int, error) // URLParamInt64 从请求返回 int64 类型的参数，如果解析失败，返回错误。 URLParamInt64(name string) (int64, error) // URLParams 返回请求查询参数映射，如果没有，返回为空。 URLParams() map[string]string // FormValue 返回一个表单值。 FormValue(name string) string // FormValues 从 data，get，post 和 查询参数中返回所有的数据值以及他们的键。 // // 提醒: 检查是否是 nil 是很有必要的。 FormValues() map[string][]string // PostValue 仅仅根据名称返回表单的post值，类似于 Request.PostFormValue。 PostValue(name string) string // FormFile 返回键指定的第一个文件。 // 如果有必要，FormFile 调用 ctx.Request.ParseMultipartForm 和 ParseForm。 // // 类似于 Request.FormFile. FormFile(key string) (multipart.File, *multipart.FileHeader, error) // +------------------------------------------------------------+ // | 自定义 HTTP 错误 | // +------------------------------------------------------------+ // NotFound 发送一个 404 错误到客户端，使用自定义的错误处理方法。 // 如果你不想剩下的处理方法被执行，你可能需要去调用 ctx.StopExecution()。 // 你可以将错误码改成更具体的，例如： // users := app.Party(&quot;/users&quot;) // users.Done(func(ctx context.Context)&#123; if ctx.StatusCode() == 400 &#123; /* custom error code for /users */ &#125;&#125;) NotFound() // +------------------------------------------------------------+ // | Body Readers | // +------------------------------------------------------------+ // SetMaxRequestBodySize 设置请求体大小的上限，应该在读取请求体之前调用。 SetMaxRequestBodySize(limitOverBytes int64) // UnmarshalBody 读取请求体，并把它绑定到一个任何类型或者指针的值。 // 使用实例: context.ReadJSON, context.ReadXML。 UnmarshalBody(v interface&#123;&#125;, unmarshaler Unmarshaler) error // ReadJSON 从请求体读取 JSON，并把它绑定到任何json有效类型的值。 ReadJSON(jsonObject interface&#123;&#125;) error // ReadXML 从请求体读取 XML，并把它绑定到任何xml有效类型的值。 ReadXML(xmlObject interface&#123;&#125;) error // ReadForm 是用表单数据绑定 formObject，支持任何类型的结构体。 ReadForm(formObject interface&#123;&#125;) error // +------------------------------------------------------------+ // | Body (raw) Writers | // +------------------------------------------------------------+ // Write 将数据作为一个HTTP响应的一部分写入连接。 // // 如果 WriteHeader 还没有调用，Write 将在 写入数据之前调用 WriteHeader(http.StatusOK)。 // 如果 Header 没有 Content-Type，Write 添加一个 Content-Type，设置为写入数据的前 // 512 字节的类型。 // // 取决于 HTTP 版本和客户端，调用 Write 或者 WriteHeader 可能组织以后读取 Request.Body。 // 对于 HTTP/1.x 请求，处理方法应该在写入响应之前读取所有必要的请求体数据。一旦 HTTP 头被清掉 // (显示调用 Flusher.Flush 或者写入了足够的数据触发了清空操作)，请求体可能变得不可用。 // 对于 HTTP/2 请求，Go HTTP 服务器允许在写入响应的同时读取请求体。然而，这种行为可能不被所有 // HTTP/2 客户端支持。处理方法应该尽可能读取最大量的数据在写入之前。 Write(body []byte) (int, error) // Writef 根据格式声明器格式化，然后写入响应。 // // 返回写入的字节数量以及任何写入错误。 Writef(format string, args ...interface&#123;&#125;) (int, error) // WriteString 将一个简单的字符串写入响应。 // // 返回写入的字节数量以及任何写入错误。 WriteString(body string) (int, error) // WriteWithExpiration 很像 Write，但是它发送了一个失效时间，它会被每个包级别的 // `StaticCacheDuration` 字段刷新。 WriteWithExpiration(body []byte, modtime time.Time) (int, error) // StreamWriter 注册给定的流用于发布响应体。 // // 这个函数可能被用于一下这些情况： // // * 如果响应体太大（超过了iris.LimitRequestBodySize） // * 如果响应体是慢慢从外部资源流入 // * 如果响应体必须分片流向客户端（例如 `http server push`） StreamWriter(writer func(w io.Writer) bool) // +------------------------------------------------------------+ // | 带压缩的 Body Writers | // +------------------------------------------------------------+ // 如果客户端支持 gzip 压缩，ClientSupportsGzip 返回 true。 ClientSupportsGzip() bool // WriteGzip accepts bytes, which are compressed to gzip format and sent to the client. // WriteGzip 接受压缩成 gzip 格式的字节然后发送给客户端，并返回写入的字节数量和错误（如果错误不支持 gzip 格式） // // 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。 WriteGzip(b []byte) (int, error) // TryWriteGzip 接受 gzip 格式压缩的字节，然后发送给客户端。 // 如果客户端不支持 gzip，就按照他们原来未压缩的样子写入。 // // 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。 TryWriteGzip(b []byte) (int, error) // GzipResponseWriter converts the current response writer into a response writer // GzipResponseWriter 将当前的响应 writer 转化为一个 gzip 响应 writer。 // 当它的 .Write 方法被调用的时候，数据被压缩成 gzip 格式然后把他们写入客户端。 // // 也可以使用 .Disable 禁用以及使用 .ResetBody 回滚到常规的响应写入器。 GzipResponseWriter() *GzipResponseWriter // Gzip 开启或者禁用 gzip 响应写入器，如果客户端支持 gzip 压缩，所以接下来的响应数据将被作为 // 压缩的 gzip 数据发送给客户端。 Gzip(enable bool) // +------------------------------------------------------------+ // | 富文本内容渲染器 | // +------------------------------------------------------------+ // ViewLayout 设置 「布局」选项，如果随后在相同的请求中 .View 被调用。 // 当需要去改变或者设置处理链中前一个方法的布局时很有用。 // // 注意 &#x27;layoutTmplFile&#x27; 参数可以被设置为 iris.NoLayout 或者 view.NoLayout 去禁用某个试图渲染动作的布局。 // 它禁用了配置项的布局属性。 // // 也可查看 .ViewData 和 .View。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/ ViewLayout(layoutTmplFile string) // ViewData 保存一个或者多个键值对为了在后续的 .View 被调用的时候使用。 // 当需要处理链中前一个处理器的模板数据的时候是很有用的。 // // 如果 .View 的绑定参数不是 nil 也不是 map 类型，这些数据就会被忽略，绑定是有优先级的，所以住路由的处理方法仍然有效。 // 如果绑定是一个map或者context.Map，这些数据然后就被添加到视图数据然后传递给模板。 // // .View 调用之后，这些数据不会被丢掉，为了在必要的时候重用（再次声明，同一个请求中），为了清除这些数据，开发者可以调用 // ctx.Set(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey(), nil)。 // // 如果 &#x27;key&#x27; 是空的，然后 值被作为它的（struct 或者 map）添加，并且开发者不能添加其他值。 // // 推荐查看 .ViewLayout 和 .View。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/ ViewData(key string, value interface&#123;&#125;) // GetViewData 返回 `context#ViewData` 注册的值。 // 返回值是 `map[string]interface&#123;&#125;` 类型，这意味着如果一个自定义的结构体被添加到 ViewData， 这个函数将把它解析成 // map，如果失败返回 nil。 // 如果不同类型的值或者没有数据通过 `ViewData` 注册，检查是否为nil总是好的编程规范。 // // 类似于 `viewData := ctx.Values().Get(&quot;iris.viewData&quot;)` 或者 // `viewData := ctx.Values().Get(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey())`。 GetViewData() map[string]interface&#123;&#125; // View 基于适配的视图引擎渲染模板。第一个参数是接受相对于视图引擎目录的文件名， // 例如如果目录是 &quot;./templates&quot;，想要渲染： &quot;./templates/users/index.html&quot; // 你应该传递 &quot;users/index.html&quot; 作为文件名参数。 // 也可以查看 .ViewData 和 .ViewLayout。 // 示例：https://github.com/kataras/iris/tree/master/_examples/view/ View(filename string) error // Binary 将原生字节作为二进制数据返回。 Binary(data []byte) (int, error) // Text 将字符串作为空白文本返回。 Text(text string) (int, error) // HTML 将字符串作为 text/html 返回. HTML(htmlContents string) (int, error) // JSON 格式化给定的数据并且返回 json 数据。 JSON(v interface&#123;&#125;, options ...JSON) (int, error) // JSONP 格式化给定的数据并且返回 json 数据。 JSONP(v interface&#123;&#125;, options ...JSONP) (int, error) // XML 格式话给定数据，并返回 XML 数据。 XML(v interface&#123;&#125;, options ...XML) (int, error) // Markdown 解析 markdown 数据为 HTML 返回给客户端。 Markdown(markdownB []byte, options ...Markdown) (int, error) // +------------------------------------------------------------+ // | 文件响应 | // +------------------------------------------------------------+ // ServeContent 返回的内容头是自动设置的，接受三个参数，它是一个低级的函数，你可以调用 .ServeFile(string,bool)/SendFile(string,string)。 // 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，不要实现 resuming，而应该使用 ctx.SendFile。 ServeContent(content io.ReadSeeker, filename string, modtime time.Time, gzipCompression bool) error // ServeFile 渲染一个视图文件，如果要发送一个文件（例如zip文件）到客户端，你应该使用 SendFile(serverfilename,clientfilename)。 // 接受两个参数： // filename/path (string) // gzipCompression (bool) // 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，这个函数没有实现 resuming，你应该使用 ctx.SendFile。 ServeFile(filename string, gzipCompression bool) error // SendFile 发送强制下载的文件到客户端 // // 使用这个而不是 ServeFile 用于大文件下载到客户端。 SendFile(filename string, destinationName string) error // +------------------------------------------------------------+ // | Cookies | // +------------------------------------------------------------+ // SetCookie 添加cookie SetCookie(cookie *http.Cookie) // SetCookieKV 添加一个 cookie，仅仅接受一个名字（字符串）和一个值（字符串） // // 如果你用这个方法设置cookie，它将在两小时之后失效。 // 如果你想去设置或者改变更多字段，使用 ctx.SetCookie 或者 http.SetCookie。 SetCookieKV(name, value string) // GetCookie 通过名称返回值，如果没找到返回空字符串。 GetCookie(name string) string // RemoveCookie 通过名字删除 cookie。 RemoveCookie(name string) // VisitAllCookies 接受一个 visitor 循环每个cookie，visitor 接受两个参数：名称和值。 VisitAllCookies(visitor func(name string, value string)) // MaxAge 返回 &quot;cache-control&quot; 请求头的值，单位为：秒，类型为 int64 // 如果头没有发现或者解析失败返回 -1。 MaxAge() int64 // +------------------------------------------------------------+ // | 高级部分: 响应记录器和事务 | // +------------------------------------------------------------+ // Record 转化上下文基本的 responseWriter 为 ResponseRecorder，它可以被用于在任何时候重置内容体， // 重置响应头，获取内容体，获取和设置状态码。 Record() // Recorder 返回上下文的 ResponseRecorder，如果没有 recording 然后它将开始记录并返回新的上下文的 ResponseRecorder。 Recorder() *ResponseRecorder // IsRecording 返回响应记录器以及一个bool值 // true 表示响应记录器正在记录状态码，内容体，HTTP 头以及更多，否则就是 false IsRecording() (*ResponseRecorder, bool) // BeginTransaction 开启一个有界事务。 // // 你可以搜索第三方文章或者查看事务 Transaction 如何工作（这里相当简单特别）。 // // 记着这个是唯一的，也是新的，目前为止，我没有在这个项目中看到任何例子和代码，就大多数 iris 功能而言。 // 它没有覆盖所有路径，例如数据库，这个应该由你使用的创建数据库连接的库管理，这个事务域仅仅用于上下文响应， // // 阅读 https://github.com/kataras/iris/tree/master/_examples/ 查看更多。 BeginTransaction(pipe func(t *Transaction)) // 如果调用 SkipTransactions 将跳过剩余的事务，或者如果在第一个事务之前调用，将跳过所有 SkipTransactions() // TransactionsSkipped 返回事务到底被跳过还是被取消了。 TransactionsSkipped() bool // Exec根据这个上下文调用framewrok的ServeCtx，但是改变了方法和路径，就像用户请求的那样，但事实并非如此。 // // 离线意味着路线已注册到 iris 并具有正常路由所具有的所有功能。 // 但是它不能通过浏览获得，它的处理程序仅在其他处理程序的上下文调用它们时执行，它可以验证路径，拥有会话，路径参数等。 // // 你可以通过 app.GetRoute(&quot;theRouteName&quot;) 找到路由，你可以设置一个路由名称如： // myRoute := app.Get(&quot;/mypath&quot;, handler)(&quot;theRouteName&quot;) // 这个将给路由设置一个名称并且返回它的 RouteInfo 实例为了进一步使用。 // // 它不会更改全局状态，如果路由处于“脱机”状态，它将保持脱机状态。 // // app.None(...) and app.GetRoutes().Offline(route)/.Online(route, method) // // 实例：https://github.com/kataras/iris/tree/master/_examples/routing/route-state // // 用户可以通过简单调用得到响应：rec := ctx.Recorder(); rec.Body()/rec.StatusCode()/rec.Header() // // Context 的 Values 和 Session 被记住为了能够通过结果路由通信， // // 它仅仅由于特别案例，99% 的用户不会用到的。 Exec(method string, path string) // Application 返回 属于这个上下文的 iris 实例。 // 值得留意的是这个函数返回 Application 的一个接口，它包含的方法能够安全地在运行是执行。 // 为了开发者的安全性，整个 app 的 字段和方法这里是不可用的。 Application() Application","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"go:并发","slug":"go-并发","date":"2023-04-07T10:59:37.000Z","updated":"2023-05-19T09:37:10.230Z","comments":true,"path":"2023/04/07/go-并发/","link":"","permalink":"https://www.napleon.cn/2023/04/07/go-%E5%B9%B6%E5%8F%91/","excerpt":"Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。","text":"Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。 123456789101112131415161718package main import ( &quot;fmt&quot; &quot;time&quot;)func say(s string) &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(s) &#125;&#125;func main () &#123; go say(&quot;world&quot;) say(&quot;hello&quot;)&#125;// 该代码的运行结果不唯一，因为是两个goroutine在执行 通道通道是用来传递数据的数据结构 通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于制定通道的方向，如果未指定方向，则为双向通道。 12345ch &lt;- v // 把v发送到chv := &lt;-ch // 从ch接收数据 // 并把值赋给v// 声明一个通道ch := make(chan int) 默认情况下，通道是不带缓冲区的。 带缓冲区的通道通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小： 1ch := make(chan int, 100) 如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 Go通过range关键字来实现遍历读取到的数据，格式如下： 1v, ok := &lt;- ch 关闭通道如果通道接收不到数据后ok就为false，这时通道就可以使用close函数来关闭。 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot;)func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x + y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"go:方法与接口","slug":"go-方法与接口","date":"2023-04-05T02:31:55.000Z","updated":"2023-05-19T09:37:11.646Z","comments":true,"path":"2023/04/05/go-方法与接口/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/","excerpt":"7.1 接口的定义Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 12345type iface struct &#123; tab *itab; data unsafe.Pointer &#125;","text":"7.1 接口的定义Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 12345type iface struct &#123; tab *itab; data unsafe.Pointer &#125; 7.2 接口使用实例12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)type Phone interface &#123; // 定义了一个接口Phone, 有方法call() call()&#125;type NokiaPhone struct &#123; // 接口Phone的一个实现&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123; // 接口Phone的一个实现&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone // 利用接口实现多态 phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; ​","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"go:数据","slug":"go-数据","date":"2023-04-05T01:26:17.000Z","updated":"2023-05-19T09:37:10.981Z","comments":true,"path":"2023/04/05/go-数据/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%95%B0%E6%8D%AE/","excerpt":"5.1 字符串string字符串是不可变字符序列 默认值为空串，而不是空指针。 遍历 12345678910111213func main() &#123; s := &#x27;Hello, world&#x27; // byte for i := 0; i &lt; len(s); i++ &#123; println(&quot;%d: [%c]\\n&quot;, i, s[i]); &#125; // rune for i, c := range s &#123; println(&quot;%d ,[%c]\\n&quot;, i, c); &#125;&#125;","text":"5.1 字符串string字符串是不可变字符序列 默认值为空串，而不是空指针。 遍历 12345678910111213func main() &#123; s := &#x27;Hello, world&#x27; // byte for i := 0; i &lt; len(s); i++ &#123; println(&quot;%d: [%c]\\n&quot;, i, s[i]); &#125; // rune for i, c := range s &#123; println(&quot;%d ,[%c]\\n&quot;, i, c); &#125;&#125; 5.2 数组5.2.1 数组的初始化1234567891011func main() &#123; var a [4]int // 元素自动初始成0 b := [4]int&#123;2, 5&#125; // 剩余元素自动初始化成0 c := [4]int&#123;5, 3:10&#125;; // 指定索引位置 d := [...]int&#123;1, 2, 3&#125; // 编译器确定数组长度 // 在定义多维数组时， 仅第一维允许使用... b := [...][2]int &#123; &#123;10, 20&#125;, &#123;30 ,40&#125;, &#125;&#125; 5.2.2 指针12345func main() &#123; x, y := 10 ,20 a := [...]*int&#123;&amp;x, &amp;y&#125; // 指针数组 p = &amp;a // 数组指针&#125; 5.2.3 复制与C数组变量隐式作为指针使用不同， Go数组是值类型，赋值和传参工作都会复制整个数组数据 5.3 切片slice本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。 123456// 数据结构type slice strcut &#123; arrary unsafe.Pointer len int // 限定可读的写元素数量 cap int // 切片所引用数组片段的真实长度&#125; 切片本身是一个只读对象， 其工作机制类似数组指针的一种包装 5.3.1 创建切片对象1234func main() &#123; s1 := make([]int, 3, 5) //指定len, cap, 底层数组初始化成零值 s2 := make([int], 3) // 省略cap, 和len相等&#125; 切片是包装过的数组对象，用来代替数组减少值传递带来的开销 5.4 字典基本操作12345678910func main() &#123; m := map[string]int &#123; &quot;a&quot;: 1, &quot;b&quot;: 2, &#125; // 判断key是否存在 if v, ok := m[&quot;d&quot;]; ok &#123; println(v) &#125; // 访问不存在的键值， 默认返回零值&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}],"keywords":[]},{"title":"vim杂谈","slug":"vim杂谈","date":"2023-04-02T14:25:14.000Z","updated":"2023-04-03T02:56:29.643Z","comments":true,"path":"2023/04/02/vim杂谈/","link":"","permalink":"https://www.napleon.cn/2023/04/02/vim%E6%9D%82%E8%B0%88/","excerpt":"vim是Linux环境下的一款重要的文本编辑器。","text":"vim是Linux环境下的一款重要的文本编辑器。 1. 基本使用1.1 三种基本模式 一般模式 编辑模式 命令行模式 1.2 按键一般模式(hjkl)对应(左下上右) “30j” &#x3D; 向下移动三十行 C+f 屏幕向下移动一页 C+b 屏幕向上移动一页 “+” 光标移动到非空格行的下一行 “-“ 光标移动到非空格行的上一行 n 光标向后移动20个字符的距离 n[Enter] 光标向下移动n行 G 移动到这个文件的最后一行 &#x2F;word 向下寻找名为word的字符串 dd 删除光标所在的一整行 yy 复制一整行 x [delete] X[backsapce] u 复原前一个操作 C+r 重做上一个操作 . 重复前一个操作","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"}],"keywords":[]},{"title":"9.虚拟内存","slug":"9-虚拟内存","date":"2023-03-29T07:26:42.000Z","updated":"2023-04-09T02:43:00.308Z","comments":true,"path":"2023/03/29/9-虚拟内存/","link":"","permalink":"https://www.napleon.cn/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","excerpt":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。","text":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。 9.1 物理和虚拟寻址CPU—(VA)–&gt;MMU—-&gt;PA—–&gt;Memory","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}],"keywords":[]},{"title":"8.异常控制流","slug":"8-异常控制流","date":"2023-03-29T03:17:27.000Z","updated":"2023-04-09T02:42:33.741Z","comments":true,"path":"2023/03/29/8-异常控制流/","link":"","permalink":"https://www.napleon.cn/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"CSAPP关于异常处理的章节。","text":"CSAPP关于异常处理的章节。 8.4进程控制8.4.1 获取进程ID12345#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t getpid(void); //获取进程的pidpid_t getppid(void); // 获取进程父进程的pid 8.4.2 创建和终止进程12345678910#include &lt;stdlib.h&gt;/*exit函数以status退出状态来终止进程*/void exit(int status);/*父进程通过调用fork函数创建一个新的运行的子进程*/pid_t fork(void);// 返回值：子进程返回0，父进程返回子进程的PID，如果出错，返回-1. fork被调用一次，却会返回两次：父进程返回子进程的PID，子进程返回0. 12345678910111213141516171819int main() &#123; pid_t pid; int x = 1; pid = fork(); if (pid == 0) &#123; prinf(&quot;child: x = %d\\n&quot;, ++x); exit(0); &#125; prinf(&quot;parent: x = %d\\n&quot;, --x); exit(0);&#125;/*parent: x = 0child: x = 2or child: x = 2parent: x = 0*/ 8.4.3 回收子进程如果一个父进程终止，内核会安排init进程成为他的孤儿进程的养父 8.4.6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 一个简单的shell的main例程 *//*shellex.c*/#include &quot;csapp.h&quot;#define MAXARGS 128/* Function protoytpes */void eval(char* cmdline);int parseline(char* buf, char** argv);int builtin_command(char** argv);int main() &#123; char cmdline[MAXLINE]; // Command line while (1) &#123; /* Read */ printf(&quot;&gt; &quot;); Fgets(cmdline, MAXLINE, stdin); if (feof(stdin)) exit(0); /* Evaluate */ eval(cmdline); &#125;&#125;/* Evaluate a commmand line*/void eval(char* cmdline) &#123; char* argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; strcpy(buf, cmdline); bg = parseline(buf, argv); if (argv[0] == NULL) return ; // Ignore empty line if (!builtin_command(argv)) &#123; if ( (pid = Fork()) == 0 ) &#123; if (execve(argv[0], argv, environ) &lt; 0) &#123; printf(&quot;%s: Command not found.\\n&quot;, argv[0]); exit(0); &#125; &#125; // Parent waits for foreground job to terminate if (!bg) &#123; int status; if (waitpid(pid, &amp;status, 0) &lt; 0) unix_error(&quot;waitfg: waitpid error&quot;); &#125; else printf(&quot;%d %s&quot;, pid, cmdline); &#125; return ;&#125;/* If first arg is a builtin command, run it and return true*/int builtin_command(char** argv) &#123; if (!strcmp(argv[0], &quot;quit&quot;)) exit(0); if (!strcmp(argv[0], &quot;&amp;&quot;)) return 1; return 0;&#125;/* parseline - Parse the command line and build the argv array*/int parseline(char* buf, char** argv) &#123; char* delim; // points to the first space delimiter int argc; // number of args int bg; buf[strlen(buf) - 1] = &#x27; &#x27;; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf ++; /* build the argv list */ argc = 0; while ( (delm = strchr(buf, &#x27; &#x27;) ) ) &#123; argv[argc++] = buf; *delim = &#x27;\\0&#x27;; buf = delim + 1; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf++; &#125; argv[argc] = NULL; if (argc == 0) return 1; if ((bg = (*argv[argc - 1] == &#x27;&amp;&#x27;)) != 0) argv[--argc] = NULL; return bg;&#125; 8.5 信号Linux信号: 软件形式的异常 8.5.1 信号的术语发送信号到用户进程的步骤： 发送信号。 方式： 更新进程上下文的状态。 发送信号的原因： 1. 监测到异常、2进程调用了kill。 接收信号。进程接收信号并将信号转移给信号处理程序。 8.5.2 发送信号1. 进程组12345#include&lt;unistd.h&gt;pid getgrp(void); // 返回进程的进程组id// 子进程与父进程的进程组id默认相同int setpgid(pid_t pid, pid_t pgid); // 改变进程的进程组id 2. 用&#x2F;bin&#x2F;kill程序发送信号1234linux&gt; /bin/kill -9 15213// 发送信号SIGKILL给pid为15213的进程linux&gt; /bin/kill -9 -15213// 发送信号SIGKILL给pgid为15213下的所有进程 3.从键盘发送信号12Ctrl + C // 终止前台作业Ctrl + C // 挂起前台作业 4. 用kill函数发送信号1","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}],"keywords":[]}]}