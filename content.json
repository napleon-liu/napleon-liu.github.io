{"meta":{"title":"Napleon","subtitle":"Napleon的个人博客","description":"真正的慷慨，就是把一切都献给现在。","author":"napleon-liu","url":"https://www.napleon.cn","root":"/"},"pages":[{"title":"about","date":"2023-03-29T07:23:32.000Z","updated":"2023-03-29T07:24:11.628Z","comments":true,"path":"about/index.html","permalink":"https://www.napleon.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T02:46:26.935Z","comments":true,"path":"categories/index.html","permalink":"https://www.napleon.cn/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T09:02:18.622Z","comments":true,"path":"guestbook/index.html","permalink":"https://www.napleon.cn/guestbook/index.html","excerpt":"","text":"欢迎来到我的博客！ 欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的，添加email可以获得更快的回复速度，在nickname栏目输入QQ号可以直接获取你的QQ头像。"},{"title":"tags","date":"2023-03-29T02:48:59.000Z","updated":"2023-03-29T02:49:18.511Z","comments":true,"path":"tags/index.html","permalink":"https://www.napleon.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iris:day1","slug":"iris-day1","date":"2023-04-08T02:45:15.000Z","updated":"2023-04-08T04:16:15.764Z","comments":true,"path":"2023/04/08/iris-day1/","link":"","permalink":"https://www.napleon.cn/2023/04/08/iris-day1/","excerpt":"","text":"概览MVC架构模式的示意图： 下面是一个使用MVC架构实现的一个简单Iris App 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( &quot;github.com/kataras/iris&quot; &quot;github.com/kataras/iris/middleware/logger&quot; &quot;github.com/kataras/iris/middleware/recover&quot; &quot;github.com/kataras/iris/mvc&quot;)func main() &#123; app := iris.New() app.Use(recover.New()) app.Use(logger.New())mvc.New(app).Handle(new(ExampleController)) // http://localhost:8080 // http://localhost:8080/ping // http://localhost:8080/hello app.Run(iris.Addr(&quot;:8080&quot;))&#125;// ExampleController serves the &quot;/&quot;, &quot;/ping&quot; and &quot;/hello&quot;.type ExampleController struct &#123;&#125;// Get serves// Method: GET// Resource: http://localhost:8080func (c *ExampleController) Get() mvc.Result &#123; return mvc.Response&#123; ContentType: &quot;text/html&quot;, Text: &quot;&lt;h1&gt;Welcome&lt;/h1&gt;&quot;, &#125;&#125;// GetPing serves// Method: GET// Resource: http://localhost:8080/pingfunc (c *ExampleController) GetPing() string &#123; return &quot;pong&quot;&#125;// GetHello serves// Method: GET// Resource: http://localhost:8080/hellofunc (c *ExampleController) GetHello() interface&#123;&#125; &#123; return map[string]string&#123;&quot;message&quot;: &quot;Hello Iris!&quot;&#125;&#125; HTTP主机配置监听和服务服务器的初始化用Run方法执行 12345678910111213// 在 Tcp 上监听网络地址 0.0.0.0:8080app.Run(iris.Addr(&quot;:8080&quot;))// 和前面一样，但是使用自定义 http.Server 也可以在其他地方运行app.Run(iris.Server(&amp;http.Server&#123;Addr:&quot;:8080&quot;&#125;))// 创建一个自定义的或者标准的net.Listener并传递给app.Run// 使用自定义 net.Listenerl, err := net.Listen(&quot;tcp4&quot;, &quot;:8080&quot;)if err != nil &#123; panic(err)&#125;app.Run(iris.Listener(l)) 下面是一个完整的例子 1234567891011121314151617181920212223242526272829package mainimport ( &quot;os&quot; &quot;net&quot; &quot;github.com/kataras/iris&quot;)func main() &#123; app := iris.New() // UNIX socket if errOs := os.Remove(socketFile); errOs != nil &amp;&amp; !os.IsNotExist(errOs) &#123; app.Logger().Fatal(errOs) &#125; l, err := net.Listen(&quot;unix&quot;, socketFile) if err != nil &#123; app.Logger().Fatal(err) &#125; if err = os.Chmod(socketFile, mode); err != nil &#123; app.Logger().Fatal(err) &#125; app.Run(iris.Listener(l))&#125; 主机配置程序以上所有的监听都是接收 func(*iris.Supervisor)为最后一个变量。可以通过这些函数传递的特定主机来添加配置程序。 下面的示例代码在服务器关闭时触发一个回调函数 12345app.Run(iris.Addr(&quot;:8080&quot;, func(h *iris.Supervisor) &#123; h.RegisterOnShutdown(func() &#123; println(&quot;server terminated&quot;) &#125;)&#125;)) HTTP路由Handler Handler 用于处理请求 APIiris提供了所有的HTTP方法，第一个参数是路由路径，第二个可变参数是一个或者多个iris.Handler 1234567891011121314151617181920212223242526272829303132333435app := iris.New()// 方法: &quot;GET&quot;app.Get(&quot;/&quot;, handler)// 方法: &quot;POST&quot;app.Post(&quot;/&quot;, handler)// 方法: &quot;PUT&quot;app.Put(&quot;/&quot;, handler)// 方法: &quot;DELETE&quot;app.Delete(&quot;/&quot;, handler)// 方法: &quot;OPTIONS&quot;app.Options(&quot;/&quot;, handler)// 方法: &quot;TRACE&quot;app.Trace(&quot;/&quot;, handler)// 方法: &quot;CONNECT&quot;app.Connect(&quot;/&quot;, handler)// 方法: &quot;HEAD&quot;app.Head(&quot;/&quot;, handler)// 方法: &quot;PATCH&quot;app.Patch(&quot;/&quot;, handler)// 用于所有 HTTP 方法app.Any(&quot;/&quot;, handler)func handler(ctx iris.Context)&#123; ctx.Writef(&quot;Hello from method: %s and path: %s&quot;, ctx.Method(), ctx.Path())&#125; 路由分组一组路由可以用前缀路径分组，组之间共享相同的中间件和模板布局，组内可以嵌套组。 .Party 被用于分组路由，开发者可以声明不限数量的分组。 示例代码： 12345678app := iris.New()users := app.Party(&quot;/users&quot;, myAuthMiddlewareHandler)// http://localhost:8080/users/42/profileusers.Get(&quot;/&#123;id:int&#125;/profile&quot;, userProfileHandler)// http://localhost:8080/users/messages/1users.Get(&quot;/messages/&#123;id:int&#125;&quot;, userMessageHandler) Context机制上下文是服务器用于所有客户端的中间人“对象” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421// 上下文是服务器用于所有客户端的中间人 &quot;对象&quot;。// // 对于每一个新的连接，会从 sync.Pool 中获取一个新上下文对象。// 上下文是 iris 的 http 流中最重要的部分。//// 开发者发送响应到客户端的请求通过一个上下文。// 开发者获取请求信息从客户端的请求上下文中。// // context 是 context.Context 子包的一个实现。// context.Context 是很好扩展，所以开发者可以按照实际所需重写它的方法。type Context interface &#123; // ResponseWriter 如期返回一个兼容 http.ResponseWriter 的 响应writer。 ResponseWriter() ResponseWriter // ResetResponseWriter 应该改变或者升级上下文的 ResponseWriter。 ResetResponseWriter(ResponseWriter) // Request 方法如期返回原始的 *http.Request。 Request() *http.Request // SetCurrentRouteName 方法设置内部路由名称，为了当开发者调用 // `GetCurrentRoute()` 方法的时候能够正确返回当前 「只读」 路由。 // 它使用 Router 初始化，如果你手动更改了名称，除了当你是使用`GetCurrentRoute()` // 的时候将获取到其他路由，其它没啥变化。 // 为了从上下文中执行一个不同的路径，你应该使用 `Exec` 函数， // 或者通过 `SetHandlers/AddHandler` 函数改变处理方法。 SetCurrentRouteName(currentRouteName string) // GetCurrentRoute 返回当前注册到当前请求路径的 「只读」路由。 GetCurrentRoute() RouteReadOnly // AddHandler 可以在服务时添加处理方法到当前请求，但是这些处理方法不会持久化到路由。 // // Router 将会调用这些添加到某个路由的处理方法。如果 AddHandler 被调用， // 那么处理方法将被添加到已经定义的路由的处理方法的后面。 AddHandler(...Handler) // SetHandlers 替换所有原有的处理方法。 SetHandlers(Handlers) // Handlers 记录当前的处理方法。 Handlers() Handlers // HandlerIndex 设置当前上下文处理方法链中当前索引。 // 如果传入 -1 ，不会当前索引。 // // 也可以查看 Handlers(), Next() and StopExecution()。 HandlerIndex(n int) (currentIndex int) // HandlerName 返回当前路由名称，方便调试。 HandlerName() string // Next 调用从处理方法链中选择剩下的进行调用，他应该被用于一个中间件中。 // // 提醒：自定义的上下文应该重写这个方法，以便能够传入他自己的 context.Context 实现。 Next() // NextHandler 从处理链中返回下一个处理方法(但不执行)。 // // 为了执行下一个 ，可以使用 .Skip() 跳过某个处理方法。 NextHandler() Handler // Skip 从处理链中 忽略/跳过 下一个处理方法。 // 它应该在中间件内使用。 Skip() // 如果调用了 StopExecution ，接下来的 .Next 调用将被局略。 StopExecution() // IsStopped 检查当前位置的Context是否是255, 如果是, 则返回true, 意味着 StopExecution() 被调用了。 IsStopped() bool // +------------------------------------------------------------+ // | 当前的 &quot;user/request&quot; 存储 | // | 处理方法之间共享信息 - Values(). | // | 保存并获取路径参数 - Params() | // +------------------------------------------------------------+ // Params 返回当前URL中的命名参数。命名的路径参数是被保存在这里的。 // 这个存储对象随着整个上下文，存活于每个请求声明周期。 Params() *RequestParams // Values 返回当前 「用户」的存储信息。 // 命名路径参数和任何可选数据可以保存在这里。 // 这个存储对象，也是存在于整个上下文，每个请求的声明周期中。 // // 你可以用这个函数设置和获取用于在处理方法和中间件之间共享信息的局部值。 Values() *memstore.Store // Translate 是 i18n 函数，用于本地化。它调用 Get(&quot;translate&quot;) 返回翻译值。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/miscellaneous/i18n Translate(format string, args ...interface&#123;&#125;) string // +------------------------------------------------------------+ // | 路径, 主机, 子域名, IP, HTTP 头 等 | // +------------------------------------------------------------+ // Method 返回 request.Method， 客户端的请求方法。 Method() string // Path 返回完整请求路径，如果 EnablePathEscape 为 True，将会转义。 Path() string // RequestPath 返回转义过的请求完整路径。 RequestPath(escape bool) string // Host 返回当前URL的主机部分。 Host() string // Subdomain 返回当前请求的子域名，如果有。 // 提醒，这个方法可能在某些情况下不能正常使用。 Subdomain() (subdomain string) // RemoteAddr 尝试解析并返回客户端正式IP。 // // 基于允许的头名称，可以通过 Configuration.RemoteAddrHeaders 修改。 // // 如果基于这些请求头的解析失败，将会 Request 的 `RemoteAddr` 字段，它在 Http 处理方法之前有 server 填充。 // // 查看 `Configuration.RemoteAddrHeaders`, // `Configuration.WithRemoteAddrHeader(...)`, // `Configuration.WithoutRemoteAddrHeader(...)` 获取更多信息。 RemoteAddr() string // GetHeader 返回指定的请求头值。 GetHeader(name string) string // IsAjax 返回这个请求是否是一个 &#x27;ajax request&#x27;( XMLHttpRequest)。 // // 不能百分之百确定一个请求是否是Ajax模式。 // 永远不要信任来自客户端的数据，他们很容易被篡改。 // // 提醒，&quot;X-Requested-With&quot; 头可以被任何客户端修改，对于十分严重的情况，不要依赖于 IsAjax。 // 试试另外的鉴别方式，例如，内容类型（content-type）。 // 有很多描述这些问题的博客并且提供了很多不同的解决方案，这就是为什么说 `IsAjax` // 太简单，只能用于一般目的。 // // 更多请看： https://developer.mozilla.org/en-US/docs/AJAX // 以及： https://xhr.spec.whatwg.org/ IsAjax() bool // +------------------------------------------------------------+ // | 响应头助手 | // +------------------------------------------------------------+ // Header 添加响应头到响应 writer。 Header(name string, value string) // ContentType 设置响应头 &quot;Content-Type&quot; 为 &#x27;cType&#x27;。 ContentType(cType string) // GetContentType 返回响应头 &quot;Content-Type&quot; 的值。 GetContentType() string // StatusCode 设置响应状态码。 // 也可查看 .GetStatusCode。 StatusCode(statusCode int) // GetStatusCode 返回当前响应的状态码。 // 也可查阅 StatusCode。 GetStatusCode() int // Redirect 发送一个重定向响应到客户端，接受两个参数，字符串和可选的证书。 // 第一个参数是重定向的URL，第二个是重定向状态码，默认是302。 // 如果必要，你可以设置为301，代表永久转义。 Redirect(urlToRedirect string, statusHeader ...int) // +------------------------------------------------------------+ // | 各种请求和 POST 数据 | // +------------------------------------------------------------+ // URLParam 返回请求中的参数，如果有。 URLParam(name string) string // URLParamInt 从请求返回 int 类型的URL参数，如果解析失败，返回错误。 URLParamInt(name string) (int, error) // URLParamInt64 从请求返回 int64 类型的参数，如果解析失败，返回错误。 URLParamInt64(name string) (int64, error) // URLParams 返回请求查询参数映射，如果没有，返回为空。 URLParams() map[string]string // FormValue 返回一个表单值。 FormValue(name string) string // FormValues 从 data，get，post 和 查询参数中返回所有的数据值以及他们的键。 // // 提醒: 检查是否是 nil 是很有必要的。 FormValues() map[string][]string // PostValue 仅仅根据名称返回表单的post值，类似于 Request.PostFormValue。 PostValue(name string) string // FormFile 返回键指定的第一个文件。 // 如果有必要，FormFile 调用 ctx.Request.ParseMultipartForm 和 ParseForm。 // // 类似于 Request.FormFile. FormFile(key string) (multipart.File, *multipart.FileHeader, error) // +------------------------------------------------------------+ // | 自定义 HTTP 错误 | // +------------------------------------------------------------+ // NotFound 发送一个 404 错误到客户端，使用自定义的错误处理方法。 // 如果你不想剩下的处理方法被执行，你可能需要去调用 ctx.StopExecution()。 // 你可以将错误码改成更具体的，例如： // users := app.Party(&quot;/users&quot;) // users.Done(func(ctx context.Context)&#123; if ctx.StatusCode() == 400 &#123; /* custom error code for /users */ &#125;&#125;) NotFound() // +------------------------------------------------------------+ // | Body Readers | // +------------------------------------------------------------+ // SetMaxRequestBodySize 设置请求体大小的上限，应该在读取请求体之前调用。 SetMaxRequestBodySize(limitOverBytes int64) // UnmarshalBody 读取请求体，并把它绑定到一个任何类型或者指针的值。 // 使用实例: context.ReadJSON, context.ReadXML。 UnmarshalBody(v interface&#123;&#125;, unmarshaler Unmarshaler) error // ReadJSON 从请求体读取 JSON，并把它绑定到任何json有效类型的值。 ReadJSON(jsonObject interface&#123;&#125;) error // ReadXML 从请求体读取 XML，并把它绑定到任何xml有效类型的值。 ReadXML(xmlObject interface&#123;&#125;) error // ReadForm 是用表单数据绑定 formObject，支持任何类型的结构体。 ReadForm(formObject interface&#123;&#125;) error // +------------------------------------------------------------+ // | Body (raw) Writers | // +------------------------------------------------------------+ // Write 将数据作为一个HTTP响应的一部分写入连接。 // // 如果 WriteHeader 还没有调用，Write 将在 写入数据之前调用 WriteHeader(http.StatusOK)。 // 如果 Header 没有 Content-Type，Write 添加一个 Content-Type，设置为写入数据的前 // 512 字节的类型。 // // 取决于 HTTP 版本和客户端，调用 Write 或者 WriteHeader 可能组织以后读取 Request.Body。 // 对于 HTTP/1.x 请求，处理方法应该在写入响应之前读取所有必要的请求体数据。一旦 HTTP 头被清掉 // (显示调用 Flusher.Flush 或者写入了足够的数据触发了清空操作)，请求体可能变得不可用。 // 对于 HTTP/2 请求，Go HTTP 服务器允许在写入响应的同时读取请求体。然而，这种行为可能不被所有 // HTTP/2 客户端支持。处理方法应该尽可能读取最大量的数据在写入之前。 Write(body []byte) (int, error) // Writef 根据格式声明器格式化，然后写入响应。 // // 返回写入的字节数量以及任何写入错误。 Writef(format string, args ...interface&#123;&#125;) (int, error) // WriteString 将一个简单的字符串写入响应。 // // 返回写入的字节数量以及任何写入错误。 WriteString(body string) (int, error) // WriteWithExpiration 很像 Write，但是它发送了一个失效时间，它会被每个包级别的 // `StaticCacheDuration` 字段刷新。 WriteWithExpiration(body []byte, modtime time.Time) (int, error) // StreamWriter 注册给定的流用于发布响应体。 // // 这个函数可能被用于一下这些情况： // // * 如果响应体太大（超过了iris.LimitRequestBodySize） // * 如果响应体是慢慢从外部资源流入 // * 如果响应体必须分片流向客户端（例如 `http server push`） StreamWriter(writer func(w io.Writer) bool) // +------------------------------------------------------------+ // | 带压缩的 Body Writers | // +------------------------------------------------------------+ // 如果客户端支持 gzip 压缩，ClientSupportsGzip 返回 true。 ClientSupportsGzip() bool // WriteGzip accepts bytes, which are compressed to gzip format and sent to the client. // WriteGzip 接受压缩成 gzip 格式的字节然后发送给客户端，并返回写入的字节数量和错误（如果错误不支持 gzip 格式） // // 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。 WriteGzip(b []byte) (int, error) // TryWriteGzip 接受 gzip 格式压缩的字节，然后发送给客户端。 // 如果客户端不支持 gzip，就按照他们原来未压缩的样子写入。 // // 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。 TryWriteGzip(b []byte) (int, error) // GzipResponseWriter converts the current response writer into a response writer // GzipResponseWriter 将当前的响应 writer 转化为一个 gzip 响应 writer。 // 当它的 .Write 方法被调用的时候，数据被压缩成 gzip 格式然后把他们写入客户端。 // // 也可以使用 .Disable 禁用以及使用 .ResetBody 回滚到常规的响应写入器。 GzipResponseWriter() *GzipResponseWriter // Gzip 开启或者禁用 gzip 响应写入器，如果客户端支持 gzip 压缩，所以接下来的响应数据将被作为 // 压缩的 gzip 数据发送给客户端。 Gzip(enable bool) // +------------------------------------------------------------+ // | 富文本内容渲染器 | // +------------------------------------------------------------+ // ViewLayout 设置 「布局」选项，如果随后在相同的请求中 .View 被调用。 // 当需要去改变或者设置处理链中前一个方法的布局时很有用。 // // 注意 &#x27;layoutTmplFile&#x27; 参数可以被设置为 iris.NoLayout 或者 view.NoLayout 去禁用某个试图渲染动作的布局。 // 它禁用了配置项的布局属性。 // // 也可查看 .ViewData 和 .View。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/ ViewLayout(layoutTmplFile string) // ViewData 保存一个或者多个键值对为了在后续的 .View 被调用的时候使用。 // 当需要处理链中前一个处理器的模板数据的时候是很有用的。 // // 如果 .View 的绑定参数不是 nil 也不是 map 类型，这些数据就会被忽略，绑定是有优先级的，所以住路由的处理方法仍然有效。 // 如果绑定是一个map或者context.Map，这些数据然后就被添加到视图数据然后传递给模板。 // // .View 调用之后，这些数据不会被丢掉，为了在必要的时候重用（再次声明，同一个请求中），为了清除这些数据，开发者可以调用 // ctx.Set(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey(), nil)。 // // 如果 &#x27;key&#x27; 是空的，然后 值被作为它的（struct 或者 map）添加，并且开发者不能添加其他值。 // // 推荐查看 .ViewLayout 和 .View。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/ ViewData(key string, value interface&#123;&#125;) // GetViewData 返回 `context#ViewData` 注册的值。 // 返回值是 `map[string]interface&#123;&#125;` 类型，这意味着如果一个自定义的结构体被添加到 ViewData， 这个函数将把它解析成 // map，如果失败返回 nil。 // 如果不同类型的值或者没有数据通过 `ViewData` 注册，检查是否为nil总是好的编程规范。 // // 类似于 `viewData := ctx.Values().Get(&quot;iris.viewData&quot;)` 或者 // `viewData := ctx.Values().Get(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey())`。 GetViewData() map[string]interface&#123;&#125; // View 基于适配的视图引擎渲染模板。第一个参数是接受相对于视图引擎目录的文件名， // 例如如果目录是 &quot;./templates&quot;，想要渲染： &quot;./templates/users/index.html&quot; // 你应该传递 &quot;users/index.html&quot; 作为文件名参数。 // 也可以查看 .ViewData 和 .ViewLayout。 // 示例：https://github.com/kataras/iris/tree/master/_examples/view/ View(filename string) error // Binary 将原生字节作为二进制数据返回。 Binary(data []byte) (int, error) // Text 将字符串作为空白文本返回。 Text(text string) (int, error) // HTML 将字符串作为 text/html 返回. HTML(htmlContents string) (int, error) // JSON 格式化给定的数据并且返回 json 数据。 JSON(v interface&#123;&#125;, options ...JSON) (int, error) // JSONP 格式化给定的数据并且返回 json 数据。 JSONP(v interface&#123;&#125;, options ...JSONP) (int, error) // XML 格式话给定数据，并返回 XML 数据。 XML(v interface&#123;&#125;, options ...XML) (int, error) // Markdown 解析 markdown 数据为 HTML 返回给客户端。 Markdown(markdownB []byte, options ...Markdown) (int, error) // +------------------------------------------------------------+ // | 文件响应 | // +------------------------------------------------------------+ // ServeContent 返回的内容头是自动设置的，接受三个参数，它是一个低级的函数，你可以调用 .ServeFile(string,bool)/SendFile(string,string)。 // 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，不要实现 resuming，而应该使用 ctx.SendFile。 ServeContent(content io.ReadSeeker, filename string, modtime time.Time, gzipCompression bool) error // ServeFile 渲染一个视图文件，如果要发送一个文件（例如zip文件）到客户端，你应该使用 SendFile(serverfilename,clientfilename)。 // 接受两个参数： // filename/path (string) // gzipCompression (bool) // 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，这个函数没有实现 resuming，你应该使用 ctx.SendFile。 ServeFile(filename string, gzipCompression bool) error // SendFile 发送强制下载的文件到客户端 // // 使用这个而不是 ServeFile 用于大文件下载到客户端。 SendFile(filename string, destinationName string) error // +------------------------------------------------------------+ // | Cookies | // +------------------------------------------------------------+ // SetCookie 添加cookie SetCookie(cookie *http.Cookie) // SetCookieKV 添加一个 cookie，仅仅接受一个名字（字符串）和一个值（字符串） // // 如果你用这个方法设置cookie，它将在两小时之后失效。 // 如果你想去设置或者改变更多字段，使用 ctx.SetCookie 或者 http.SetCookie。 SetCookieKV(name, value string) // GetCookie 通过名称返回值，如果没找到返回空字符串。 GetCookie(name string) string // RemoveCookie 通过名字删除 cookie。 RemoveCookie(name string) // VisitAllCookies 接受一个 visitor 循环每个cookie，visitor 接受两个参数：名称和值。 VisitAllCookies(visitor func(name string, value string)) // MaxAge 返回 &quot;cache-control&quot; 请求头的值，单位为：秒，类型为 int64 // 如果头没有发现或者解析失败返回 -1。 MaxAge() int64 // +------------------------------------------------------------+ // | 高级部分: 响应记录器和事务 | // +------------------------------------------------------------+ // Record 转化上下文基本的 responseWriter 为 ResponseRecorder，它可以被用于在任何时候重置内容体， // 重置响应头，获取内容体，获取和设置状态码。 Record() // Recorder 返回上下文的 ResponseRecorder，如果没有 recording 然后它将开始记录并返回新的上下文的 ResponseRecorder。 Recorder() *ResponseRecorder // IsRecording 返回响应记录器以及一个bool值 // true 表示响应记录器正在记录状态码，内容体，HTTP 头以及更多，否则就是 false IsRecording() (*ResponseRecorder, bool) // BeginTransaction 开启一个有界事务。 // // 你可以搜索第三方文章或者查看事务 Transaction 如何工作（这里相当简单特别）。 // // 记着这个是唯一的，也是新的，目前为止，我没有在这个项目中看到任何例子和代码，就大多数 iris 功能而言。 // 它没有覆盖所有路径，例如数据库，这个应该由你使用的创建数据库连接的库管理，这个事务域仅仅用于上下文响应， // // 阅读 https://github.com/kataras/iris/tree/master/_examples/ 查看更多。 BeginTransaction(pipe func(t *Transaction)) // 如果调用 SkipTransactions 将跳过剩余的事务，或者如果在第一个事务之前调用，将跳过所有 SkipTransactions() // TransactionsSkipped 返回事务到底被跳过还是被取消了。 TransactionsSkipped() bool // Exec根据这个上下文调用framewrok的ServeCtx，但是改变了方法和路径，就像用户请求的那样，但事实并非如此。 // // 离线意味着路线已注册到 iris 并具有正常路由所具有的所有功能。 // 但是它不能通过浏览获得，它的处理程序仅在其他处理程序的上下文调用它们时执行，它可以验证路径，拥有会话，路径参数等。 // // 你可以通过 app.GetRoute(&quot;theRouteName&quot;) 找到路由，你可以设置一个路由名称如： // myRoute := app.Get(&quot;/mypath&quot;, handler)(&quot;theRouteName&quot;) // 这个将给路由设置一个名称并且返回它的 RouteInfo 实例为了进一步使用。 // // 它不会更改全局状态，如果路由处于“脱机”状态，它将保持脱机状态。 // // app.None(...) and app.GetRoutes().Offline(route)/.Online(route, method) // // 实例：https://github.com/kataras/iris/tree/master/_examples/routing/route-state // // 用户可以通过简单调用得到响应：rec := ctx.Recorder(); rec.Body()/rec.StatusCode()/rec.Header() // // Context 的 Values 和 Session 被记住为了能够通过结果路由通信， // // 它仅仅由于特别案例，99% 的用户不会用到的。 Exec(method string, path string) // Application 返回 属于这个上下文的 iris 实例。 // 值得留意的是这个函数返回 Application 的一个接口，它包含的方法能够安全地在运行是执行。 // 为了开发者的安全性，整个 app 的 字段和方法这里是不可用的。 Application() Application 动态路由参数","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"go:并发","slug":"go-并发","date":"2023-04-07T10:59:37.000Z","updated":"2023-04-08T01:39:44.562Z","comments":true,"path":"2023/04/07/go-并发/","link":"","permalink":"https://www.napleon.cn/2023/04/07/go-%E5%B9%B6%E5%8F%91/","excerpt":"Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。","text":"Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。 123456789101112131415161718package main import ( &quot;fmt&quot; &quot;time&quot;)func say(s string) &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(s) &#125;&#125;func main () &#123; go say(&quot;world&quot;) say(&quot;hello&quot;)&#125;// 该代码的运行结果不唯一，因为是两个goroutine在执行 通道通道是用来传递数据的数据结构 通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于制定通道的方向，如果未指定方向，则为双向通道。 12345ch &lt;- v // 把v发送到chv := &lt;-ch // 从ch接收数据 // 并把值赋给v// 声明一个通道ch := make(chan int) 默认情况下，通道是不带缓冲区的。 带缓冲区的通道通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小： 1ch := make(chan int, 100) 如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 Go通过range关键字来实现遍历读取到的数据，格式如下： 1v, ok := &lt;- ch 关闭通道如果通道接收不到数据后ok就为false，这时通道就可以使用close函数来关闭。 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot;)func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x + y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"go:方法与接口","slug":"go-方法与接口","date":"2023-04-05T02:31:55.000Z","updated":"2023-04-07T10:55:43.215Z","comments":true,"path":"2023/04/05/go-方法与接口/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/","excerpt":"7.1 接口的定义Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 12345type iface struct &#123; tab *itab; data unsafe.Pointer &#125;","text":"7.1 接口的定义Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 12345type iface struct &#123; tab *itab; data unsafe.Pointer &#125; 7.2 接口使用实例12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)type Phone interface &#123; // 定义了一个接口Phone, 有方法call() call()&#125;type NokiaPhone struct &#123; // 接口Phone的一个实现&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123; // 接口Phone的一个实现&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone // 利用接口实现多态 phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; ​","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"go:数据","slug":"go-数据","date":"2023-04-05T01:26:17.000Z","updated":"2023-04-07T10:56:23.369Z","comments":true,"path":"2023/04/05/go-数据/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%95%B0%E6%8D%AE/","excerpt":"5.1 字符串string字符串是不可变字符序列 默认值为空串，而不是空指针。 遍历 12345678910111213func main() &#123; s := &#x27;Hello, world&#x27; // byte for i := 0; i &lt; len(s); i++ &#123; println(&quot;%d: [%c]\\n&quot;, i, s[i]); &#125; // rune for i, c := range s &#123; println(&quot;%d ,[%c]\\n&quot;, i, c); &#125;&#125;","text":"5.1 字符串string字符串是不可变字符序列 默认值为空串，而不是空指针。 遍历 12345678910111213func main() &#123; s := &#x27;Hello, world&#x27; // byte for i := 0; i &lt; len(s); i++ &#123; println(&quot;%d: [%c]\\n&quot;, i, s[i]); &#125; // rune for i, c := range s &#123; println(&quot;%d ,[%c]\\n&quot;, i, c); &#125;&#125; 5.2 数组5.2.1 数组的初始化1234567891011func main() &#123; var a [4]int // 元素自动初始成0 b := [4]int&#123;2, 5&#125; // 剩余元素自动初始化成0 c := [4]int&#123;5, 3:10&#125;; // 指定索引位置 d := [...]int&#123;1, 2, 3&#125; // 编译器确定数组长度 // 在定义多维数组时， 仅第一维允许使用... b := [...][2]int &#123; &#123;10, 20&#125;, &#123;30 ,40&#125;, &#125;&#125; 5.2.2 指针12345func main() &#123; x, y := 10 ,20 a := [...]*int&#123;&amp;x, &amp;y&#125; // 指针数组 p = &amp;a // 数组指针&#125; 5.2.3 复制与C数组变量隐式作为指针使用不同， Go数组是值类型，赋值和传参工作都会复制整个数组数据 5.3 切片slice本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。 123456// 数据结构type slice strcut &#123; arrary unsafe.Pointer len int // 限定可读的写元素数量 cap int // 切片所引用数组片段的真实长度&#125; 切片本身是一个只读对象， 其工作机制类似数组指针的一种包装 5.3.1 创建切片对象1234func main() &#123; s1 := make([]int, 3, 5) //指定len, cap, 底层数组初始化成零值 s2 := make([int], 3) // 省略cap, 和len相等&#125; 切片是包装过的数组对象，用来代替数组减少值传递带来的开销 5.4 字典基本操作12345678910func main() &#123; m := map[string]int &#123; &quot;a&quot;: 1, &quot;b&quot;: 2, &#125; // 判断key是否存在 if v, ok := m[&quot;d&quot;]; ok &#123; println(v) &#125; // 访问不存在的键值， 默认返回零值&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"vim杂谈","slug":"vim杂谈","date":"2023-04-02T14:25:14.000Z","updated":"2023-04-03T02:56:29.643Z","comments":true,"path":"2023/04/02/vim杂谈/","link":"","permalink":"https://www.napleon.cn/2023/04/02/vim%E6%9D%82%E8%B0%88/","excerpt":"vim是Linux环境下的一款重要的文本编辑器。","text":"vim是Linux环境下的一款重要的文本编辑器。 1. 基本使用1.1 三种基本模式 一般模式 编辑模式 命令行模式 1.2 按键一般模式(hjkl)对应(左下上右) “30j” &#x3D; 向下移动三十行 C+f 屏幕向下移动一页 C+b 屏幕向上移动一页 “+” 光标移动到非空格行的下一行 “-“ 光标移动到非空格行的上一行 n 光标向后移动20个字符的距离 n[Enter] 光标向下移动n行 G 移动到这个文件的最后一行 &#x2F;word 向下寻找名为word的字符串 dd 删除光标所在的一整行 yy 复制一整行 x [delete] X[backsapce] u 复原前一个操作 C+r 重做上一个操作 . 重复前一个操作","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"}]},{"title":"9.虚拟内存","slug":"9-虚拟内存","date":"2023-03-29T07:26:42.000Z","updated":"2023-04-03T14:50:54.368Z","comments":true,"path":"2023/03/29/9-虚拟内存/","link":"","permalink":"https://www.napleon.cn/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","excerpt":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。","text":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。 9.1 物理和虚拟寻址CPU—(VA)–&gt;MMU—-&gt;PA—–&gt;Memory","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"}],"tags":[]},{"title":"8.异常控制流","slug":"8-异常控制流","date":"2023-03-29T03:17:27.000Z","updated":"2023-03-30T13:19:23.051Z","comments":true,"path":"2023/03/29/8-异常控制流/","link":"","permalink":"https://www.napleon.cn/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"CSAPP关于异常处理的章节。","text":"CSAPP关于异常处理的章节。 8.4进程控制8.4.1 获取进程ID12345#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t getpid(void); //获取进程的pidpid_t getppid(void); // 获取进程父进程的pid 8.4.2 创建和终止进程12345678910#include &lt;stdlib.h&gt;/*exit函数以status退出状态来终止进程*/void exit(int status);/*父进程通过调用fork函数创建一个新的运行的子进程*/pid_t fork(void);// 返回值：子进程返回0，父进程返回子进程的PID，如果出错，返回-1. fork被调用一次，却会返回两次：父进程返回子进程的PID，子进程返回0. 12345678910111213141516171819int main() &#123; pid_t pid; int x = 1; pid = fork(); if (pid == 0) &#123; prinf(&quot;child: x = %d\\n&quot;, ++x); exit(0); &#125; prinf(&quot;parent: x = %d\\n&quot;, --x); exit(0);&#125;/*parent: x = 0child: x = 2or child: x = 2parent: x = 0*/ 8.4.3 回收子进程如果一个父进程终止，内核会安排init进程成为他的孤儿进程的养父 8.4.6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 一个简单的shell的main例程 *//*shellex.c*/#include &quot;csapp.h&quot;#define MAXARGS 128/* Function protoytpes */void eval(char* cmdline);int parseline(char* buf, char** argv);int builtin_command(char** argv);int main() &#123; char cmdline[MAXLINE]; // Command line while (1) &#123; /* Read */ printf(&quot;&gt; &quot;); Fgets(cmdline, MAXLINE, stdin); if (feof(stdin)) exit(0); /* Evaluate */ eval(cmdline); &#125;&#125;/* Evaluate a commmand line*/void eval(char* cmdline) &#123; char* argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; strcpy(buf, cmdline); bg = parseline(buf, argv); if (argv[0] == NULL) return ; // Ignore empty line if (!builtin_command(argv)) &#123; if ( (pid = Fork()) == 0 ) &#123; if (execve(argv[0], argv, environ) &lt; 0) &#123; printf(&quot;%s: Command not found.\\n&quot;, argv[0]); exit(0); &#125; &#125; // Parent waits for foreground job to terminate if (!bg) &#123; int status; if (waitpid(pid, &amp;status, 0) &lt; 0) unix_error(&quot;waitfg: waitpid error&quot;); &#125; else printf(&quot;%d %s&quot;, pid, cmdline); &#125; return ;&#125;/* If first arg is a builtin command, run it and return true*/int builtin_command(char** argv) &#123; if (!strcmp(argv[0], &quot;quit&quot;)) exit(0); if (!strcmp(argv[0], &quot;&amp;&quot;)) return 1; return 0;&#125;/* parseline - Parse the command line and build the argv array*/int parseline(char* buf, char** argv) &#123; char* delim; // points to the first space delimiter int argc; // number of args int bg; buf[strlen(buf) - 1] = &#x27; &#x27;; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf ++; /* build the argv list */ argc = 0; while ( (delm = strchr(buf, &#x27; &#x27;) ) ) &#123; argv[argc++] = buf; *delim = &#x27;\\0&#x27;; buf = delim + 1; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf++; &#125; argv[argc] = NULL; if (argc == 0) return 1; if ((bg = (*argv[argc - 1] == &#x27;&amp;&#x27;)) != 0) argv[--argc] = NULL; return bg;&#125; 8.5 信号Linux信号: 软件形式的异常 8.5.1 信号的术语发送信号到用户进程的步骤： 发送信号。 方式： 更新进程上下文的状态。 发送信号的原因： 1. 监测到异常、2进程调用了kill。 接收信号。进程接收信号并将信号转移给信号处理程序。 8.5.2 发送信号1. 进程组12345#include&lt;unistd.h&gt;pid getgrp(void); // 返回进程的进程组id// 子进程与父进程的进程组id默认相同int setpgid(pid_t pid, pid_t pgid); // 改变进程的进程组id 2. 用&#x2F;bin&#x2F;kill程序发送信号1234linux&gt; /bin/kill -9 15213// 发送信号SIGKILL给pid为15213的进程linux&gt; /bin/kill -9 -15213// 发送信号SIGKILL给pgid为15213下的所有进程 3.从键盘发送信号12Ctrl + C // 终止前台作业Ctrl + C // 挂起前台作业 4. 用kill函数发送信号1","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"}],"tags":[]},{"title":"教你如何给C盘扩容","slug":"教你如何给C盘扩容","date":"2022-06-30T06:36:42.000Z","updated":"2023-03-30T12:52:36.321Z","comments":true,"path":"2022/06/30/教你如何给C盘扩容/","link":"","permalink":"https://www.napleon.cn/2022/06/30/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99C%E7%9B%98%E6%89%A9%E5%AE%B9/","excerpt":"前言作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。","text":"前言作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。 磁盘的分区右击‘此电脑’，可以看到‘管理’，点开‘管理’。进入管理界面后，点击左侧的“磁盘管理”，即可进入电脑的磁盘页面。可以看到，我的电脑有两个磁盘，其中磁盘0未分区，磁盘1分为C、D两个分区。首先要压缩D盘，如果你有多个磁盘也可以压缩别的磁盘，但不建议这样做。因为磁盘的读取方式不一致可能会造成错误。右击分区D，选择压缩分区，并输入你要压缩的空间大小。压缩后，你可以看到现在有了未分配的空间。检查一下，可以发现，当前未分配的空间可以给D盘扩容，但却不能给C盘扩容。这是因为逻辑分区之间具有顺序关系。可以理解成当前未分配的空间只能给它前面的分区扩容，而不能给它不相邻的分区扩容。只使用系统的磁盘管理器是不能直接给C盘扩容的，除非先把数据拷贝好，然后将D盘格式化，再重新将1磁盘分区。这样过于麻烦，下面介绍一下利用软件给C盘扩容的方法。 使用DiskGenius实现无损扩容DiskGenius是一款免费的国产磁盘管理软件，它能够直接用未分区的逻辑分区给主分区扩容。前往DiskGenius的官网可直接下载。进入软件，选中C盘，点击上方的分区选项卡选择扩容分区。但现在还别着急，磁盘中可能有的簇未使用，却被标记成了已使用。为了解决这一问题，需要按Windows+x，选择‘Windows PowerShell’，进入管理员界面。在命令行中键入chkdsk /f /x c:,其中’c’代表盘符，建议对所有盘都扫描一遍，保证不出问题。回到刚才的步骤，现在选择未分配的空间，然后按照提示进行操作。然后选中‘重启’,等待软件进行操作，重启两次后，你的C盘就扩容成功了！ 总结网上的教程鱼龙混杂，大多是互相复制粘贴，好多操作都已经过时了，为了扩容C盘我花费了一下午，到处参考教程，不断的试错，最终写成了这篇博客，如果你觉得有用的话，可以分享给你的朋友哦。","categories":[{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}],"categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"},{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"},{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"},{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}