{"meta":{"title":"Napleon","subtitle":"Napleon的个人博客","description":"真正的慷慨，就是把一切都献给现在。","author":"napleon-liu","url":"https://www.napleon.cn","root":"/"},"pages":[{"title":"categories","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T02:46:26.935Z","comments":true,"path":"categories/index.html","permalink":"https://www.napleon.cn/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-03-29T07:23:32.000Z","updated":"2023-03-29T07:24:11.628Z","comments":true,"path":"about/index.html","permalink":"https://www.napleon.cn/about/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T09:02:18.622Z","comments":true,"path":"guestbook/index.html","permalink":"https://www.napleon.cn/guestbook/index.html","excerpt":"","text":"欢迎来到我的博客！ 欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的，添加email可以获得更快的回复速度，在nickname栏目输入QQ号可以直接获取你的QQ头像。"},{"title":"tags","date":"2023-03-29T02:48:59.000Z","updated":"2023-03-29T02:49:18.511Z","comments":true,"path":"tags/index.html","permalink":"https://www.napleon.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"go:方法与接口","slug":"go-方法与接口","date":"2023-04-05T02:31:55.000Z","updated":"2023-04-07T10:50:58.270Z","comments":true,"path":"2023/04/05/go-方法与接口/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"7.1 接口的定义Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 12345type iface struct &#123; tab *itab; data unsafe.Pointer &#125; 7.2 接口使用实例12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)type Phone interface &#123; // 定义了一个接口Phone, 有方法call() call()&#125;type NokiaPhone struct &#123; // 接口Phone的一个实现&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123; // 接口Phone的一个实现&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone // 利用接口实现多态 phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; ​","categories":[],"tags":[{"name":"go","slug":"go","permalink":"https://www.napleon.cn/tags/go/"}]},{"title":"go:数据","slug":"go-数据","date":"2023-04-05T01:26:17.000Z","updated":"2023-04-05T02:31:24.710Z","comments":true,"path":"2023/04/05/go-数据/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%95%B0%E6%8D%AE/","excerpt":"","text":"5.1 字符串string字符串是不可变字符序列 默认值为空串，而不是空指针。 遍历 12345678910111213func main() &#123; s := &#x27;Hello, world&#x27; // byte for i := 0; i &lt; len(s); i++ &#123; println(&quot;%d: [%c]\\n&quot;, i, s[i]); &#125; // rune for i, c := range s &#123; println(&quot;%d ,[%c]\\n&quot;, i, c); &#125;&#125; 5.2 数组5.2.1 数组的初始化1234567891011func main() &#123; var a [4]int // 元素自动初始成0 b := [4]int&#123;2, 5&#125; // 剩余元素自动初始化成0 c := [4]int&#123;5, 3:10&#125;; // 指定索引位置 d := [...]int&#123;1, 2, 3&#125; // 编译器确定数组长度 // 在定义多维数组时， 仅第一维允许使用... b := [...][2]int &#123; &#123;10, 20&#125;, &#123;30 ,40&#125;, &#125;&#125; 5.2.2 指针12345func main() &#123; x, y := 10 ,20 a := [...]*int&#123;&amp;x, &amp;y&#125; // 指针数组 p = &amp;a // 数组指针&#125; 5.2.3 复制与C数组变量隐式作为指针使用不同， Go数组是值类型，赋值和传参工作都会复制整个数组数据 5.3 切片slice本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。 123456// 数据结构type slice strcut &#123; arrary unsafe.Pointer len int // 限定可读的写元素数量 cap int // 切片所引用数组片段的真实长度&#125; 切片本身是一个只读对象， 其工作机制类似数组指针的一种包装 5.3.1 创建切片对象1234func main() &#123; s1 := make([]int, 3, 5) //指定len, cap, 底层数组初始化成零值 s2 := make([int], 3) // 省略cap, 和len相等&#125; 切片是包装过的数组对象，用来代替数组减少值传递带来的开销 5.4 字典基本操作12345678910func main() &#123; m := map[string]int &#123; &quot;a&quot;: 1, &quot;b&quot;: 2, &#125; // 判断key是否存在 if v, ok := m[&quot;d&quot;]; ok &#123; println(v) &#125; // 访问不存在的键值， 默认返回零值&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"vim杂谈","slug":"vim杂谈","date":"2023-04-02T14:25:14.000Z","updated":"2023-04-03T02:56:29.643Z","comments":true,"path":"2023/04/02/vim杂谈/","link":"","permalink":"https://www.napleon.cn/2023/04/02/vim%E6%9D%82%E8%B0%88/","excerpt":"vim是Linux环境下的一款重要的文本编辑器。","text":"vim是Linux环境下的一款重要的文本编辑器。 1. 基本使用1.1 三种基本模式 一般模式 编辑模式 命令行模式 1.2 按键一般模式(hjkl)对应(左下上右) “30j” &#x3D; 向下移动三十行 C+f 屏幕向下移动一页 C+b 屏幕向上移动一页 “+” 光标移动到非空格行的下一行 “-“ 光标移动到非空格行的上一行 n 光标向后移动20个字符的距离 n[Enter] 光标向下移动n行 G 移动到这个文件的最后一行 &#x2F;word 向下寻找名为word的字符串 dd 删除光标所在的一整行 yy 复制一整行 x [delete] X[backsapce] u 复原前一个操作 C+r 重做上一个操作 . 重复前一个操作","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"}]},{"title":"9.虚拟内存","slug":"9-虚拟内存","date":"2023-03-29T07:26:42.000Z","updated":"2023-03-30T13:42:49.282Z","comments":true,"path":"2023/03/29/9-虚拟内存/","link":"","permalink":"https://www.napleon.cn/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","excerpt":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。","text":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。 9.1 物理和虚拟寻址CPU—(VA)–&gt;MMU—-&gt;PA—–&gt;Memory","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"}],"tags":[]},{"title":"8.异常控制流","slug":"8-异常控制流","date":"2023-03-29T03:17:27.000Z","updated":"2023-03-30T13:19:23.051Z","comments":true,"path":"2023/03/29/8-异常控制流/","link":"","permalink":"https://www.napleon.cn/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"CSAPP关于异常处理的章节。","text":"CSAPP关于异常处理的章节。 8.4进程控制8.4.1 获取进程ID12345#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t getpid(void); //获取进程的pidpid_t getppid(void); // 获取进程父进程的pid 8.4.2 创建和终止进程12345678910#include &lt;stdlib.h&gt;/*exit函数以status退出状态来终止进程*/void exit(int status);/*父进程通过调用fork函数创建一个新的运行的子进程*/pid_t fork(void);// 返回值：子进程返回0，父进程返回子进程的PID，如果出错，返回-1. fork被调用一次，却会返回两次：父进程返回子进程的PID，子进程返回0. 12345678910111213141516171819int main() &#123; pid_t pid; int x = 1; pid = fork(); if (pid == 0) &#123; prinf(&quot;child: x = %d\\n&quot;, ++x); exit(0); &#125; prinf(&quot;parent: x = %d\\n&quot;, --x); exit(0);&#125;/*parent: x = 0child: x = 2or child: x = 2parent: x = 0*/ 8.4.3 回收子进程如果一个父进程终止，内核会安排init进程成为他的孤儿进程的养父 8.4.6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 一个简单的shell的main例程 *//*shellex.c*/#include &quot;csapp.h&quot;#define MAXARGS 128/* Function protoytpes */void eval(char* cmdline);int parseline(char* buf, char** argv);int builtin_command(char** argv);int main() &#123; char cmdline[MAXLINE]; // Command line while (1) &#123; /* Read */ printf(&quot;&gt; &quot;); Fgets(cmdline, MAXLINE, stdin); if (feof(stdin)) exit(0); /* Evaluate */ eval(cmdline); &#125;&#125;/* Evaluate a commmand line*/void eval(char* cmdline) &#123; char* argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; strcpy(buf, cmdline); bg = parseline(buf, argv); if (argv[0] == NULL) return ; // Ignore empty line if (!builtin_command(argv)) &#123; if ( (pid = Fork()) == 0 ) &#123; if (execve(argv[0], argv, environ) &lt; 0) &#123; printf(&quot;%s: Command not found.\\n&quot;, argv[0]); exit(0); &#125; &#125; // Parent waits for foreground job to terminate if (!bg) &#123; int status; if (waitpid(pid, &amp;status, 0) &lt; 0) unix_error(&quot;waitfg: waitpid error&quot;); &#125; else printf(&quot;%d %s&quot;, pid, cmdline); &#125; return ;&#125;/* If first arg is a builtin command, run it and return true*/int builtin_command(char** argv) &#123; if (!strcmp(argv[0], &quot;quit&quot;)) exit(0); if (!strcmp(argv[0], &quot;&amp;&quot;)) return 1; return 0;&#125;/* parseline - Parse the command line and build the argv array*/int parseline(char* buf, char** argv) &#123; char* delim; // points to the first space delimiter int argc; // number of args int bg; buf[strlen(buf) - 1] = &#x27; &#x27;; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf ++; /* build the argv list */ argc = 0; while ( (delm = strchr(buf, &#x27; &#x27;) ) ) &#123; argv[argc++] = buf; *delim = &#x27;\\0&#x27;; buf = delim + 1; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf++; &#125; argv[argc] = NULL; if (argc == 0) return 1; if ((bg = (*argv[argc - 1] == &#x27;&amp;&#x27;)) != 0) argv[--argc] = NULL; return bg;&#125; 8.5 信号Linux信号: 软件形式的异常 8.5.1 信号的术语发送信号到用户进程的步骤： 发送信号。 方式： 更新进程上下文的状态。 发送信号的原因： 1. 监测到异常、2进程调用了kill。 接收信号。进程接收信号并将信号转移给信号处理程序。 8.5.2 发送信号1. 进程组12345#include&lt;unistd.h&gt;pid getgrp(void); // 返回进程的进程组id// 子进程与父进程的进程组id默认相同int setpgid(pid_t pid, pid_t pgid); // 改变进程的进程组id 2. 用&#x2F;bin&#x2F;kill程序发送信号1234linux&gt; /bin/kill -9 15213// 发送信号SIGKILL给pid为15213的进程linux&gt; /bin/kill -9 -15213// 发送信号SIGKILL给pgid为15213下的所有进程 3.从键盘发送信号12Ctrl + C // 终止前台作业Ctrl + C // 挂起前台作业 4. 用kill函数发送信号1","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"}],"tags":[]},{"title":"教你如何给C盘扩容","slug":"教你如何给C盘扩容","date":"2022-06-30T06:36:42.000Z","updated":"2023-03-30T12:52:36.321Z","comments":true,"path":"2022/06/30/教你如何给C盘扩容/","link":"","permalink":"https://www.napleon.cn/2022/06/30/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99C%E7%9B%98%E6%89%A9%E5%AE%B9/","excerpt":"前言作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。","text":"前言作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。 磁盘的分区右击‘此电脑’，可以看到‘管理’，点开‘管理’。进入管理界面后，点击左侧的“磁盘管理”，即可进入电脑的磁盘页面。可以看到，我的电脑有两个磁盘，其中磁盘0未分区，磁盘1分为C、D两个分区。首先要压缩D盘，如果你有多个磁盘也可以压缩别的磁盘，但不建议这样做。因为磁盘的读取方式不一致可能会造成错误。右击分区D，选择压缩分区，并输入你要压缩的空间大小。压缩后，你可以看到现在有了未分配的空间。检查一下，可以发现，当前未分配的空间可以给D盘扩容，但却不能给C盘扩容。这是因为逻辑分区之间具有顺序关系。可以理解成当前未分配的空间只能给它前面的分区扩容，而不能给它不相邻的分区扩容。只使用系统的磁盘管理器是不能直接给C盘扩容的，除非先把数据拷贝好，然后将D盘格式化，再重新将1磁盘分区。这样过于麻烦，下面介绍一下利用软件给C盘扩容的方法。 使用DiskGenius实现无损扩容DiskGenius是一款免费的国产磁盘管理软件，它能够直接用未分区的逻辑分区给主分区扩容。前往DiskGenius的官网可直接下载。进入软件，选中C盘，点击上方的分区选项卡选择扩容分区。但现在还别着急，磁盘中可能有的簇未使用，却被标记成了已使用。为了解决这一问题，需要按Windows+x，选择‘Windows PowerShell’，进入管理员界面。在命令行中键入chkdsk /f /x c:,其中’c’代表盘符，建议对所有盘都扫描一遍，保证不出问题。回到刚才的步骤，现在选择未分配的空间，然后按照提示进行操作。然后选中‘重启’,等待软件进行操作，重启两次后，你的C盘就扩容成功了！ 总结网上的教程鱼龙混杂，大多是互相复制粘贴，好多操作都已经过时了，为了扩容C盘我花费了一下午，到处参考教程，不断的试错，最终写成了这篇博客，如果你觉得有用的话，可以分享给你的朋友哦。","categories":[{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}],"categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"},{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"go","slug":"go","permalink":"https://www.napleon.cn/tags/go/"},{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"},{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"},{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}