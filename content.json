{"meta":{"title":"Napleon","subtitle":"Napleon的个人博客","description":"真正的慷慨，就是把一切都献给现在。","author":"napleon-liu","url":"https://www.napleon.cn","root":"/"},"pages":[{"title":"categories","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T02:46:26.935Z","comments":true,"path":"categories/index.html","permalink":"https://www.napleon.cn/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-29T08:15:06.000Z","updated":"2023-03-29T08:15:06.906Z","comments":true,"path":"guestbook/index.html","permalink":"https://www.napleon.cn/guestbook/index.html","excerpt":"","text":""},{"title":"about","date":"2023-03-29T07:23:32.000Z","updated":"2023-03-29T07:24:11.628Z","comments":true,"path":"about/index.html","permalink":"https://www.napleon.cn/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-29T02:48:59.000Z","updated":"2023-03-29T02:49:18.511Z","comments":true,"path":"tags/index.html","permalink":"https://www.napleon.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"9.虚拟内存","slug":"9-虚拟内存","date":"2023-03-29T07:26:42.000Z","updated":"2023-03-29T07:26:42.420Z","comments":true,"path":"2023/03/29/9-虚拟内存/","link":"","permalink":"https://www.napleon.cn/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"8.异常控制流","slug":"8-异常控制流","date":"2023-03-29T03:17:27.000Z","updated":"2023-03-29T07:21:24.402Z","comments":true,"path":"2023/03/29/8-异常控制流/","link":"","permalink":"https://www.napleon.cn/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"","text":"8.4进程控制8.4.1 获取进程ID12345#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t getpid(void); //获取进程的pidpid_t getppid(void); // 获取进程父进程的pid 8.4.2 创建和终止进程12345678910#include &lt;stdlib.h&gt;/*exit函数以status退出状态来终止进程*/void exit(int status);/*父进程通过调用fork函数创建一个新的运行的子进程*/pid_t fork(void);// 返回值：子进程返回0，父进程返回子进程的PID，如果出错，返回-1. fork被调用一次，却会返回两次：父进程返回子进程的PID，子进程返回0. 12345678910111213141516171819int main() &#123; pid_t pid; int x = 1; pid = fork(); if (pid == 0) &#123; prinf(&quot;child: x = %d\\n&quot;, ++x); exit(0); &#125; prinf(&quot;parent: x = %d\\n&quot;, --x); exit(0);&#125;/*parent: x = 0child: x = 2or child: x = 2parent: x = 0*/ 8.4.3 回收子进程如果一个父进程终止，内核会安排init进程成为他的孤儿进程的养父 8.4.6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 一个简单的shell的main例程 *//*shellex.c*/#include &quot;csapp.h&quot;#define MAXARGS 128/* Function protoytpes */void eval(char* cmdline);int parseline(char* buf, char** argv);int builtin_command(char** argv);int main() &#123; char cmdline[MAXLINE]; // Command line while (1) &#123; /* Read */ printf(&quot;&gt; &quot;); Fgets(cmdline, MAXLINE, stdin); if (feof(stdin)) exit(0); /* Evaluate */ eval(cmdline); &#125;&#125;/* Evaluate a commmand line*/void eval(char* cmdline) &#123; char* argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; strcpy(buf, cmdline); bg = parseline(buf, argv); if (argv[0] == NULL) return ; // Ignore empty line if (!builtin_command(argv)) &#123; if ( (pid = Fork()) == 0 ) &#123; if (execve(argv[0], argv, environ) &lt; 0) &#123; printf(&quot;%s: Command not found.\\n&quot;, argv[0]); exit(0); &#125; &#125; // Parent waits for foreground job to terminate if (!bg) &#123; int status; if (waitpid(pid, &amp;status, 0) &lt; 0) unix_error(&quot;waitfg: waitpid error&quot;); &#125; else printf(&quot;%d %s&quot;, pid, cmdline); &#125; return ;&#125;/* If first arg is a builtin command, run it and return true*/int builtin_command(char** argv) &#123; if (!strcmp(argv[0], &quot;quit&quot;)) exit(0); if (!strcmp(argv[0], &quot;&amp;&quot;)) return 1; return 0;&#125;/* parseline - Parse the command line and build the argv array*/int parseline(char* buf, char** argv) &#123; char* delim; // points to the first space delimiter int argc; // number of args int bg; buf[strlen(buf) - 1] = &#x27; &#x27;; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf ++; /* build the argv list */ argc = 0; while ( (delm = strchr(buf, &#x27; &#x27;) ) ) &#123; argv[argc++] = buf; *delim = &#x27;\\0&#x27;; buf = delim + 1; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf++; &#125; argv[argc] = NULL; if (argc == 0) return 1; if ((bg = (*argv[argc - 1] == &#x27;&amp;&#x27;)) != 0) argv[--argc] = NULL; return bg;&#125; 8.5 信号Linux信号: 软件形式的异常 8.5.1 信号的术语发送信号到用户进程的步骤： 发送信号。 方式： 更新进程上下文的状态。 发送信号的原因： 1. 监测到异常、2进程调用了kill。 接收信号。进程接收信号并将信号转移给信号处理程序。 8.5.2 发送信号1. 进程组12345#include&lt;unistd.h&gt;pid getgrp(void); // 返回进程的进程组id// 子进程与父进程的进程组id默认相同int setpgid(pid_t pid, pid_t pgid); // 改变进程的进程组id 2. 用&#x2F;bin&#x2F;kill程序发送信号1234linux&gt; /bin/kill -9 15213// 发送信号SIGKILL给pid为15213的进程linux&gt; /bin/kill -9 -15213// 发送信号SIGKILL给pgid为15213下的所有进程 3.从键盘发送信号12Ctrl + C // 终止前台作业Ctrl + C // 挂起前台作业 4. 用kill函数发送信号1","categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"}],"tags":[{"name":"os","slug":"os","permalink":"https://www.napleon.cn/tags/os/"}]},{"title":"教你如何给C盘扩容","slug":"教你如何给C盘扩容","date":"2022-06-30T06:36:42.000Z","updated":"2023-03-29T02:51:34.185Z","comments":true,"path":"2022/06/30/教你如何给C盘扩容/","link":"","permalink":"https://www.napleon.cn/2022/06/30/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99C%E7%9B%98%E6%89%A9%E5%AE%B9/","excerpt":"","text":"前言作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。 &lt;! –more–&gt; 磁盘的分区右击‘此电脑’，可以看到‘管理’，点开‘管理’。进入管理界面后，点击左侧的“磁盘管理”，即可进入电脑的磁盘页面。可以看到，我的电脑有两个磁盘，其中磁盘0未分区，磁盘1分为C、D两个分区。首先要压缩D盘，如果你有多个磁盘也可以压缩别的磁盘，但不建议这样做。因为磁盘的读取方式不一致可能会造成错误。右击分区D，选择压缩分区，并输入你要压缩的空间大小。压缩后，你可以看到现在有了未分配的空间。检查一下，可以发现，当前未分配的空间可以给D盘扩容，但却不能给C盘扩容。这是因为逻辑分区之间具有顺序关系。可以理解成当前未分配的空间只能给它前面的分区扩容，而不能给它不相邻的分区扩容。只使用系统的磁盘管理器是不能直接给C盘扩容的，除非先把数据拷贝好，然后将D盘格式化，再重新将1磁盘分区。这样过于麻烦，下面介绍一下利用软件给C盘扩容的方法。 使用DiskGenius实现无损扩容DiskGenius是一款免费的国产磁盘管理软件，它能够直接用未分区的逻辑分区给主分区扩容。前往DiskGenius的官网可直接下载。进入软件，选中C盘，点击上方的分区选项卡选择扩容分区。但现在还别着急，磁盘中可能有的簇未使用，却被标记成了已使用。为了解决这一问题，需要按Windows+x，选择‘Windows PowerShell’，进入管理员界面。在命令行中键入chkdsk /f /x c:,其中’c’代表盘符，建议对所有盘都扫描一遍，保证不出问题。回到刚才的步骤，现在选择未分配的空间，然后按照提示进行操作。然后选中‘重启’,等待软件进行操作，重启两次后，你的C盘就扩容成功了！ 总结网上的教程鱼龙混杂，大多是互相复制粘贴，好多操作都已经过时了，为了扩容C盘我花费了一下午，到处参考教程，不断的试错，最终写成了这篇博客，如果你觉得有用的话，可以分享给你的朋友哦。","categories":[{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}],"categories":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/categories/CSAPP/"},{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"os","slug":"os","permalink":"https://www.napleon.cn/tags/os/"},{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}