{"meta":{"title":"Napleon","subtitle":"Napleon的个人博客","description":"Talk is cheap, give me the code.","author":"napleon-liu","url":"https://www.napleon.cn","root":"/"},"pages":[{"title":"about","date":"2023-03-29T07:23:32.000Z","updated":"2023-03-29T07:24:11.628Z","comments":true,"path":"about/index.html","permalink":"https://www.napleon.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T02:46:26.935Z","comments":true,"path":"categories/index.html","permalink":"https://www.napleon.cn/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2023-03-29T02:45:21.000Z","updated":"2023-03-29T09:02:18.622Z","comments":true,"path":"guestbook/index.html","permalink":"https://www.napleon.cn/guestbook/index.html","excerpt":"","text":"欢迎来到我的博客！ 欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的，添加email可以获得更快的回复速度，在nickname栏目输入QQ号可以直接获取你的QQ头像。"},{"title":"tags","date":"2023-03-29T02:48:59.000Z","updated":"2023-03-29T02:49:18.511Z","comments":true,"path":"tags/index.html","permalink":"https://www.napleon.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iris-day2","slug":"iris-day2","date":"2023-04-10T12:53:21.000Z","updated":"2023-04-11T06:21:13.823Z","comments":true,"path":"2023/04/10/iris-day2/","link":"","permalink":"https://www.napleon.cn/2023/04/10/iris-day2/","excerpt":"","text":"MVC架构","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"浅谈mmap","slug":"浅谈mmap","date":"2023-04-09T13:13:58.000Z","updated":"2023-04-09T13:36:32.233Z","comments":true,"path":"2023/04/09/浅谈mmap/","link":"","permalink":"https://www.napleon.cn/2023/04/09/%E6%B5%85%E8%B0%88mmap/","excerpt":"mmap能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。普通文件在被映射到进程地址空间后，进程可以像访问普通内存一样访问文件，不必通过read()、write()等系统调用来访问文件。","text":"mmap能将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。普通文件在被映射到进程地址空间后，进程可以像访问普通内存一样访问文件，不必通过read()、write()等系统调用来访问文件。 mmap接口描述1234567891011121314151617#include &lt;sys/mman.h&gt;void *mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);// addr: 内存空间上的起始地址，一般为NULL，内核自动分配// length: 字节数// prot: 共享内存的访问权限/*PROT_READPROT_WRITEPROT_EXECPROT_NONE*/// flags:// fd: 文件描述符// offset: 偏移量// 返回值: 文件映射到进程空间的地址。 匿名映射匿名映射没有对应的文件。fork()得到的子进程会拷贝父进程映射后的空间，同时也继承了mmap()的返回地址，从而实现进程间的通信。 12345678910111213141516// 匿名映射的例子ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);pid = fork();switch(pid) &#123; case pid &lt; 0: printf(&quot;err\\n&quot;); break; case pid = 0: lock(ptr); critical_section(); unlock(ptr); case pid &gt; 0: lock(ptr); critical_section(); unlock(ptr);&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"}]},{"title":"7:链接","slug":"7-链接","date":"2023-04-09T08:24:36.000Z","updated":"2023-04-09T13:36:46.552Z","comments":true,"path":"2023/04/09/7-链接/","link":"","permalink":"https://www.napleon.cn/2023/04/09/7-%E9%93%BE%E6%8E%A5/","excerpt":"链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。","text":"链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。 7.1 编译器驱动程序下面是两个运行示例： 1234567891011121314151617181920// main.cint fum(int *a, int n);int array[2] = &#123;1, 2&#125;;int main() &#123; int val = sum(array, 2); return val;&#125;// sum.cint sum(int *a, int n) &#123; int i, s = 0; for (int i = 0; i &lt; n; i++) &#123; s += a[i]; &#125; return s;&#125;// Linux下编译该C程序的命令linux&gt; gcc -Og -o prog main.c sum.c 7.2 静态链接静态链接器 (static linker)以一组可重定向的目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。 input: ​ 由各种不同的的代码和数据节构成，每一节都是一个连续的字节序列。 链接器的任务： 符号解析。将每个符号引用与每个符号定义关联起来。 重定位。 编译器和汇编器生成从地址0开始代码和数据节。链接器通过把每个符号定义和内存位置关联起来，从而重定向这些节。然后修改所有对这些符号的引用。使得他们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。 7.3 目标文件目标文件有三种形式： 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。 7.4 可重定向目标文件下图展示了一个典型的ELF可重定向目标文件的格式。 ELF 头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节： .text：已编译程序的机器代码。 .rodata：只读数据，比如 printf 语句中的格式串和开关语句的跳转表。 .data：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。 .bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。 .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。 .rel.text：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。 .rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。 .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。 .line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。 .strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。 7.5 符号和符号表在链接器的上下文中，有三种不同的符号： 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。 由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。 只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。 .symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理。 123456789// ELF符号表条目typedef struct &#123; int name; // 字符串表中的字节偏移 char type:4; // 函数或者数据 char binding:4; // 本地或者全局 short section; // 分配的目标文件的节 long value; // 对齐要求 long size; // 最小的大小&#125; 7.6 符号解析7.6.1 链接器如何解析多重定义的全局符号在编译时，编译器向汇编器输出每个全局符号的强弱类型。汇编器将这个信息编码在可重定向目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 链接器处理多重定义的符号名的规则如下： 规则 1：不允许有多个同名的强符号。 规则 2：如果有一个强符号和多个弱符号同名，那么选择强符号。 规则 3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。 7.6.2 与静态链接库编译系统提供了一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，可以作为链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标板块。 与静态库链接的示意图如下图所示： 7.6.3 链接器如何使用静态库来解析引用7.9 加载可执行目标文件当在命令号中键入 1linux &gt; ./prog Shell调用被称为加载器的操作系统代码来运行该可执行目标文件。任何Linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存当中，然后通过跳转到程序的第一条指令或入口点来运行该程序。 7.10 动态链接共享库共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序来执行的。共享库也称为共享目标（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。 动态链接过程如下图所示： 为了构造图中示例向量例程的共享库，我们调用编译器驱动程序，给编译器和链接器如下指令： 123linux &gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c// -shared选项指示链接器创建一个共享的目标文件// -fpic选项指示编译器生成与位置无关的代码 链接的指令： 1linux &gt; gcc -o prog2l main2.c ./libvector.so","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}]},{"title":"10:系统级IO","slug":"10-系统级IO","date":"2023-04-08T04:20:32.000Z","updated":"2023-04-08T11:00:05.816Z","comments":true,"path":"2023/04/08/10-系统级IO/","link":"","permalink":"https://www.napleon.cn/2023/04/08/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/","excerpt":"I&#x2F;O是在主存和外部设备之间拷贝数据的过程。本章介绍Unix I&#x2F;O 和一般I&#x2F;O的基本概念。并展示在C程序中如何可靠地使用这些接口。","text":"I&#x2F;O是在主存和外部设备之间拷贝数据的过程。本章介绍Unix I&#x2F;O 和一般I&#x2F;O的基本概念。并展示在C程序中如何可靠地使用这些接口。 10.1 Unix I&#x2F;O在UNIX系统中，一切都被认为是字节序列(文件), 因而所有的输入域输出都能以统一的方式进行。 打开文件 内核打开文件后，会返回一个小的非负整数，叫做 描述符 ，用于表示文件。 改变当前文件的位置 内核保持文件位置k，是文件开头起始的字节偏移量。seek操作可以显式的设置文件的当前位置k。 读写文件 读操作。从文件拷贝n个字节到存储器，偏移量k&#x3D;k+n。若文件大小为m，当k大于等于m时，触发EOF。 写操作。从存储器拷贝n&gt;0个字节到一个文件，文件k&#x3D; k + n。 关闭文件 10.2 打开和关闭文件open函数 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(char* filename, int flags, mode_t mode);// flags// O_RDONLY: 只读// O_WRONLY: 只写// O_RDWR: 读写// O_CREAT: 如果文件不存在，就创建它的一个截断的文件// O_TRUNC: 如果文件已经存在，就截断它// O_APPEND 打开文件时设置文件位置到文件的结尾处/*mode: 新文件的访问权限位*/ 10.3 读写文件123456789#include &lt;unistd.h&gt;ssize_t read(int fd, void* buf, size_t n);ssize_t write(int fd, const void* buf, size_t, n);// 返回值// 成功：读/写的字节数// EOF: 0// 失败： -1 123//ssize_t和size_t的区别typedef ssize_t int;typedef size_t unsigned int; 10.4 用RIO包健壮的读写10.4.1 RIO无缓冲输入输出函数12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;csapp.h&quot;ssize_t rio_readn(int fd, void* usrbuf, size_t n);ssize_t rio_writen(int fd, void* usrbuf, size_t n);// 返回值与read和write类似ssize_t rio_readn(int fd, void* userbuf, size_t n) &#123; size_t nleft = n; ssize_t nread; char* bufp = usrbuf; while (nleft &gt; 0) &#123; if ((nread = read(fd, bufp, nleft)) &lt; 0) &#123; if (errno = EINTR) nread = 0; else return -1; &#125; else if (nread == 0) break; nleft -= nread; bufp += nread; &#125; return (n - nleft);&#125;ssize_t rio_writen(int fd, void* usrbuf, size_t n) &#123; size_t nleft = n; ssize_t nwritten; char* bufp = usrbuf; while (nleft &gt; 0) &#123; if ((nwritten = write(fd, bufp, nleft)) &lt;= 0) &#123; if (errno == EINTR) nwritten = 0; else return -1; &#125; nleft -= nwritten; bufp += nwritten; &#125; return n;&#125; 10.4.2 RIO带缓冲的输入函数123456void rio_readinitb(rio_t* rp, int fd);// 将描述符fd和地址rp处读缓冲区联系起来void rio_readlineb(rio_t* rp, void* usrbuf, size_t maxlen);// 从一个内部 读缓冲区 拷贝一个文本行，当缓冲区变空时，会自动调用read重新填满缓冲区。最多写maxlen - 1 个字节，然后用一个空字符截断。ssize_t rio_readnb(rio_t* rp, void* usrbuf, size_t n);// 从文件rp中最多读n个字节到存储器位置usrbuf。 123456789101112// 从标准输入拷贝一个文本文件到标准输出#include &quot;csapp.h&quot;int main(int argc, char** argv) &#123; int n; rio_t rio; char buf[MAXLINE]; Rio_readinitb(&amp;rio, STDIN_FILENO); while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) Rio_writen(STDOUT_FILENO, buf, n);&#125; 12345678// 一个类型为rio_t的读缓冲区#define RIO_BUFSIZE 8192typedef struct &#123; int rio_fd; // 缓冲区关联的文件描述符 int rio_cnt; // 缓冲区中未读的字节数 char* rio_bufptr; // 缓冲区中下一个字节的位置 char rio_buf[RIO_BUFSIZE]; // 内部缓冲区大小&#125; 123456// rio_readinitb函数void rio_readinitb(rio_t* rp, int fd) &#123; rp-&gt;rio_fd = fd; rp-&gt;rio_cnt = 0; rp-&gt;rio_bufptr = rp-&gt;rio_buf;&#125; 1234567891011121314151617181920212223// rio_read函数static ssize_t rio_read(rio_t* rp, char* usrbuf, size_t n) &#123; int cnt; while (rp-&gt;rio_cnt &lt;= 0) &#123; if (rp-&gt;rio_cnt &lt; 0) &#123; if (errno !=EINTR) return -1; &#125; else if (rp-&gt;rio_cnt == 0) return 0; else rp-&gt;rio_bufptr = rp-&gt;rio_buf; &#125; cnt = n; if (rp-&gt;rio_cnt &lt; 0) cnt = rp-&gt;rio_cnt; memcpy(usrbuf, rp-&gt;rio_bufptr, cnt); rp-&gt;rio_bufptr += cnt; rp-&gt;rio_cnt -= cnt; return cnt;&#125; 123456789101112131415161718192021// rio_readlineb 的一个实现ssize_t rio_readlineb(rio_t* rp, void* usrbuf, size_t maxlen) &#123; int n, rc; char c, *bufp = usrbuf; for (n = 1; n &lt; maxlen; n++) &#123; if ((rc = rio_read(rp, &amp;c, 1)) == 1) &#123; *bufp++ = c; if (c == &#x27;\\n&#x27;) break; &#125; else if ((rc == 0)) &#123; if (n == 1) return 0; // EOF, no data read else break; // EOF, read some data; &#125; else return -1; &#125; *bufp = 0; return n;&#125; 10.5 读取文件元数据12345678910111213141516171819202122#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int stat(const char* filename, struct stat* buf);int fstat(int fd, struct stat* buf);// 函数输入的数据结构struct stat &#123; dev_t st_dev; // 设备 ino_t st_ino; // inode mode_t st_mode; // 保护和文件类型 nlink_t st_nlink; // 硬链接数目 uit_t st_uid; // 文件拥有者的用户ID gid_t st_gid; // 文件拥有者的组ID dev_t st_rdev; // 设备类型 off_t st_size; // 总大小(字节) unsigned long st_blksize; // 文件系统I/O的块大小 unsigned long st_blocks; // 分配的块数 time_t st_atime; // 最后一次进入的时间 time_t st_mtime; // 最后一次更新的时间 time_t st_ctime; // 最后一次改变的时间&#125; 1234567891011121314151617181920// 查询和处理一个文件的st_mode位#include &quot;csapp.h&quot;int main(int argc, char** argv) &#123; struct stat stat; char* type, *readok; Stat(argv[1], &amp;stat); if (S_ISREG(stat.st_mode)) type = &quot;regular&quot;; else if (S_ISDIR(stat.st_mode)) type = &quot;directory&quot;; else type = &quot;other&quot;; if ((stat.st_mode &amp; S_ISUSR)) readok = &quot;yes&quot;; else readok = &quot;no&quot;; printf(&quot;type: %s, read: %s\\n&quot;, type, readok); exit(0);&#125; 10.6 共享文件内核用三个相关的数据结构描述打开的文件： 描述符表。 每个进程都有独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。 文件表。打开的文件的集合，由所有的进程共享。 v-node表。同文件表一样，由所有的进程共享。 10.7 I&#x2F;O重定向Unix Shell提供了I&#x2F;O重定向机制，允许用户将磁盘文件和标准输入输出联系起来。例如： unix&gt; ls &gt; foo.txt 下面使用dup2函数实现I&#x2F;O重定向。 1234#include &lt;unistd.h&gt;int dup2(int oldfd, int new fd);// dup2函数拷贝描述符表表项oldfd到描述符表表项newfd，覆盖描述符表表项newfd以前的内容。","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}]},{"title":"iris:day1","slug":"iris-day1","date":"2023-04-08T02:45:15.000Z","updated":"2023-04-10T12:52:31.892Z","comments":true,"path":"2023/04/08/iris-day1/","link":"","permalink":"https://www.napleon.cn/2023/04/08/iris-day1/","excerpt":"Iris是一个Go语言下的MVC框架。","text":"Iris是一个Go语言下的MVC框架。 概览MVC架构模式的示意图： 下面是一个使用MVC架构实现的一个简单Iris App 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( &quot;github.com/kataras/iris&quot; &quot;github.com/kataras/iris/middleware/logger&quot; &quot;github.com/kataras/iris/middleware/recover&quot; &quot;github.com/kataras/iris/mvc&quot;)func main() &#123; app := iris.New() app.Use(recover.New()) app.Use(logger.New())mvc.New(app).Handle(new(ExampleController)) // http://localhost:8080 // http://localhost:8080/ping // http://localhost:8080/hello app.Run(iris.Addr(&quot;:8080&quot;))&#125;// ExampleController serves the &quot;/&quot;, &quot;/ping&quot; and &quot;/hello&quot;.type ExampleController struct &#123;&#125;// Get serves// Method: GET// Resource: http://localhost:8080func (c *ExampleController) Get() mvc.Result &#123; return mvc.Response&#123; ContentType: &quot;text/html&quot;, Text: &quot;&lt;h1&gt;Welcome&lt;/h1&gt;&quot;, &#125;&#125;// GetPing serves// Method: GET// Resource: http://localhost:8080/pingfunc (c *ExampleController) GetPing() string &#123; return &quot;pong&quot;&#125;// GetHello serves// Method: GET// Resource: http://localhost:8080/hellofunc (c *ExampleController) GetHello() interface&#123;&#125; &#123; return map[string]string&#123;&quot;message&quot;: &quot;Hello Iris!&quot;&#125;&#125; HTTP主机配置监听和服务服务器的初始化用Run方法执行 12345678910111213// 在 Tcp 上监听网络地址 0.0.0.0:8080app.Run(iris.Addr(&quot;:8080&quot;))// 和前面一样，但是使用自定义 http.Server 也可以在其他地方运行app.Run(iris.Server(&amp;http.Server&#123;Addr:&quot;:8080&quot;&#125;))// 创建一个自定义的或者标准的net.Listener并传递给app.Run// 使用自定义 net.Listenerl, err := net.Listen(&quot;tcp4&quot;, &quot;:8080&quot;)if err != nil &#123; panic(err)&#125;app.Run(iris.Listener(l)) 下面是一个完整的例子 1234567891011121314151617181920212223242526272829package mainimport ( &quot;os&quot; &quot;net&quot; &quot;github.com/kataras/iris&quot;)func main() &#123; app := iris.New() // UNIX socket if errOs := os.Remove(socketFile); errOs != nil &amp;&amp; !os.IsNotExist(errOs) &#123; app.Logger().Fatal(errOs) &#125; l, err := net.Listen(&quot;unix&quot;, socketFile) if err != nil &#123; app.Logger().Fatal(err) &#125; if err = os.Chmod(socketFile, mode); err != nil &#123; app.Logger().Fatal(err) &#125; app.Run(iris.Listener(l))&#125; 主机配置程序以上所有的监听都是接收 func(*iris.Supervisor)为最后一个变量。可以通过这些函数传递的特定主机来添加配置程序。 下面的示例代码在服务器关闭时触发一个回调函数 12345app.Run(iris.Addr(&quot;:8080&quot;, func(h *iris.Supervisor) &#123; h.RegisterOnShutdown(func() &#123; println(&quot;server terminated&quot;) &#125;)&#125;)) HTTP路由Handler Handler 用于处理请求 APIiris提供了所有的HTTP方法，第一个参数是路由路径，第二个可变参数是一个或者多个iris.Handler 1234567891011121314151617181920212223242526272829303132333435app := iris.New()// 方法: &quot;GET&quot;app.Get(&quot;/&quot;, handler)// 方法: &quot;POST&quot;app.Post(&quot;/&quot;, handler)// 方法: &quot;PUT&quot;app.Put(&quot;/&quot;, handler)// 方法: &quot;DELETE&quot;app.Delete(&quot;/&quot;, handler)// 方法: &quot;OPTIONS&quot;app.Options(&quot;/&quot;, handler)// 方法: &quot;TRACE&quot;app.Trace(&quot;/&quot;, handler)// 方法: &quot;CONNECT&quot;app.Connect(&quot;/&quot;, handler)// 方法: &quot;HEAD&quot;app.Head(&quot;/&quot;, handler)// 方法: &quot;PATCH&quot;app.Patch(&quot;/&quot;, handler)// 用于所有 HTTP 方法app.Any(&quot;/&quot;, handler)func handler(ctx iris.Context)&#123; ctx.Writef(&quot;Hello from method: %s and path: %s&quot;, ctx.Method(), ctx.Path())&#125; 路由分组一组路由可以用前缀路径分组，组之间共享相同的中间件和模板布局，组内可以嵌套组。 .Party 被用于分组路由，开发者可以声明不限数量的分组。 示例代码： 12345678app := iris.New()users := app.Party(&quot;/users&quot;, myAuthMiddlewareHandler)// http://localhost:8080/users/42/profileusers.Get(&quot;/&#123;id:int&#125;/profile&quot;, userProfileHandler)// http://localhost:8080/users/messages/1users.Get(&quot;/messages/&#123;id:int&#125;&quot;, userMessageHandler) Context机制上下文是服务器用于所有客户端的中间人“对象” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421// 上下文是服务器用于所有客户端的中间人 &quot;对象&quot;。// // 对于每一个新的连接，会从 sync.Pool 中获取一个新上下文对象。// 上下文是 iris 的 http 流中最重要的部分。//// 开发者发送响应到客户端的请求通过一个上下文。// 开发者获取请求信息从客户端的请求上下文中。// // context 是 context.Context 子包的一个实现。// context.Context 是很好扩展，所以开发者可以按照实际所需重写它的方法。type Context interface &#123; // ResponseWriter 如期返回一个兼容 http.ResponseWriter 的 响应writer。 ResponseWriter() ResponseWriter // ResetResponseWriter 应该改变或者升级上下文的 ResponseWriter。 ResetResponseWriter(ResponseWriter) // Request 方法如期返回原始的 *http.Request。 Request() *http.Request // SetCurrentRouteName 方法设置内部路由名称，为了当开发者调用 // `GetCurrentRoute()` 方法的时候能够正确返回当前 「只读」 路由。 // 它使用 Router 初始化，如果你手动更改了名称，除了当你是使用`GetCurrentRoute()` // 的时候将获取到其他路由，其它没啥变化。 // 为了从上下文中执行一个不同的路径，你应该使用 `Exec` 函数， // 或者通过 `SetHandlers/AddHandler` 函数改变处理方法。 SetCurrentRouteName(currentRouteName string) // GetCurrentRoute 返回当前注册到当前请求路径的 「只读」路由。 GetCurrentRoute() RouteReadOnly // AddHandler 可以在服务时添加处理方法到当前请求，但是这些处理方法不会持久化到路由。 // // Router 将会调用这些添加到某个路由的处理方法。如果 AddHandler 被调用， // 那么处理方法将被添加到已经定义的路由的处理方法的后面。 AddHandler(...Handler) // SetHandlers 替换所有原有的处理方法。 SetHandlers(Handlers) // Handlers 记录当前的处理方法。 Handlers() Handlers // HandlerIndex 设置当前上下文处理方法链中当前索引。 // 如果传入 -1 ，不会当前索引。 // // 也可以查看 Handlers(), Next() and StopExecution()。 HandlerIndex(n int) (currentIndex int) // HandlerName 返回当前路由名称，方便调试。 HandlerName() string // Next 调用从处理方法链中选择剩下的进行调用，他应该被用于一个中间件中。 // // 提醒：自定义的上下文应该重写这个方法，以便能够传入他自己的 context.Context 实现。 Next() // NextHandler 从处理链中返回下一个处理方法(但不执行)。 // // 为了执行下一个 ，可以使用 .Skip() 跳过某个处理方法。 NextHandler() Handler // Skip 从处理链中 忽略/跳过 下一个处理方法。 // 它应该在中间件内使用。 Skip() // 如果调用了 StopExecution ，接下来的 .Next 调用将被局略。 StopExecution() // IsStopped 检查当前位置的Context是否是255, 如果是, 则返回true, 意味着 StopExecution() 被调用了。 IsStopped() bool // +------------------------------------------------------------+ // | 当前的 &quot;user/request&quot; 存储 | // | 处理方法之间共享信息 - Values(). | // | 保存并获取路径参数 - Params() | // +------------------------------------------------------------+ // Params 返回当前URL中的命名参数。命名的路径参数是被保存在这里的。 // 这个存储对象随着整个上下文，存活于每个请求声明周期。 Params() *RequestParams // Values 返回当前 「用户」的存储信息。 // 命名路径参数和任何可选数据可以保存在这里。 // 这个存储对象，也是存在于整个上下文，每个请求的声明周期中。 // // 你可以用这个函数设置和获取用于在处理方法和中间件之间共享信息的局部值。 Values() *memstore.Store // Translate 是 i18n 函数，用于本地化。它调用 Get(&quot;translate&quot;) 返回翻译值。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/miscellaneous/i18n Translate(format string, args ...interface&#123;&#125;) string // +------------------------------------------------------------+ // | 路径, 主机, 子域名, IP, HTTP 头 等 | // +------------------------------------------------------------+ // Method 返回 request.Method， 客户端的请求方法。 Method() string // Path 返回完整请求路径，如果 EnablePathEscape 为 True，将会转义。 Path() string // RequestPath 返回转义过的请求完整路径。 RequestPath(escape bool) string // Host 返回当前URL的主机部分。 Host() string // Subdomain 返回当前请求的子域名，如果有。 // 提醒，这个方法可能在某些情况下不能正常使用。 Subdomain() (subdomain string) // RemoteAddr 尝试解析并返回客户端正式IP。 // // 基于允许的头名称，可以通过 Configuration.RemoteAddrHeaders 修改。 // // 如果基于这些请求头的解析失败，将会 Request 的 `RemoteAddr` 字段，它在 Http 处理方法之前有 server 填充。 // // 查看 `Configuration.RemoteAddrHeaders`, // `Configuration.WithRemoteAddrHeader(...)`, // `Configuration.WithoutRemoteAddrHeader(...)` 获取更多信息。 RemoteAddr() string // GetHeader 返回指定的请求头值。 GetHeader(name string) string // IsAjax 返回这个请求是否是一个 &#x27;ajax request&#x27;( XMLHttpRequest)。 // // 不能百分之百确定一个请求是否是Ajax模式。 // 永远不要信任来自客户端的数据，他们很容易被篡改。 // // 提醒，&quot;X-Requested-With&quot; 头可以被任何客户端修改，对于十分严重的情况，不要依赖于 IsAjax。 // 试试另外的鉴别方式，例如，内容类型（content-type）。 // 有很多描述这些问题的博客并且提供了很多不同的解决方案，这就是为什么说 `IsAjax` // 太简单，只能用于一般目的。 // // 更多请看： https://developer.mozilla.org/en-US/docs/AJAX // 以及： https://xhr.spec.whatwg.org/ IsAjax() bool // +------------------------------------------------------------+ // | 响应头助手 | // +------------------------------------------------------------+ // Header 添加响应头到响应 writer。 Header(name string, value string) // ContentType 设置响应头 &quot;Content-Type&quot; 为 &#x27;cType&#x27;。 ContentType(cType string) // GetContentType 返回响应头 &quot;Content-Type&quot; 的值。 GetContentType() string // StatusCode 设置响应状态码。 // 也可查看 .GetStatusCode。 StatusCode(statusCode int) // GetStatusCode 返回当前响应的状态码。 // 也可查阅 StatusCode。 GetStatusCode() int // Redirect 发送一个重定向响应到客户端，接受两个参数，字符串和可选的证书。 // 第一个参数是重定向的URL，第二个是重定向状态码，默认是302。 // 如果必要，你可以设置为301，代表永久转义。 Redirect(urlToRedirect string, statusHeader ...int) // +------------------------------------------------------------+ // | 各种请求和 POST 数据 | // +------------------------------------------------------------+ // URLParam 返回请求中的参数，如果有。 URLParam(name string) string // URLParamInt 从请求返回 int 类型的URL参数，如果解析失败，返回错误。 URLParamInt(name string) (int, error) // URLParamInt64 从请求返回 int64 类型的参数，如果解析失败，返回错误。 URLParamInt64(name string) (int64, error) // URLParams 返回请求查询参数映射，如果没有，返回为空。 URLParams() map[string]string // FormValue 返回一个表单值。 FormValue(name string) string // FormValues 从 data，get，post 和 查询参数中返回所有的数据值以及他们的键。 // // 提醒: 检查是否是 nil 是很有必要的。 FormValues() map[string][]string // PostValue 仅仅根据名称返回表单的post值，类似于 Request.PostFormValue。 PostValue(name string) string // FormFile 返回键指定的第一个文件。 // 如果有必要，FormFile 调用 ctx.Request.ParseMultipartForm 和 ParseForm。 // // 类似于 Request.FormFile. FormFile(key string) (multipart.File, *multipart.FileHeader, error) // +------------------------------------------------------------+ // | 自定义 HTTP 错误 | // +------------------------------------------------------------+ // NotFound 发送一个 404 错误到客户端，使用自定义的错误处理方法。 // 如果你不想剩下的处理方法被执行，你可能需要去调用 ctx.StopExecution()。 // 你可以将错误码改成更具体的，例如： // users := app.Party(&quot;/users&quot;) // users.Done(func(ctx context.Context)&#123; if ctx.StatusCode() == 400 &#123; /* custom error code for /users */ &#125;&#125;) NotFound() // +------------------------------------------------------------+ // | Body Readers | // +------------------------------------------------------------+ // SetMaxRequestBodySize 设置请求体大小的上限，应该在读取请求体之前调用。 SetMaxRequestBodySize(limitOverBytes int64) // UnmarshalBody 读取请求体，并把它绑定到一个任何类型或者指针的值。 // 使用实例: context.ReadJSON, context.ReadXML。 UnmarshalBody(v interface&#123;&#125;, unmarshaler Unmarshaler) error // ReadJSON 从请求体读取 JSON，并把它绑定到任何json有效类型的值。 ReadJSON(jsonObject interface&#123;&#125;) error // ReadXML 从请求体读取 XML，并把它绑定到任何xml有效类型的值。 ReadXML(xmlObject interface&#123;&#125;) error // ReadForm 是用表单数据绑定 formObject，支持任何类型的结构体。 ReadForm(formObject interface&#123;&#125;) error // +------------------------------------------------------------+ // | Body (raw) Writers | // +------------------------------------------------------------+ // Write 将数据作为一个HTTP响应的一部分写入连接。 // // 如果 WriteHeader 还没有调用，Write 将在 写入数据之前调用 WriteHeader(http.StatusOK)。 // 如果 Header 没有 Content-Type，Write 添加一个 Content-Type，设置为写入数据的前 // 512 字节的类型。 // // 取决于 HTTP 版本和客户端，调用 Write 或者 WriteHeader 可能组织以后读取 Request.Body。 // 对于 HTTP/1.x 请求，处理方法应该在写入响应之前读取所有必要的请求体数据。一旦 HTTP 头被清掉 // (显示调用 Flusher.Flush 或者写入了足够的数据触发了清空操作)，请求体可能变得不可用。 // 对于 HTTP/2 请求，Go HTTP 服务器允许在写入响应的同时读取请求体。然而，这种行为可能不被所有 // HTTP/2 客户端支持。处理方法应该尽可能读取最大量的数据在写入之前。 Write(body []byte) (int, error) // Writef 根据格式声明器格式化，然后写入响应。 // // 返回写入的字节数量以及任何写入错误。 Writef(format string, args ...interface&#123;&#125;) (int, error) // WriteString 将一个简单的字符串写入响应。 // // 返回写入的字节数量以及任何写入错误。 WriteString(body string) (int, error) // WriteWithExpiration 很像 Write，但是它发送了一个失效时间，它会被每个包级别的 // `StaticCacheDuration` 字段刷新。 WriteWithExpiration(body []byte, modtime time.Time) (int, error) // StreamWriter 注册给定的流用于发布响应体。 // // 这个函数可能被用于一下这些情况： // // * 如果响应体太大（超过了iris.LimitRequestBodySize） // * 如果响应体是慢慢从外部资源流入 // * 如果响应体必须分片流向客户端（例如 `http server push`） StreamWriter(writer func(w io.Writer) bool) // +------------------------------------------------------------+ // | 带压缩的 Body Writers | // +------------------------------------------------------------+ // 如果客户端支持 gzip 压缩，ClientSupportsGzip 返回 true。 ClientSupportsGzip() bool // WriteGzip accepts bytes, which are compressed to gzip format and sent to the client. // WriteGzip 接受压缩成 gzip 格式的字节然后发送给客户端，并返回写入的字节数量和错误（如果错误不支持 gzip 格式） // // 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。 WriteGzip(b []byte) (int, error) // TryWriteGzip 接受 gzip 格式压缩的字节，然后发送给客户端。 // 如果客户端不支持 gzip，就按照他们原来未压缩的样子写入。 // // 这个函数写入临时的 gzip 内容，ResponseWriter 不会改变。 TryWriteGzip(b []byte) (int, error) // GzipResponseWriter converts the current response writer into a response writer // GzipResponseWriter 将当前的响应 writer 转化为一个 gzip 响应 writer。 // 当它的 .Write 方法被调用的时候，数据被压缩成 gzip 格式然后把他们写入客户端。 // // 也可以使用 .Disable 禁用以及使用 .ResetBody 回滚到常规的响应写入器。 GzipResponseWriter() *GzipResponseWriter // Gzip 开启或者禁用 gzip 响应写入器，如果客户端支持 gzip 压缩，所以接下来的响应数据将被作为 // 压缩的 gzip 数据发送给客户端。 Gzip(enable bool) // +------------------------------------------------------------+ // | 富文本内容渲染器 | // +------------------------------------------------------------+ // ViewLayout 设置 「布局」选项，如果随后在相同的请求中 .View 被调用。 // 当需要去改变或者设置处理链中前一个方法的布局时很有用。 // // 注意 &#x27;layoutTmplFile&#x27; 参数可以被设置为 iris.NoLayout 或者 view.NoLayout 去禁用某个试图渲染动作的布局。 // 它禁用了配置项的布局属性。 // // 也可查看 .ViewData 和 .View。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/ ViewLayout(layoutTmplFile string) // ViewData 保存一个或者多个键值对为了在后续的 .View 被调用的时候使用。 // 当需要处理链中前一个处理器的模板数据的时候是很有用的。 // // 如果 .View 的绑定参数不是 nil 也不是 map 类型，这些数据就会被忽略，绑定是有优先级的，所以住路由的处理方法仍然有效。 // 如果绑定是一个map或者context.Map，这些数据然后就被添加到视图数据然后传递给模板。 // // .View 调用之后，这些数据不会被丢掉，为了在必要的时候重用（再次声明，同一个请求中），为了清除这些数据，开发者可以调用 // ctx.Set(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey(), nil)。 // // 如果 &#x27;key&#x27; 是空的，然后 值被作为它的（struct 或者 map）添加，并且开发者不能添加其他值。 // // 推荐查看 .ViewLayout 和 .View。 // // 示例：https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/ ViewData(key string, value interface&#123;&#125;) // GetViewData 返回 `context#ViewData` 注册的值。 // 返回值是 `map[string]interface&#123;&#125;` 类型，这意味着如果一个自定义的结构体被添加到 ViewData， 这个函数将把它解析成 // map，如果失败返回 nil。 // 如果不同类型的值或者没有数据通过 `ViewData` 注册，检查是否为nil总是好的编程规范。 // // 类似于 `viewData := ctx.Values().Get(&quot;iris.viewData&quot;)` 或者 // `viewData := ctx.Values().Get(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey())`。 GetViewData() map[string]interface&#123;&#125; // View 基于适配的视图引擎渲染模板。第一个参数是接受相对于视图引擎目录的文件名， // 例如如果目录是 &quot;./templates&quot;，想要渲染： &quot;./templates/users/index.html&quot; // 你应该传递 &quot;users/index.html&quot; 作为文件名参数。 // 也可以查看 .ViewData 和 .ViewLayout。 // 示例：https://github.com/kataras/iris/tree/master/_examples/view/ View(filename string) error // Binary 将原生字节作为二进制数据返回。 Binary(data []byte) (int, error) // Text 将字符串作为空白文本返回。 Text(text string) (int, error) // HTML 将字符串作为 text/html 返回. HTML(htmlContents string) (int, error) // JSON 格式化给定的数据并且返回 json 数据。 JSON(v interface&#123;&#125;, options ...JSON) (int, error) // JSONP 格式化给定的数据并且返回 json 数据。 JSONP(v interface&#123;&#125;, options ...JSONP) (int, error) // XML 格式话给定数据，并返回 XML 数据。 XML(v interface&#123;&#125;, options ...XML) (int, error) // Markdown 解析 markdown 数据为 HTML 返回给客户端。 Markdown(markdownB []byte, options ...Markdown) (int, error) // +------------------------------------------------------------+ // | 文件响应 | // +------------------------------------------------------------+ // ServeContent 返回的内容头是自动设置的，接受三个参数，它是一个低级的函数，你可以调用 .ServeFile(string,bool)/SendFile(string,string)。 // 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，不要实现 resuming，而应该使用 ctx.SendFile。 ServeContent(content io.ReadSeeker, filename string, modtime time.Time, gzipCompression bool) error // ServeFile 渲染一个视图文件，如果要发送一个文件（例如zip文件）到客户端，你应该使用 SendFile(serverfilename,clientfilename)。 // 接受两个参数： // filename/path (string) // gzipCompression (bool) // 这个函数调用之后，你可以定义自己的 &quot;Content-Type&quot; 头，这个函数没有实现 resuming，你应该使用 ctx.SendFile。 ServeFile(filename string, gzipCompression bool) error // SendFile 发送强制下载的文件到客户端 // // 使用这个而不是 ServeFile 用于大文件下载到客户端。 SendFile(filename string, destinationName string) error // +------------------------------------------------------------+ // | Cookies | // +------------------------------------------------------------+ // SetCookie 添加cookie SetCookie(cookie *http.Cookie) // SetCookieKV 添加一个 cookie，仅仅接受一个名字（字符串）和一个值（字符串） // // 如果你用这个方法设置cookie，它将在两小时之后失效。 // 如果你想去设置或者改变更多字段，使用 ctx.SetCookie 或者 http.SetCookie。 SetCookieKV(name, value string) // GetCookie 通过名称返回值，如果没找到返回空字符串。 GetCookie(name string) string // RemoveCookie 通过名字删除 cookie。 RemoveCookie(name string) // VisitAllCookies 接受一个 visitor 循环每个cookie，visitor 接受两个参数：名称和值。 VisitAllCookies(visitor func(name string, value string)) // MaxAge 返回 &quot;cache-control&quot; 请求头的值，单位为：秒，类型为 int64 // 如果头没有发现或者解析失败返回 -1。 MaxAge() int64 // +------------------------------------------------------------+ // | 高级部分: 响应记录器和事务 | // +------------------------------------------------------------+ // Record 转化上下文基本的 responseWriter 为 ResponseRecorder，它可以被用于在任何时候重置内容体， // 重置响应头，获取内容体，获取和设置状态码。 Record() // Recorder 返回上下文的 ResponseRecorder，如果没有 recording 然后它将开始记录并返回新的上下文的 ResponseRecorder。 Recorder() *ResponseRecorder // IsRecording 返回响应记录器以及一个bool值 // true 表示响应记录器正在记录状态码，内容体，HTTP 头以及更多，否则就是 false IsRecording() (*ResponseRecorder, bool) // BeginTransaction 开启一个有界事务。 // // 你可以搜索第三方文章或者查看事务 Transaction 如何工作（这里相当简单特别）。 // // 记着这个是唯一的，也是新的，目前为止，我没有在这个项目中看到任何例子和代码，就大多数 iris 功能而言。 // 它没有覆盖所有路径，例如数据库，这个应该由你使用的创建数据库连接的库管理，这个事务域仅仅用于上下文响应， // // 阅读 https://github.com/kataras/iris/tree/master/_examples/ 查看更多。 BeginTransaction(pipe func(t *Transaction)) // 如果调用 SkipTransactions 将跳过剩余的事务，或者如果在第一个事务之前调用，将跳过所有 SkipTransactions() // TransactionsSkipped 返回事务到底被跳过还是被取消了。 TransactionsSkipped() bool // Exec根据这个上下文调用framewrok的ServeCtx，但是改变了方法和路径，就像用户请求的那样，但事实并非如此。 // // 离线意味着路线已注册到 iris 并具有正常路由所具有的所有功能。 // 但是它不能通过浏览获得，它的处理程序仅在其他处理程序的上下文调用它们时执行，它可以验证路径，拥有会话，路径参数等。 // // 你可以通过 app.GetRoute(&quot;theRouteName&quot;) 找到路由，你可以设置一个路由名称如： // myRoute := app.Get(&quot;/mypath&quot;, handler)(&quot;theRouteName&quot;) // 这个将给路由设置一个名称并且返回它的 RouteInfo 实例为了进一步使用。 // // 它不会更改全局状态，如果路由处于“脱机”状态，它将保持脱机状态。 // // app.None(...) and app.GetRoutes().Offline(route)/.Online(route, method) // // 实例：https://github.com/kataras/iris/tree/master/_examples/routing/route-state // // 用户可以通过简单调用得到响应：rec := ctx.Recorder(); rec.Body()/rec.StatusCode()/rec.Header() // // Context 的 Values 和 Session 被记住为了能够通过结果路由通信， // // 它仅仅由于特别案例，99% 的用户不会用到的。 Exec(method string, path string) // Application 返回 属于这个上下文的 iris 实例。 // 值得留意的是这个函数返回 Application 的一个接口，它包含的方法能够安全地在运行是执行。 // 为了开发者的安全性，整个 app 的 字段和方法这里是不可用的。 Application() Application","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"go:并发","slug":"go-并发","date":"2023-04-07T10:59:37.000Z","updated":"2023-04-08T01:39:44.562Z","comments":true,"path":"2023/04/07/go-并发/","link":"","permalink":"https://www.napleon.cn/2023/04/07/go-%E5%B9%B6%E5%8F%91/","excerpt":"Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。","text":"Go语言使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数。同一个程序中的所有goroutine共享一个地址空间。 123456789101112131415161718package main import ( &quot;fmt&quot; &quot;time&quot;)func say(s string) &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(s) &#125;&#125;func main () &#123; go say(&quot;world&quot;) say(&quot;hello&quot;)&#125;// 该代码的运行结果不唯一，因为是两个goroutine在执行 通道通道是用来传递数据的数据结构 通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符&lt;-用于制定通道的方向，如果未指定方向，则为双向通道。 12345ch &lt;- v // 把v发送到chv := &lt;-ch // 从ch接收数据 // 并把值赋给v// 声明一个通道ch := make(chan int) 默认情况下，通道是不带缓冲区的。 带缓冲区的通道通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小： 1ch := make(chan int, 100) 如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 Go通过range关键字来实现遍历读取到的数据，格式如下： 1v, ok := &lt;- ch 关闭通道如果通道接收不到数据后ok就为false，这时通道就可以使用close函数来关闭。 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot;)func fibonacci(n int, c chan int) &#123; x, y := 0, 1 for i := 0; i &lt; n; i++ &#123; c &lt;- x x, y = y, x + y &#125; close(c)&#125;func main() &#123; c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c &#123; fmt.Println(i) &#125;&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"go:方法与接口","slug":"go-方法与接口","date":"2023-04-05T02:31:55.000Z","updated":"2023-04-07T10:55:43.215Z","comments":true,"path":"2023/04/05/go-方法与接口/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8E%A5%E5%8F%A3/","excerpt":"7.1 接口的定义Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 12345type iface struct &#123; tab *itab; data unsafe.Pointer &#125;","text":"7.1 接口的定义Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 12345type iface struct &#123; tab *itab; data unsafe.Pointer &#125; 7.2 接口使用实例12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)type Phone interface &#123; // 定义了一个接口Phone, 有方法call() call()&#125;type NokiaPhone struct &#123; // 接口Phone的一个实现&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123; // 接口Phone的一个实现&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone // 利用接口实现多态 phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; ​","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"go:数据","slug":"go-数据","date":"2023-04-05T01:26:17.000Z","updated":"2023-04-07T10:56:23.369Z","comments":true,"path":"2023/04/05/go-数据/","link":"","permalink":"https://www.napleon.cn/2023/04/05/go-%E6%95%B0%E6%8D%AE/","excerpt":"5.1 字符串string字符串是不可变字符序列 默认值为空串，而不是空指针。 遍历 12345678910111213func main() &#123; s := &#x27;Hello, world&#x27; // byte for i := 0; i &lt; len(s); i++ &#123; println(&quot;%d: [%c]\\n&quot;, i, s[i]); &#125; // rune for i, c := range s &#123; println(&quot;%d ,[%c]\\n&quot;, i, c); &#125;&#125;","text":"5.1 字符串string字符串是不可变字符序列 默认值为空串，而不是空指针。 遍历 12345678910111213func main() &#123; s := &#x27;Hello, world&#x27; // byte for i := 0; i &lt; len(s); i++ &#123; println(&quot;%d: [%c]\\n&quot;, i, s[i]); &#125; // rune for i, c := range s &#123; println(&quot;%d ,[%c]\\n&quot;, i, c); &#125;&#125; 5.2 数组5.2.1 数组的初始化1234567891011func main() &#123; var a [4]int // 元素自动初始成0 b := [4]int&#123;2, 5&#125; // 剩余元素自动初始化成0 c := [4]int&#123;5, 3:10&#125;; // 指定索引位置 d := [...]int&#123;1, 2, 3&#125; // 编译器确定数组长度 // 在定义多维数组时， 仅第一维允许使用... b := [...][2]int &#123; &#123;10, 20&#125;, &#123;30 ,40&#125;, &#125;&#125; 5.2.2 指针12345func main() &#123; x, y := 10 ,20 a := [...]*int&#123;&amp;x, &amp;y&#125; // 指针数组 p = &amp;a // 数组指针&#125; 5.2.3 复制与C数组变量隐式作为指针使用不同， Go数组是值类型，赋值和传参工作都会复制整个数组数据 5.3 切片slice本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在制定区域内。 123456// 数据结构type slice strcut &#123; arrary unsafe.Pointer len int // 限定可读的写元素数量 cap int // 切片所引用数组片段的真实长度&#125; 切片本身是一个只读对象， 其工作机制类似数组指针的一种包装 5.3.1 创建切片对象1234func main() &#123; s1 := make([]int, 3, 5) //指定len, cap, 底层数组初始化成零值 s2 := make([int], 3) // 省略cap, 和len相等&#125; 切片是包装过的数组对象，用来代替数组减少值传递带来的开销 5.4 字典基本操作12345678910func main() &#123; m := map[string]int &#123; &quot;a&quot;: 1, &quot;b&quot;: 2, &#125; // 判断key是否存在 if v, ok := m[&quot;d&quot;]; ok &#123; println(v) &#125; // 访问不存在的键值， 默认返回零值&#125;","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"}]},{"title":"vim杂谈","slug":"vim杂谈","date":"2023-04-02T14:25:14.000Z","updated":"2023-04-03T02:56:29.643Z","comments":true,"path":"2023/04/02/vim杂谈/","link":"","permalink":"https://www.napleon.cn/2023/04/02/vim%E6%9D%82%E8%B0%88/","excerpt":"vim是Linux环境下的一款重要的文本编辑器。","text":"vim是Linux环境下的一款重要的文本编辑器。 1. 基本使用1.1 三种基本模式 一般模式 编辑模式 命令行模式 1.2 按键一般模式(hjkl)对应(左下上右) “30j” &#x3D; 向下移动三十行 C+f 屏幕向下移动一页 C+b 屏幕向上移动一页 “+” 光标移动到非空格行的下一行 “-“ 光标移动到非空格行的上一行 n 光标向后移动20个字符的距离 n[Enter] 光标向下移动n行 G 移动到这个文件的最后一行 &#x2F;word 向下寻找名为word的字符串 dd 删除光标所在的一整行 yy 复制一整行 x [delete] X[backsapce] u 复原前一个操作 C+r 重做上一个操作 . 重复前一个操作","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"}]},{"title":"9.虚拟内存","slug":"9-虚拟内存","date":"2023-03-29T07:26:42.000Z","updated":"2023-04-09T02:43:00.308Z","comments":true,"path":"2023/03/29/9-虚拟内存/","link":"","permalink":"https://www.napleon.cn/2023/03/29/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","excerpt":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。","text":"虚拟存储器： 三个能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 为每个进程提供了一致的地址空间，从而简化了存储管理。 保护了每个进程的地址空间不被其他进程破坏。 9.1 物理和虚拟寻址CPU—(VA)–&gt;MMU—-&gt;PA—–&gt;Memory","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}]},{"title":"8.异常控制流","slug":"8-异常控制流","date":"2023-03-29T03:17:27.000Z","updated":"2023-04-09T02:42:33.741Z","comments":true,"path":"2023/03/29/8-异常控制流/","link":"","permalink":"https://www.napleon.cn/2023/03/29/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"CSAPP关于异常处理的章节。","text":"CSAPP关于异常处理的章节。 8.4进程控制8.4.1 获取进程ID12345#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t getpid(void); //获取进程的pidpid_t getppid(void); // 获取进程父进程的pid 8.4.2 创建和终止进程12345678910#include &lt;stdlib.h&gt;/*exit函数以status退出状态来终止进程*/void exit(int status);/*父进程通过调用fork函数创建一个新的运行的子进程*/pid_t fork(void);// 返回值：子进程返回0，父进程返回子进程的PID，如果出错，返回-1. fork被调用一次，却会返回两次：父进程返回子进程的PID，子进程返回0. 12345678910111213141516171819int main() &#123; pid_t pid; int x = 1; pid = fork(); if (pid == 0) &#123; prinf(&quot;child: x = %d\\n&quot;, ++x); exit(0); &#125; prinf(&quot;parent: x = %d\\n&quot;, --x); exit(0);&#125;/*parent: x = 0child: x = 2or child: x = 2parent: x = 0*/ 8.4.3 回收子进程如果一个父进程终止，内核会安排init进程成为他的孤儿进程的养父 8.4.6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* 一个简单的shell的main例程 *//*shellex.c*/#include &quot;csapp.h&quot;#define MAXARGS 128/* Function protoytpes */void eval(char* cmdline);int parseline(char* buf, char** argv);int builtin_command(char** argv);int main() &#123; char cmdline[MAXLINE]; // Command line while (1) &#123; /* Read */ printf(&quot;&gt; &quot;); Fgets(cmdline, MAXLINE, stdin); if (feof(stdin)) exit(0); /* Evaluate */ eval(cmdline); &#125;&#125;/* Evaluate a commmand line*/void eval(char* cmdline) &#123; char* argv[MAXARGS]; char buf[MAXLINE]; int bg; pid_t pid; strcpy(buf, cmdline); bg = parseline(buf, argv); if (argv[0] == NULL) return ; // Ignore empty line if (!builtin_command(argv)) &#123; if ( (pid = Fork()) == 0 ) &#123; if (execve(argv[0], argv, environ) &lt; 0) &#123; printf(&quot;%s: Command not found.\\n&quot;, argv[0]); exit(0); &#125; &#125; // Parent waits for foreground job to terminate if (!bg) &#123; int status; if (waitpid(pid, &amp;status, 0) &lt; 0) unix_error(&quot;waitfg: waitpid error&quot;); &#125; else printf(&quot;%d %s&quot;, pid, cmdline); &#125; return ;&#125;/* If first arg is a builtin command, run it and return true*/int builtin_command(char** argv) &#123; if (!strcmp(argv[0], &quot;quit&quot;)) exit(0); if (!strcmp(argv[0], &quot;&amp;&quot;)) return 1; return 0;&#125;/* parseline - Parse the command line and build the argv array*/int parseline(char* buf, char** argv) &#123; char* delim; // points to the first space delimiter int argc; // number of args int bg; buf[strlen(buf) - 1] = &#x27; &#x27;; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf ++; /* build the argv list */ argc = 0; while ( (delm = strchr(buf, &#x27; &#x27;) ) ) &#123; argv[argc++] = buf; *delim = &#x27;\\0&#x27;; buf = delim + 1; while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) buf++; &#125; argv[argc] = NULL; if (argc == 0) return 1; if ((bg = (*argv[argc - 1] == &#x27;&amp;&#x27;)) != 0) argv[--argc] = NULL; return bg;&#125; 8.5 信号Linux信号: 软件形式的异常 8.5.1 信号的术语发送信号到用户进程的步骤： 发送信号。 方式： 更新进程上下文的状态。 发送信号的原因： 1. 监测到异常、2进程调用了kill。 接收信号。进程接收信号并将信号转移给信号处理程序。 8.5.2 发送信号1. 进程组12345#include&lt;unistd.h&gt;pid getgrp(void); // 返回进程的进程组id// 子进程与父进程的进程组id默认相同int setpgid(pid_t pid, pid_t pgid); // 改变进程的进程组id 2. 用&#x2F;bin&#x2F;kill程序发送信号1234linux&gt; /bin/kill -9 15213// 发送信号SIGKILL给pid为15213的进程linux&gt; /bin/kill -9 -15213// 发送信号SIGKILL给pgid为15213下的所有进程 3.从键盘发送信号12Ctrl + C // 终止前台作业Ctrl + C // 挂起前台作业 4. 用kill函数发送信号1","categories":[],"tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"}]},{"title":"教你如何给C盘扩容","slug":"教你如何给C盘扩容","date":"2022-06-30T06:36:42.000Z","updated":"2023-03-30T12:52:36.321Z","comments":true,"path":"2022/06/30/教你如何给C盘扩容/","link":"","permalink":"https://www.napleon.cn/2022/06/30/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99C%E7%9B%98%E6%89%A9%E5%AE%B9/","excerpt":"前言作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。","text":"前言作为一名深度强迫症患者，我不能容忍电脑中出现任何不合我意的地方。尤其是磁盘爆红。电脑买了一年多了，当时到手时没在意，自带的磁盘被分成了两个区，系统盘C盘只分了100个G的空间，然而系统自身就占去了近一半的空间。一年下来，尽管我尽量将数据存在别的磁盘里，C盘还是渐渐地被各种软件蚕食殆尽。等到我准备采取措施时，C盘的容量已经小于5%了。本文是我查阅了多个教程，并根据自己的踩雷经验整合而成，水平有限，不能保证文章中涵盖了扩容过程可能出现的所有错误。一定要谨慎，数据一旦丢失就不可恢复了。Tips:操作过程中务必将电脑接上电源，以免电脑中途关机，造成不可挽回的损失。 磁盘的分区右击‘此电脑’，可以看到‘管理’，点开‘管理’。进入管理界面后，点击左侧的“磁盘管理”，即可进入电脑的磁盘页面。可以看到，我的电脑有两个磁盘，其中磁盘0未分区，磁盘1分为C、D两个分区。首先要压缩D盘，如果你有多个磁盘也可以压缩别的磁盘，但不建议这样做。因为磁盘的读取方式不一致可能会造成错误。右击分区D，选择压缩分区，并输入你要压缩的空间大小。压缩后，你可以看到现在有了未分配的空间。检查一下，可以发现，当前未分配的空间可以给D盘扩容，但却不能给C盘扩容。这是因为逻辑分区之间具有顺序关系。可以理解成当前未分配的空间只能给它前面的分区扩容，而不能给它不相邻的分区扩容。只使用系统的磁盘管理器是不能直接给C盘扩容的，除非先把数据拷贝好，然后将D盘格式化，再重新将1磁盘分区。这样过于麻烦，下面介绍一下利用软件给C盘扩容的方法。 使用DiskGenius实现无损扩容DiskGenius是一款免费的国产磁盘管理软件，它能够直接用未分区的逻辑分区给主分区扩容。前往DiskGenius的官网可直接下载。进入软件，选中C盘，点击上方的分区选项卡选择扩容分区。但现在还别着急，磁盘中可能有的簇未使用，却被标记成了已使用。为了解决这一问题，需要按Windows+x，选择‘Windows PowerShell’，进入管理员界面。在命令行中键入chkdsk /f /x c:,其中’c’代表盘符，建议对所有盘都扫描一遍，保证不出问题。回到刚才的步骤，现在选择未分配的空间，然后按照提示进行操作。然后选中‘重启’,等待软件进行操作，重启两次后，你的C盘就扩容成功了！ 总结网上的教程鱼龙混杂，大多是互相复制粘贴，好多操作都已经过时了，为了扩容C盘我花费了一下午，到处参考教程，不断的试错，最终写成了这篇博客，如果你觉得有用的话，可以分享给你的朋友哦。","categories":[{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}],"categories":[{"name":"搞机","slug":"搞机","permalink":"https://www.napleon.cn/categories/%E6%90%9E%E6%9C%BA/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.napleon.cn/tags/Go/"},{"name":"Linux","slug":"Linux","permalink":"https://www.napleon.cn/tags/Linux/"},{"name":"CSAPP","slug":"CSAPP","permalink":"https://www.napleon.cn/tags/CSAPP/"},{"name":"computer","slug":"computer","permalink":"https://www.napleon.cn/tags/computer/"}]}